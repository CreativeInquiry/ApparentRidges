// Generated by Haxe 4.1.3
(function ($hx_exports, $global) { "use strict";
$hx_exports["apparentridges"] = $hx_exports["apparentridges"] || {};
$hx_exports["apparentridges"]["_ApparentRidges"] = $hx_exports["apparentridges"]["_ApparentRidges"] || {};
var HxOverrides = function() { };
HxOverrides.__name__ = true;
HxOverrides.cca = function(s,index) {
	var x = s.charCodeAt(index);
	if(x != x) {
		return undefined;
	}
	return x;
};
HxOverrides.substr = function(s,pos,len) {
	if(len == null) {
		len = s.length;
	} else if(len < 0) {
		if(pos == 0) {
			len = s.length + len;
		} else {
			return "";
		}
	}
	return s.substr(pos,len);
};
HxOverrides.remove = function(a,obj) {
	var i = a.indexOf(obj);
	if(i == -1) {
		return false;
	}
	a.splice(i,1);
	return true;
};
HxOverrides.now = function() {
	return Date.now();
};
Math.__name__ = true;
var Std = function() { };
Std.__name__ = true;
Std.string = function(s) {
	return js_Boot.__string_rec(s,"");
};
Std.parseInt = function(x) {
	if(x != null) {
		var _g = 0;
		var _g1 = x.length;
		while(_g < _g1) {
			var i = _g++;
			var c = x.charCodeAt(i);
			if(c <= 8 || c >= 14 && c != 32 && c != 45) {
				var nc = x.charCodeAt(i + 1);
				var v = parseInt(x,nc == 120 || nc == 88 ? 16 : 10);
				if(isNaN(v)) {
					return null;
				} else {
					return v;
				}
			}
		}
	}
	return null;
};
var StringTools = function() { };
StringTools.__name__ = true;
StringTools.isSpace = function(s,pos) {
	var c = HxOverrides.cca(s,pos);
	if(!(c > 8 && c < 14)) {
		return c == 32;
	} else {
		return true;
	}
};
StringTools.ltrim = function(s) {
	var l = s.length;
	var r = 0;
	while(r < l && StringTools.isSpace(s,r)) ++r;
	if(r > 0) {
		return HxOverrides.substr(s,r,l - r);
	} else {
		return s;
	}
};
StringTools.rtrim = function(s) {
	var l = s.length;
	var r = 0;
	while(r < l && StringTools.isSpace(s,l - r - 1)) ++r;
	if(r > 0) {
		return HxOverrides.substr(s,0,l - r);
	} else {
		return s;
	}
};
StringTools.trim = function(s) {
	return StringTools.ltrim(StringTools.rtrim(s));
};
var apparentridges_Util = $hx_exports["apparentridges"]["Util"] = function() { };
apparentridges_Util.__name__ = true;
apparentridges_Util.rndInt = function(x) {
	return Math.round(x) | 0;
};
apparentridges_Util.min = function(a,b) {
	if(a > b) {
		return b;
	} else {
		return a;
	}
};
apparentridges_Util.sq = function(x) {
	return x * x;
};
apparentridges_Util.nextMod3 = function(i) {
	if(i < 2) {
		return i + 1;
	} else {
		return i - 2;
	}
};
apparentridges_Util.prevMod3 = function(i) {
	if(i > 0) {
		return i - 1;
	} else {
		return i + 2;
	}
};
apparentridges_Util.trinorm = function(v0,v1,v2) {
	var this1 = new Array(3);
	var this2 = this1;
	this2[0] = v1[0] - v0[0];
	this2[1] = v1[1] - v0[1];
	this2[2] = v1[2] - v0[2];
	var v1 = this2;
	var this1 = new Array(3);
	var this2 = this1;
	this2[0] = v2[0] - v0[0];
	this2[1] = v2[1] - v0[1];
	this2[2] = v2[2] - v0[2];
	var v2 = this2;
	var this1 = new Array(3);
	var this2 = this1;
	this2[0] = v1[1] * v2[2] - v1[2] * v2[1];
	this2[1] = v1[2] * v2[0] - v1[0] * v2[2];
	this2[2] = v1[0] * v2[1] - v1[1] * v2[0];
	var this1 = this2;
	var this2 = new Array(3);
	var this3 = this2;
	this3[0] = this1[0] * 0.5;
	this3[1] = this1[1] * 0.5;
	this3[2] = this1[2] * 0.5;
	return this3;
};
apparentridges_Util.ldltdc = function(A,rdiag) {
	var N = rdiag.length;
	if(N < 1) {
		return false;
	} else if(N <= 3) {
		var d0 = A[0][0];
		rdiag[0] = 1 / d0;
		if(N == 1) {
			return d0 != 0;
		}
		A[1][0] = A[0][1];
		var l10 = rdiag[0] * A[1][0];
		var d1 = A[1][1] - l10 * A[1][0];
		rdiag[1] = 1 / d1;
		if(N == 2) {
			if(d0 != 0) {
				return d1 != 0;
			} else {
				return false;
			}
		}
		var x = A[2][0];
		var x1 = A[2][1];
		var d2 = A[2][2] - rdiag[0] * (x * x) - rdiag[1] * (x1 * x1);
		rdiag[2] = 1 / d2;
		A[2][0] = A[0][2];
		A[2][1] = A[1][2] - l10 * A[2][0];
		if(d0 != 0 && d1 != 0) {
			return d2 != 0;
		} else {
			return false;
		}
	}
	var v = [];
	var _g = 0;
	var _g1 = N;
	while(_g < _g1) {
		var i = _g++;
		var _g2 = 0;
		var _g3 = i;
		while(_g2 < _g3) {
			var k = _g2++;
			v[k] = A[i][k] * rdiag[k];
		}
		var _g4 = i;
		var _g5 = N;
		while(_g4 < _g5) {
			var j = _g4++;
			var sum = A[i][j];
			var _g6 = 0;
			var _g7 = i;
			while(_g6 < _g7) {
				var k1 = _g6++;
				sum -= v[k1] * A[j][k1];
			}
			if(i == j) {
				if(sum == 0) {
					return false;
				}
				rdiag[i] = 1 / sum;
			} else {
				A[j][i] = sum;
			}
		}
	}
	return true;
};
apparentridges_Util.ldltsl = function(A,rdiag,b,x) {
	var N = rdiag.length;
	var _g = 0;
	var _g1 = N;
	while(_g < _g1) {
		var i = _g++;
		var sum = b[i];
		var _g2 = 0;
		var _g3 = i;
		while(_g2 < _g3) {
			var k = _g2++;
			sum -= A[i][k] * x[k];
		}
		x[i] = sum * rdiag[i];
	}
	var _g = 0;
	var _g1 = N;
	while(_g < _g1) {
		var _i = _g++;
		var i = N - _i - 1;
		var sum = 0;
		var _g2 = i + 1;
		var _g3 = N;
		while(_g2 < _g3) {
			var k = _g2++;
			sum += A[k][i] * x[k];
		}
		x[i] -= sum * rdiag[i];
	}
};
apparentridges_Util.largestEig2x2 = function(m1,m12,m2) {
	var l1 = 0.5 * (m1 + m2);
	if(l1 > 0.0) {
		var x = m2 - m1;
		l1 += Math.sqrt(m12 * m12 + 0.25 * (x * x));
	} else {
		var x = m2 - m1;
		l1 -= Math.sqrt(m12 * m12 + 0.25 * (x * x));
	}
	var this1 = new Array(3);
	var this2 = this1;
	this2[0] = m2 - l1;
	this2[1] = -m12;
	this2[2] = 0;
	var e1 = this2;
	var l = Math.sqrt(e1[0] * e1[0] + e1[1] * e1[1] + e1[2] * e1[2]);
	if(l > 0) {
		l = 1 / l;
		e1[0] *= l;
		e1[1] *= l;
		e1[2] *= l;
	} else {
		e1[0] = 0;
		e1[1] = 0;
		e1[2] = 1;
	}
	e1[2] = l1;
	return e1;
};
apparentridges_Util.matIden = function() {
	return [1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1];
};
apparentridges_Util.matRotx = function(a) {
	return [1,0,0,0,0,Math.cos(a),-Math.sin(a),0,0,Math.sin(a),Math.cos(a),0,0,0,0,1];
};
apparentridges_Util.matRoty = function(a) {
	return [Math.cos(a),0,Math.sin(a),0,0,1,0,0,-Math.sin(a),0,Math.cos(a),0,0,0,0,1];
};
apparentridges_Util.matRotz = function(a) {
	return [Math.cos(a),-Math.sin(a),0,0,Math.sin(a),Math.cos(a),0,0,0,0,1,0,0,0,0,1];
};
apparentridges_Util.matTrsl = function(x,y,z) {
	return [1,0,0,x,0,1,0,y,0,0,1,z,0,0,0,1];
};
apparentridges_Util.matScal = function(x,y,z) {
	return [x,0,0,0,0,y,0,0,0,0,z,0,0,0,0,1];
};
apparentridges_Util.matMult = function(A,B) {
	return [A[0] * B[0] + A[1] * B[4] + A[2] * B[8] + A[3] * B[12],A[0] * B[1] + A[1] * B[5] + A[2] * B[9] + A[3] * B[13],A[0] * B[2] + A[1] * B[6] + A[2] * B[10] + A[3] * B[14],A[0] * B[3] + A[1] * B[7] + A[2] * B[11] + A[3] * B[15],A[4] * B[0] + A[5] * B[4] + A[6] * B[8] + A[7] * B[12],A[4] * B[1] + A[5] * B[5] + A[6] * B[9] + A[7] * B[13],A[4] * B[2] + A[5] * B[6] + A[6] * B[10] + A[7] * B[14],A[4] * B[3] + A[5] * B[7] + A[6] * B[11] + A[7] * B[15],A[8] * B[0] + A[9] * B[4] + A[10] * B[8] + A[11] * B[12],A[8] * B[1] + A[9] * B[5] + A[10] * B[9] + A[11] * B[13],A[8] * B[2] + A[9] * B[6] + A[10] * B[10] + A[11] * B[14],A[8] * B[3] + A[9] * B[7] + A[10] * B[11] + A[11] * B[15],A[12] * B[0] + A[13] * B[4] + A[14] * B[8] + A[15] * B[12],A[12] * B[1] + A[13] * B[5] + A[14] * B[9] + A[15] * B[13],A[12] * B[2] + A[13] * B[6] + A[14] * B[10] + A[15] * B[14],A[12] * B[3] + A[13] * B[7] + A[14] * B[11] + A[15] * B[15]];
};
apparentridges_Util.matTrfm = function(A,v) {
	var this1 = new Array(3);
	var this2 = this1;
	this2[0] = (A[0] * v[0] + A[1] * v[1] + A[2] * v[2] + A[3]) / (A[12] * v[0] + A[13] * v[1] + A[14] * v[2] + A[15]);
	this2[1] = (A[4] * v[0] + A[5] * v[1] + A[6] * v[2] + A[7]) / (A[12] * v[0] + A[13] * v[1] + A[14] * v[2] + A[15]);
	this2[2] = (A[8] * v[0] + A[9] * v[1] + A[10] * v[2] + A[11]) / (A[12] * v[0] + A[13] * v[1] + A[14] * v[2] + A[15]);
	return this2;
};
apparentridges_Util.matProj = function(f,v) {
	var this1 = new Array(3);
	var this2 = this1;
	this2[0] = f * v[0] / v[2];
	this2[1] = f * v[1] / v[2];
	this2[2] = 0;
	return this2;
};
apparentridges_Util.uniformHemisphereSampler = function() {
	var Xi1 = Math.random();
	var Xi2 = Math.random();
	var theta = Math.acos(Xi1);
	var phi = 2 * Math.PI * Xi2;
	var xs = Math.sin(theta) * Math.cos(phi);
	var ys = Math.sin(theta) * Math.sin(phi);
	var zs = Math.cos(theta);
	var this1 = new Array(3);
	var this2 = this1;
	this2[0] = xs;
	this2[1] = ys;
	this2[2] = zs;
	var v = this2;
	return v;
};
var apparentridges_Vec3 = $hx_exports["apparentridges"]["Vec3"] = {};
apparentridges_Vec3._new = function(_x,_y,_z) {
	var this1 = new Array(3);
	var this2 = this1;
	this2[0] = _x;
	this2[1] = _y;
	this2[2] = _z;
	return this2;
};
apparentridges_Vec3.get_x = function(this1) {
	return this1[0];
};
apparentridges_Vec3.get_y = function(this1) {
	return this1[1];
};
apparentridges_Vec3.get_z = function(this1) {
	return this1[2];
};
apparentridges_Vec3.set_x = function(this1,v) {
	return this1[0] = v;
};
apparentridges_Vec3.set_y = function(this1,v) {
	return this1[1] = v;
};
apparentridges_Vec3.set_z = function(this1,v) {
	return this1[2] = v;
};
apparentridges_Vec3.copy = function(this1) {
	var this2 = new Array(3);
	var this3 = this2;
	this3[0] = this1[0];
	this3[1] = this1[1];
	this3[2] = this1[2];
	return this3;
};
apparentridges_Vec3.assign = function(this1,v) {
	this1[0] = v[0];
	this1[1] = v[1];
	this1[2] = v[2];
};
apparentridges_Vec3.cross = function(v1,v2) {
	var this1 = new Array(3);
	var this2 = this1;
	this2[0] = v1[1] * v2[2] - v1[2] * v2[1];
	this2[1] = v1[2] * v2[0] - v1[0] * v2[2];
	this2[2] = v1[0] * v2[1] - v1[1] * v2[0];
	return this2;
};
apparentridges_Vec3.dot = function(v1,v2) {
	return v1[0] * v2[0] + v1[1] * v2[1] + v1[2] * v2[2];
};
apparentridges_Vec3.dist2 = function(v1,v2) {
	var x = v1[0] - v2[0];
	var x1 = v1[1] - v2[1];
	var x2 = v1[2] - v2[2];
	return x * x + x1 * x1 + x2 * x2;
};
apparentridges_Vec3.dist = function(v1,v2) {
	var x = v1[0] - v2[0];
	var x1 = v1[1] - v2[1];
	var x2 = v1[2] - v2[2];
	return Math.sqrt(x * x + x1 * x1 + x2 * x2);
};
apparentridges_Vec3.len = function(this1) {
	return Math.sqrt(this1[0] * this1[0] + this1[1] * this1[1] + this1[2] * this1[2]);
};
apparentridges_Vec3.len2 = function(this1) {
	return this1[0] * this1[0] + this1[1] * this1[1] + this1[2] * this1[2];
};
apparentridges_Vec3.normalize = function(this1) {
	var l = Math.sqrt(this1[0] * this1[0] + this1[1] * this1[1] + this1[2] * this1[2]);
	if(l > 0) {
		l = 1 / l;
		this1[0] *= l;
		this1[1] *= l;
		this1[2] *= l;
	} else {
		this1[0] = 0;
		this1[1] = 0;
		this1[2] = 1;
	}
};
apparentridges_Vec3.scale = function(this1,s) {
	this1[0] *= s;
	this1[1] *= s;
	this1[2] *= s;
};
apparentridges_Vec3.get = function(this1,i) {
	return this1[i];
};
apparentridges_Vec3.set = function(this1,i,v) {
	this1[i] = v;
	return v;
};
apparentridges_Vec3.add = function(this1,rhs) {
	var this2 = new Array(3);
	var this3 = this2;
	this3[0] = this1[0] + rhs[0];
	this3[1] = this1[1] + rhs[1];
	this3[2] = this1[2] + rhs[2];
	return this3;
};
apparentridges_Vec3.sub = function(this1,rhs) {
	var this2 = new Array(3);
	var this3 = this2;
	this3[0] = this1[0] - rhs[0];
	this3[1] = this1[1] - rhs[1];
	this3[2] = this1[2] - rhs[2];
	return this3;
};
apparentridges_Vec3.mul = function(this1,rhs) {
	var this2 = new Array(3);
	var this3 = this2;
	this3[0] = this1[0] * rhs[0];
	this3[1] = this1[1] * rhs[1];
	this3[2] = this1[2] * rhs[2];
	return this3;
};
apparentridges_Vec3.mulf = function(this1,rhs) {
	var this2 = new Array(3);
	var this3 = this2;
	this3[0] = this1[0] * rhs;
	this3[1] = this1[1] * rhs;
	this3[2] = this1[2] * rhs;
	return this3;
};
var apparentridges_Face = $hx_exports["apparentridges"]["Face"] = {};
apparentridges_Face._new = function(a,b,c) {
	var this1 = new Array(3);
	var this2 = this1;
	this2[0] = a;
	this2[1] = b;
	this2[2] = c;
	return this2;
};
apparentridges_Face.get = function(this1,i) {
	return this1[i];
};
apparentridges_Face.set = function(this1,i,v) {
	this1[i] = v;
	return v;
};
apparentridges_Face.indexOf = function(this1,v) {
	if(this1[0] == v) {
		return 0;
	}
	if(this1[1] == v) {
		return 1;
	}
	if(this1[2] == v) {
		return 2;
	}
	return -1;
};
var apparentridges_Ridge = $hx_exports["apparentridges"]["Ridge"] = function(a,sa,b,sb) {
	this.A = a;
	this.strengthA = sa;
	this.B = b;
	this.strengthB = sb;
};
apparentridges_Ridge.__name__ = true;
var apparentridges_BSphere = $hx_exports["apparentridges"]["BSphere"] = function() {
};
apparentridges_BSphere.__name__ = true;
var apparentridges_Mesh = $hx_exports["apparentridges"]["Mesh"] = function() {
	this.Dt1q1 = [];
	this.t1q1 = [];
	this.ndotv = [];
	this.adjacentFaces = [];
	this.cornerAreas = [];
	this.pointAreas = [];
	this.pdir2 = [];
	this.pdir1 = [];
	this.curv2 = [];
	this.curv1 = [];
	this.normals = [];
	this.faces = [];
	this.vertices = [];
};
apparentridges_Mesh.__name__ = true;
apparentridges_Mesh.rotCoordSys = function(old_u,old_v,new_norm,new_u,new_v) {
	new_u[0] = old_u[0];
	new_u[1] = old_u[1];
	new_u[2] = old_u[2];
	new_v[0] = old_v[0];
	new_v[1] = old_v[1];
	new_v[2] = old_v[2];
	var this1 = new Array(3);
	var this2 = this1;
	this2[0] = old_u[1] * old_v[2] - old_u[2] * old_v[1];
	this2[1] = old_u[2] * old_v[0] - old_u[0] * old_v[2];
	this2[2] = old_u[0] * old_v[1] - old_u[1] * old_v[0];
	var old_norm = this2;
	var ndot = old_norm[0] * new_norm[0] + old_norm[1] * new_norm[1] + old_norm[2] * new_norm[2];
	if(ndot <= -1) {
		new_u[0] *= -1;
		new_u[1] *= -1;
		new_u[2] *= -1;
		new_v[0] *= -1;
		new_v[1] *= -1;
		new_v[2] *= -1;
		return;
	}
	var this1 = new Array(3);
	var this2 = this1;
	this2[0] = old_norm[0] * ndot;
	this2[1] = old_norm[1] * ndot;
	this2[2] = old_norm[2] * ndot;
	var rhs = this2;
	var this1 = new Array(3);
	var this2 = this1;
	this2[0] = new_norm[0] - rhs[0];
	this2[1] = new_norm[1] - rhs[1];
	this2[2] = new_norm[2] - rhs[2];
	var perp_old = this2;
	var this1 = new Array(3);
	var this2 = this1;
	this2[0] = old_norm[0] + new_norm[0];
	this2[1] = old_norm[1] + new_norm[1];
	this2[2] = old_norm[2] + new_norm[2];
	var this1 = this2;
	var rhs = 1 / (1 + ndot);
	var this2 = new Array(3);
	var this3 = this2;
	this3[0] = this1[0] * rhs;
	this3[1] = this1[1] * rhs;
	this3[2] = this1[2] * rhs;
	var dperp = this3;
	var rhs = new_u[0] * perp_old[0] + new_u[1] * perp_old[1] + new_u[2] * perp_old[2];
	var this1 = new Array(3);
	var this2 = this1;
	this2[0] = dperp[0] * rhs;
	this2[1] = dperp[1] * rhs;
	this2[2] = dperp[2] * rhs;
	var rhs = this2;
	var this1 = new Array(3);
	var this2 = this1;
	this2[0] = new_u[0] - rhs[0];
	this2[1] = new_u[1] - rhs[1];
	this2[2] = new_u[2] - rhs[2];
	new_u = this2;
	var rhs = new_v[0] * perp_old[0] + new_v[1] * perp_old[1] + new_v[2] * perp_old[2];
	var this1 = new Array(3);
	var this2 = this1;
	this2[0] = dperp[0] * rhs;
	this2[1] = dperp[1] * rhs;
	this2[2] = dperp[2] * rhs;
	var rhs = this2;
	var this1 = new Array(3);
	var this2 = this1;
	this2[0] = new_v[0] - rhs[0];
	this2[1] = new_v[1] - rhs[1];
	this2[2] = new_v[2] - rhs[2];
	new_v = this2;
};
apparentridges_Mesh.projCurv = function(old_u,old_v,old_ku,old_kuv,old_kv,new_u,new_v) {
	var this1 = new Array(3);
	var this2 = this1;
	this2[0] = 0;
	this2[1] = 0;
	this2[2] = 0;
	var r_new_u = this2;
	var this1 = new Array(3);
	var this2 = this1;
	this2[0] = 0;
	this2[1] = 0;
	this2[2] = 0;
	var r_new_v = this2;
	var this1 = new Array(3);
	var this2 = this1;
	this2[0] = old_u[1] * old_v[2] - old_u[2] * old_v[1];
	this2[1] = old_u[2] * old_v[0] - old_u[0] * old_v[2];
	this2[2] = old_u[0] * old_v[1] - old_u[1] * old_v[0];
	apparentridges_Mesh.rotCoordSys(new_u,new_v,this2,r_new_u,r_new_v);
	var u1 = r_new_u[0] * old_u[0] + r_new_u[1] * old_u[1] + r_new_u[2] * old_u[2];
	var v1 = r_new_u[0] * old_v[0] + r_new_u[1] * old_v[1] + r_new_u[2] * old_v[2];
	var u2 = r_new_v[0] * old_u[0] + r_new_v[1] * old_u[1] + r_new_v[2] * old_u[2];
	var v2 = r_new_v[0] * old_v[0] + r_new_v[1] * old_v[1] + r_new_v[2] * old_v[2];
	var new_ku = old_ku * u1 * u1 + old_kuv * (2 * u1 * v1) + old_kv * v1 * v1;
	var new_kuv = old_ku * u1 * u2 + old_kuv * (u1 * v2 + u2 * v1) + old_kv * v1 * v2;
	var new_kv = old_ku * u2 * u2 + old_kuv * (2 * u2 * v2) + old_kv * v2 * v2;
	var this1 = new Array(3);
	var this2 = this1;
	this2[0] = new_ku;
	this2[1] = new_kuv;
	this2[2] = new_kv;
	return this2;
};
apparentridges_Mesh.diagonalizeCurv = function(old_u,old_v,ku,kuv,kv,new_norm,pd1,pd2,k1k2) {
	var this1 = new Array(3);
	var this2 = this1;
	this2[0] = 0;
	this2[1] = 0;
	this2[2] = 0;
	var r_old_u = this2;
	var this1 = new Array(3);
	var this2 = this1;
	this2[0] = 0;
	this2[1] = 0;
	this2[2] = 0;
	var r_old_v = this2;
	apparentridges_Mesh.rotCoordSys(old_u,old_v,new_norm,r_old_u,r_old_v);
	var c = 1;
	var s = 0;
	var tt = 0;
	if(kuv != 0.0) {
		var h = 0.5 * (kv - ku) / kuv;
		tt = h < 0.0 ? 1.0 / (h - Math.sqrt(1.0 + h * h)) : 1.0 / (h + Math.sqrt(1.0 + h * h));
		c = 1.0 / Math.sqrt(1.0 + tt * tt);
		s = tt * c;
	}
	var k1 = ku - tt * kuv;
	var k2 = kv + tt * kuv;
	if(Math.abs(k1) >= Math.abs(k2)) {
		k1k2[0] = k1;
		k1k2[1] = k2;
		var this1 = new Array(3);
		var this2 = this1;
		this2[0] = r_old_u[0] * c;
		this2[1] = r_old_u[1] * c;
		this2[2] = r_old_u[2] * c;
		var this1 = this2;
		var this2 = new Array(3);
		var this3 = this2;
		this3[0] = r_old_v[0] * s;
		this3[1] = r_old_v[1] * s;
		this3[2] = r_old_v[2] * s;
		var rhs = this3;
		var this2 = new Array(3);
		var this3 = this2;
		this3[0] = this1[0] - rhs[0];
		this3[1] = this1[1] - rhs[1];
		this3[2] = this1[2] - rhs[2];
		var v = this3;
		pd1[0] = v[0];
		pd1[1] = v[1];
		pd1[2] = v[2];
	} else {
		k1k2[0] = k2;
		k1k2[1] = k1;
		var this1 = new Array(3);
		var this2 = this1;
		this2[0] = r_old_u[0] * s;
		this2[1] = r_old_u[1] * s;
		this2[2] = r_old_u[2] * s;
		var this1 = this2;
		var this2 = new Array(3);
		var this3 = this2;
		this3[0] = r_old_v[0] * c;
		this3[1] = r_old_v[1] * c;
		this3[2] = r_old_v[2] * c;
		var rhs = this3;
		var this2 = new Array(3);
		var this3 = this2;
		this3[0] = this1[0] + rhs[0];
		this3[1] = this1[1] + rhs[1];
		this3[2] = this1[2] + rhs[2];
		var v = this3;
		pd1[0] = v[0];
		pd1[1] = v[1];
		pd1[2] = v[2];
	}
	var this1 = new Array(3);
	var this2 = this1;
	this2[0] = new_norm[1] * pd1[2] - new_norm[2] * pd1[1];
	this2[1] = new_norm[2] * pd1[0] - new_norm[0] * pd1[2];
	this2[2] = new_norm[0] * pd1[1] - new_norm[1] * pd1[0];
	var v = this2;
	pd2[0] = v[0];
	pd2[1] = v[1];
	pd2[2] = v[2];
};
apparentridges_Mesh.prototype = {
	precompute: function(doBVH,verb) {
		if(verb == null) {
			verb = false;
		}
		if(doBVH == null) {
			doBVH = true;
		}
		if(verb) {
			console.log("apparentridges/ApparentRidges.hx:337:","computing normals...");
		}
		this.computeNormals();
		if(verb) {
			console.log("apparentridges/ApparentRidges.hx:339:","computing point areas...");
		}
		this.computePointAreas();
		if(verb) {
			console.log("apparentridges/ApparentRidges.hx:341:","computing adjacent faces...");
		}
		this.computeAdjacentFaces();
		if(verb) {
			console.log("apparentridges/ApparentRidges.hx:343:","computing curvatures...");
		}
		this.computeCurvatures();
		if(verb) {
			console.log("apparentridges/ApparentRidges.hx:345:","computing bounding sphere...");
		}
		this.computeBSphere();
		if(verb) {
			console.log("apparentridges/ApparentRidges.hx:347:","computing feature size...");
		}
		this.computeFeatureSize();
		if(verb) {
			console.log("apparentridges/ApparentRidges.hx:349:","computing bounding volume hierarchy...");
		}
		if(doBVH) {
			this.computeBVH();
		} else {
			this.computeBVHTrivial();
		}
		if(verb) {
			console.log("apparentridges/ApparentRidges.hx:351:","pre-computation finished.");
		}
	}
	,computeNormals: function() {
		var _g = [];
		var _g1 = 0;
		var _g2 = this.vertices.length;
		while(_g1 < _g2) {
			var i = _g1++;
			var this1 = new Array(3);
			var this2 = this1;
			this2[0] = 0;
			this2[1] = 0;
			this2[2] = 0;
			_g.push(this2);
		}
		this.normals = _g;
		var _g = 0;
		var _g1 = this.faces;
		while(_g < _g1.length) {
			var f = _g1[_g];
			++_g;
			var p0 = this.vertices[f[0]];
			var p1 = this.vertices[f[1]];
			var p2 = this.vertices[f[2]];
			var this1 = new Array(3);
			var this2 = this1;
			this2[0] = p0[0] - p1[0];
			this2[1] = p0[1] - p1[1];
			this2[2] = p0[2] - p1[2];
			var a = this2;
			var this3 = new Array(3);
			var this4 = this3;
			this4[0] = p1[0] - p2[0];
			this4[1] = p1[1] - p2[1];
			this4[2] = p1[2] - p2[2];
			var b = this4;
			var this5 = new Array(3);
			var this6 = this5;
			this6[0] = a[1] * b[2] - a[2] * b[1];
			this6[1] = a[2] * b[0] - a[0] * b[2];
			this6[2] = a[0] * b[1] - a[1] * b[0];
			var fn = this6;
			var tmp = this.normals;
			var f1 = f[0];
			var this7 = this.normals[f[0]];
			var this8 = new Array(3);
			var this9 = this8;
			this9[0] = this7[0] + fn[0];
			this9[1] = this7[1] + fn[1];
			this9[2] = this7[2] + fn[2];
			tmp[f1] = this9;
			var tmp1 = this.normals;
			var f2 = f[1];
			var this10 = this.normals[f[1]];
			var this11 = new Array(3);
			var this12 = this11;
			this12[0] = this10[0] + fn[0];
			this12[1] = this10[1] + fn[1];
			this12[2] = this10[2] + fn[2];
			tmp1[f2] = this12;
			var tmp2 = this.normals;
			var f3 = f[2];
			var this13 = this.normals[f[2]];
			var this14 = new Array(3);
			var this15 = this14;
			this15[0] = this13[0] + fn[0];
			this15[1] = this13[1] + fn[1];
			this15[2] = this13[2] + fn[2];
			tmp2[f3] = this15;
		}
		var _g = 0;
		var _g1 = this.normals;
		while(_g < _g1.length) {
			var n = _g1[_g];
			++_g;
			var l = Math.sqrt(n[0] * n[0] + n[1] * n[1] + n[2] * n[2]);
			if(l > 0) {
				l = 1 / l;
				n[0] *= l;
				n[1] *= l;
				n[2] *= l;
			} else {
				n[0] = 0;
				n[1] = 0;
				n[2] = 1;
			}
		}
	}
	,computeBSphere: function() {
		var _gthis = this;
		this.bsphere = new apparentridges_BSphere();
		var farthestVertexAlong = function(dir) {
			var nv = _gthis.vertices.length;
			var far = 0;
			var v1 = _gthis.vertices[0];
			var far_dot = v1[0] * dir[0] + v1[1] * dir[1] + v1[2] * dir[2];
			var _g = 1;
			var _g1 = nv;
			while(_g < _g1) {
				var i = _g++;
				var v1 = _gthis.vertices[i];
				var my_dot = v1[0] * dir[0] + v1[1] * dir[1] + v1[2] * dir[2];
				if(my_dot > far_dot) {
					far = i;
					far_dot = my_dot;
				}
			}
			return far;
		};
		var this1 = new Array(3);
		var this2 = this1;
		this2[0] = 0;
		this2[1] = 0;
		this2[2] = 0;
		var best_min = this2;
		var this1 = new Array(3);
		var this2 = this1;
		this2[0] = 0;
		this2[1] = 0;
		this2[2] = 0;
		var best_max = this2;
		var this1 = new Array(3);
		var this2 = this1;
		this2[0] = 1;
		this2[1] = 0;
		this2[2] = 0;
		var this1 = new Array(3);
		var this3 = this1;
		this3[0] = 0;
		this3[1] = 1;
		this3[2] = 0;
		var this1 = new Array(3);
		var this4 = this1;
		this4[0] = 0;
		this4[1] = 0;
		this4[2] = 1;
		var this1 = new Array(3);
		var this5 = this1;
		this5[0] = 1;
		this5[1] = 1;
		this5[2] = 1;
		var this1 = new Array(3);
		var this6 = this1;
		this6[0] = 1;
		this6[1] = -1;
		this6[2] = 1;
		var this1 = new Array(3);
		var this7 = this1;
		this7[0] = 1;
		this7[1] = -1;
		this7[2] = -1;
		var this1 = new Array(3);
		var this8 = this1;
		this8[0] = 1;
		this8[1] = 1;
		this8[2] = 1;
		var dirs = [this2,this3,this4,this5,this6,this7,this8];
		var _g = 0;
		while(_g < dirs.length) {
			var d = dirs[_g];
			++_g;
			var p1 = this.vertices;
			var this1 = new Array(3);
			var this2 = this1;
			this2[0] = d[0] * -1.0;
			this2[1] = d[1] * -1.0;
			this2[2] = d[2] * -1.0;
			var p11 = p1[farthestVertexAlong(this2)];
			var p2 = this.vertices[farthestVertexAlong(d)];
			var x = p11[0] - p2[0];
			var x1 = p11[1] - p2[1];
			var x2 = p11[2] - p2[2];
			var x3 = best_min[0] - best_max[0];
			var x4 = best_min[1] - best_max[1];
			var x5 = best_min[2] - best_max[2];
			if(x * x + x1 * x1 + x2 * x2 > x3 * x3 + x4 * x4 + x5 * x5) {
				best_min = p11;
				best_max = p2;
			}
		}
		var this1 = new Array(3);
		var this2 = this1;
		this2[0] = best_min[0] + best_max[0];
		this2[1] = best_min[1] + best_max[1];
		this2[2] = best_min[2] + best_max[2];
		var this1 = this2;
		var this2 = new Array(3);
		var this3 = this2;
		this3[0] = this1[0] * 0.5;
		this3[1] = this1[1] * 0.5;
		this3[2] = this1[2] * 0.5;
		this.bsphere.o = this3;
		var x = best_min[0] - best_max[0];
		var x1 = best_min[1] - best_max[1];
		var x2 = best_min[2] - best_max[2];
		this.bsphere.r = Math.sqrt(x * x + x1 * x1 + x2 * x2) * 0.5;
		var x = this.bsphere.r;
		var r2 = x * x;
		var _g = 0;
		var _g1 = this.vertices.length;
		while(_g < _g1) {
			var i = _g++;
			var v1 = this.vertices[i];
			var v2 = this.bsphere.o;
			var x = v1[0] - v2[0];
			var x1 = v1[1] - v2[1];
			var x2 = v1[2] - v2[2];
			var d2 = x * x + x1 * x1 + x2 * x2;
			if(d2 <= r2) {
				continue;
			}
			var d = Math.sqrt(d2);
			this.bsphere.r = 0.5 * (this.bsphere.r + d);
			var x3 = this.bsphere.r;
			r2 = x3 * x3;
			var this1 = this.bsphere.o;
			var rhs = this.vertices[i];
			var this2 = new Array(3);
			var this3 = this2;
			this3[0] = this1[0] - rhs[0];
			this3[1] = this1[1] - rhs[1];
			this3[2] = this1[2] - rhs[2];
			this.bsphere.o = this3;
			var this4 = this.bsphere.o;
			var rhs1 = this.bsphere.r * (1.0 / d);
			var this5 = new Array(3);
			var this6 = this5;
			this6[0] = this4[0] * rhs1;
			this6[1] = this4[1] * rhs1;
			this6[2] = this4[2] * rhs1;
			this.bsphere.o = this6;
			var this7 = this.bsphere.o;
			var rhs2 = this.vertices[i];
			var this8 = new Array(3);
			var this9 = this8;
			this9[0] = this7[0] + rhs2[0];
			this9[1] = this7[1] + rhs2[1];
			this9[2] = this7[2] + rhs2[2];
			this.bsphere.o = this9;
		}
	}
	,computeFeatureSize: function() {
		var nv = this.curv1.length;
		var nsamp = nv > 500 ? 500 : nv;
		var samples = [];
		var s = 79;
		var p = 103;
		var q = 211;
		var m = p * q;
		var _g = 0;
		var _g1 = nsamp;
		while(_g < _g1) {
			var i = _g++;
			var ind = nv * (s / m) | 0;
			s = s * s % m;
			samples.push(Math.abs(this.curv1[ind]));
			samples.push(Math.abs(this.curv2[ind]));
		}
		var frac = 0.1;
		var mult = 0.01;
		var max_feat_size = 0.05 * this.bsphere.r;
		var which = frac * samples.length | 0;
		samples.sort(function(a,b) {
			if(a < b) {
				return -1;
			} else if(a > b) {
				return 1;
			} else {
				return 0;
			}
		});
		this.featureSize = Math.min(mult / samples[which],max_feat_size);
	}
	,computeAdjacentFaces: function() {
		var _g = [];
		var _g1 = 0;
		var _g2 = this.vertices.length;
		while(_g1 < _g2) {
			var i = _g1++;
			_g.push([]);
		}
		this.adjacentFaces = _g;
		var _g = 0;
		var _g1 = this.faces.length;
		while(_g < _g1) {
			var i = _g++;
			this.adjacentFaces[this.faces[i][0]].push(i);
			this.adjacentFaces[this.faces[i][1]].push(i);
			this.adjacentFaces[this.faces[i][2]].push(i);
		}
	}
	,getFaceEdges: function(f) {
		var this1 = new Array(3);
		var e = this1;
		var this1 = this.vertices[f[2]];
		var rhs = this.vertices[f[1]];
		var this2 = new Array(3);
		var this3 = this2;
		this3[0] = this1[0] - rhs[0];
		this3[1] = this1[1] - rhs[1];
		this3[2] = this1[2] - rhs[2];
		e[0] = this3;
		var this1 = this.vertices[f[0]];
		var rhs = this.vertices[f[2]];
		var this2 = new Array(3);
		var this3 = this2;
		this3[0] = this1[0] - rhs[0];
		this3[1] = this1[1] - rhs[1];
		this3[2] = this1[2] - rhs[2];
		e[1] = this3;
		var this1 = this.vertices[f[1]];
		var rhs = this.vertices[f[0]];
		var this2 = new Array(3);
		var this3 = this2;
		this3[0] = this1[0] - rhs[0];
		this3[1] = this1[1] - rhs[1];
		this3[2] = this1[2] - rhs[2];
		e[2] = this3;
		return e;
	}
	,computePointAreas: function() {
		var nf = this.faces.length;
		var nv = this.vertices.length;
		var _g = [];
		var _g1 = 0;
		var _g2 = nv;
		while(_g1 < _g2) {
			var i = _g1++;
			_g.push(0);
		}
		this.pointAreas = _g;
		var _g = [];
		var _g1 = 0;
		var _g2 = nf;
		while(_g1 < _g2) {
			var i = _g1++;
			var this1 = new Array(3);
			var this2 = this1;
			this2[0] = 0;
			this2[1] = 0;
			this2[2] = 0;
			_g.push(this2);
		}
		this.cornerAreas = _g;
		var _g = 0;
		var _g1 = nf;
		while(_g < _g1) {
			var i = _g++;
			var e = this.getFaceEdges(this.faces[i]);
			var v1 = e[0];
			var v2 = e[1];
			var this1 = new Array(3);
			var this2 = this1;
			this2[0] = v1[1] * v2[2] - v1[2] * v2[1];
			this2[1] = v1[2] * v2[0] - v1[0] * v2[2];
			this2[2] = v1[0] * v2[1] - v1[1] * v2[0];
			var this3 = this2;
			var area = 0.5 * Math.sqrt(this3[0] * this3[0] + this3[1] * this3[1] + this3[2] * this3[2]);
			var this4 = e[0];
			var l2_0 = this4[0] * this4[0] + this4[1] * this4[1] + this4[2] * this4[2];
			var this5 = e[1];
			var l2_1 = this5[0] * this5[0] + this5[1] * this5[1] + this5[2] * this5[2];
			var this6 = e[2];
			var l2_2 = this6[0] * this6[0] + this6[1] * this6[1] + this6[2] * this6[2];
			var bcw_0 = l2_0 * (l2_1 + l2_2 - l2_0);
			var bcw_1 = l2_1 * (l2_2 + l2_0 - l2_1);
			var bcw_2 = l2_2 * (l2_0 + l2_1 - l2_2);
			if(bcw_0 <= 0) {
				var v11 = e[0];
				var v21 = e[2];
				var v = -0.25 * l2_2 * area / (v11[0] * v21[0] + v11[1] * v21[1] + v11[2] * v21[2]);
				this.cornerAreas[i][1] = v;
				var v12 = e[0];
				var v22 = e[1];
				var v3 = -0.25 * l2_1 * area / (v12[0] * v22[0] + v12[1] * v22[1] + v12[2] * v22[2]);
				this.cornerAreas[i][2] = v3;
				var v4 = area - this.cornerAreas[i][1] - this.cornerAreas[i][2];
				this.cornerAreas[i][0] = v4;
			} else if(bcw_1 <= 0.0) {
				var v13 = e[1];
				var v23 = e[0];
				var v5 = -0.25 * l2_0 * area / (v13[0] * v23[0] + v13[1] * v23[1] + v13[2] * v23[2]);
				this.cornerAreas[i][2] = v5;
				var v14 = e[1];
				var v24 = e[2];
				var v6 = -0.25 * l2_2 * area / (v14[0] * v24[0] + v14[1] * v24[1] + v14[2] * v24[2]);
				this.cornerAreas[i][0] = v6;
				var v7 = area - this.cornerAreas[i][2] - this.cornerAreas[i][0];
				this.cornerAreas[i][1] = v7;
			} else if(bcw_2 <= 0.0) {
				var v15 = e[2];
				var v25 = e[1];
				var v8 = -0.25 * l2_1 * area / (v15[0] * v25[0] + v15[1] * v25[1] + v15[2] * v25[2]);
				this.cornerAreas[i][0] = v8;
				var v16 = e[2];
				var v26 = e[0];
				var v9 = -0.25 * l2_0 * area / (v16[0] * v26[0] + v16[1] * v26[1] + v16[2] * v26[2]);
				this.cornerAreas[i][1] = v9;
				var v10 = area - this.cornerAreas[i][0] - this.cornerAreas[i][1];
				this.cornerAreas[i][2] = v10;
			} else {
				var scale = 0.5 * area / (bcw_0 + bcw_1 + bcw_2);
				var v17 = scale * (bcw_1 + bcw_2);
				this.cornerAreas[i][0] = v17;
				var v18 = scale * (bcw_2 + bcw_0);
				this.cornerAreas[i][1] = v18;
				var v19 = scale * (bcw_0 + bcw_1);
				this.cornerAreas[i][2] = v19;
			}
			this.pointAreas[this.faces[i][0]] += this.cornerAreas[i][0];
			this.pointAreas[this.faces[i][1]] += this.cornerAreas[i][1];
			this.pointAreas[this.faces[i][2]] += this.cornerAreas[i][2];
		}
	}
	,computeCurvatures: function() {
		var nv = this.vertices.length;
		var nf = this.faces.length;
		var _g = [];
		var _g1 = 0;
		var _g2 = nv;
		while(_g1 < _g2) {
			var i = _g1++;
			_g.push(0);
		}
		this.curv1 = _g;
		var _g = [];
		var _g1 = 0;
		var _g2 = nv;
		while(_g1 < _g2) {
			var i = _g1++;
			_g.push(0);
		}
		this.curv2 = _g;
		var _g = [];
		var _g1 = 0;
		var _g2 = nv;
		while(_g1 < _g2) {
			var i = _g1++;
			var this1 = new Array(3);
			var this2 = this1;
			this2[0] = 0;
			this2[1] = 0;
			this2[2] = 0;
			_g.push(this2);
		}
		this.pdir1 = _g;
		var _g = [];
		var _g1 = 0;
		var _g2 = nv;
		while(_g1 < _g2) {
			var i = _g1++;
			var this1 = new Array(3);
			var this2 = this1;
			this2[0] = 0;
			this2[1] = 0;
			this2[2] = 0;
			_g.push(this2);
		}
		this.pdir2 = _g;
		var _g = [];
		var _g1 = 0;
		var _g2 = nv;
		while(_g1 < _g2) {
			var i = _g1++;
			_g.push(0);
		}
		var curv12 = _g;
		var _g = 0;
		var _g1 = nf;
		while(_g < _g1) {
			var i = _g++;
			var tmp = this.pdir1;
			var tmp1 = this.faces[i][0];
			var this1 = this.vertices[this.faces[i][1]];
			var rhs = this.vertices[this.faces[i][0]];
			var this2 = new Array(3);
			var this3 = this2;
			this3[0] = this1[0] - rhs[0];
			this3[1] = this1[1] - rhs[1];
			this3[2] = this1[2] - rhs[2];
			tmp[tmp1] = this3;
			var tmp2 = this.pdir1;
			var tmp3 = this.faces[i][1];
			var this4 = this.vertices[this.faces[i][2]];
			var rhs1 = this.vertices[this.faces[i][1]];
			var this5 = new Array(3);
			var this6 = this5;
			this6[0] = this4[0] - rhs1[0];
			this6[1] = this4[1] - rhs1[1];
			this6[2] = this4[2] - rhs1[2];
			tmp2[tmp3] = this6;
			var tmp4 = this.pdir1;
			var tmp5 = this.faces[i][2];
			var this7 = this.vertices[this.faces[i][0]];
			var rhs2 = this.vertices[this.faces[i][2]];
			var this8 = new Array(3);
			var this9 = this8;
			this9[0] = this7[0] - rhs2[0];
			this9[1] = this7[1] - rhs2[1];
			this9[2] = this7[2] - rhs2[2];
			tmp4[tmp5] = this9;
		}
		var _g = 0;
		var _g1 = nv;
		while(_g < _g1) {
			var i = _g++;
			var tmp = this.pdir1;
			var v1 = this.pdir1[i];
			var v2 = this.normals[i];
			var this1 = new Array(3);
			var this2 = this1;
			this2[0] = v1[1] * v2[2] - v1[2] * v2[1];
			this2[1] = v1[2] * v2[0] - v1[0] * v2[2];
			this2[2] = v1[0] * v2[1] - v1[1] * v2[0];
			tmp[i] = this2;
			var this3 = this.pdir1[i];
			var l = Math.sqrt(this3[0] * this3[0] + this3[1] * this3[1] + this3[2] * this3[2]);
			if(l > 0) {
				l = 1 / l;
				this3[0] *= l;
				this3[1] *= l;
				this3[2] *= l;
			} else {
				this3[0] = 0;
				this3[1] = 0;
				this3[2] = 1;
			}
			var tmp1 = this.pdir2;
			var v11 = this.normals[i];
			var v21 = this.pdir1[i];
			var this4 = new Array(3);
			var this5 = this4;
			this5[0] = v11[1] * v21[2] - v11[2] * v21[1];
			this5[1] = v11[2] * v21[0] - v11[0] * v21[2];
			this5[2] = v11[0] * v21[1] - v11[1] * v21[0];
			tmp1[i] = this5;
		}
		var _g = 0;
		var _g1 = nf;
		while(_g < _g1) {
			var i = _g++;
			var f = this.faces[i];
			var e = this.getFaceEdges(f);
			var this1 = e[0];
			var this2 = new Array(3);
			var this3 = this2;
			this3[0] = this1[0];
			this3[1] = this1[1];
			this3[2] = this1[2];
			var t = this3;
			var l = Math.sqrt(t[0] * t[0] + t[1] * t[1] + t[2] * t[2]);
			if(l > 0) {
				l = 1 / l;
				t[0] *= l;
				t[1] *= l;
				t[2] *= l;
			} else {
				t[0] = 0;
				t[1] = 0;
				t[2] = 1;
			}
			var v1 = e[0];
			var v2 = e[1];
			var this4 = new Array(3);
			var this5 = this4;
			this5[0] = v1[1] * v2[2] - v1[2] * v2[1];
			this5[1] = v1[2] * v2[0] - v1[0] * v2[2];
			this5[2] = v1[0] * v2[1] - v1[1] * v2[0];
			var n = this5;
			var this6 = new Array(3);
			var this7 = this6;
			this7[0] = n[1] * t[2] - n[2] * t[1];
			this7[1] = n[2] * t[0] - n[0] * t[2];
			this7[2] = n[0] * t[1] - n[1] * t[0];
			var b = this7;
			var l1 = Math.sqrt(b[0] * b[0] + b[1] * b[1] + b[2] * b[2]);
			if(l1 > 0) {
				l1 = 1 / l1;
				b[0] *= l1;
				b[1] *= l1;
				b[2] *= l1;
			} else {
				b[0] = 0;
				b[1] = 0;
				b[2] = 1;
			}
			var m = [0,0,0];
			var w = [[0,0,0],[0,0,0],[0,0,0]];
			var _g2 = 0;
			while(_g2 < 3) {
				var j = _g2++;
				var v11 = e[j];
				var u = v11[0] * t[0] + v11[1] * t[1] + v11[2] * t[2];
				var v12 = e[j];
				var v = v12[0] * b[0] + v12[1] * b[1] + v12[2] * b[2];
				w[0][0] += u * u;
				w[0][1] += u * v;
				w[2][2] += v * v;
				var this8 = this.normals[f[j > 0 ? j - 1 : j + 2]];
				var rhs = this.normals[f[j < 2 ? j + 1 : j - 2]];
				var this9 = new Array(3);
				var this10 = this9;
				this10[0] = this8[0] - rhs[0];
				this10[1] = this8[1] - rhs[1];
				this10[2] = this8[2] - rhs[2];
				var dn = this10;
				var dnu = dn[0] * t[0] + dn[1] * t[1] + dn[2] * t[2];
				var dnv = dn[0] * b[0] + dn[1] * b[1] + dn[2] * b[2];
				m[0] += dnu * u;
				m[1] += dnu * v + dnv * u;
				m[2] += dnv * v;
			}
			w[1][1] = w[0][0] + w[2][2];
			w[1][2] = w[0][1];
			var diag = [0,0,0];
			if(!apparentridges_Util.ldltdc(w,diag)) {
				continue;
			}
			apparentridges_Util.ldltsl(w,diag,m,m);
			var vj = f[0];
			var ccc = apparentridges_Mesh.projCurv(t,b,m[0],m[1],m[2],this.pdir1[vj],this.pdir2[vj]);
			var c1 = ccc[0];
			var c12 = ccc[1];
			var c2 = ccc[2];
			var wt = this.cornerAreas[i][0] / this.pointAreas[vj];
			this.curv1[vj] += wt * c1;
			curv12[vj] += wt * c12;
			this.curv2[vj] += wt * c2;
			var vj1 = f[1];
			var ccc1 = apparentridges_Mesh.projCurv(t,b,m[0],m[1],m[2],this.pdir1[vj1],this.pdir2[vj1]);
			var c11 = ccc1[0];
			var c121 = ccc1[1];
			var c21 = ccc1[2];
			var wt1 = this.cornerAreas[i][1] / this.pointAreas[vj1];
			this.curv1[vj1] += wt1 * c11;
			curv12[vj1] += wt1 * c121;
			this.curv2[vj1] += wt1 * c21;
			var vj2 = f[2];
			var ccc2 = apparentridges_Mesh.projCurv(t,b,m[0],m[1],m[2],this.pdir1[vj2],this.pdir2[vj2]);
			var c13 = ccc2[0];
			var c122 = ccc2[1];
			var c22 = ccc2[2];
			var wt2 = this.cornerAreas[i][2] / this.pointAreas[vj2];
			this.curv1[vj2] += wt2 * c13;
			curv12[vj2] += wt2 * c122;
			this.curv2[vj2] += wt2 * c22;
		}
		var _g = 0;
		var _g1 = nv;
		while(_g < _g1) {
			var i = _g++;
			var this1 = new Array(3);
			var this2 = this1;
			this2[0] = 0;
			this2[1] = 0;
			this2[2] = 0;
			var c1c2 = this2;
			apparentridges_Mesh.diagonalizeCurv(this.pdir1[i],this.pdir2[i],this.curv1[i],curv12[i],this.curv2[i],this.normals[i],this.pdir1[i],this.pdir2[i],c1c2);
			this.curv1[i] = c1c2[0];
			this.curv2[i] = c1c2[1];
		}
	}
	,computeVertViewDepCurv: function(i,ndotv,u2,uv,v2) {
		var sectheta_minus1 = 1.0 / Math.abs(ndotv) - 1.0;
		var Q11 = this.curv1[i] * (1.0 + sectheta_minus1 * u2);
		var Q12 = this.curv1[i] * (sectheta_minus1 * uv);
		var Q21 = this.curv2[i] * (sectheta_minus1 * uv);
		var Q22 = this.curv2[i] * (1.0 + sectheta_minus1 * v2);
		var QTQ1 = Q11 * Q11 + Q21 * Q21;
		var QTQ12 = Q11 * Q12 + Q21 * Q22;
		var QTQ2 = Q12 * Q12 + Q22 * Q22;
		return apparentridges_Util.largestEig2x2(QTQ1,QTQ12,QTQ2);
	}
	,computeVertDt1q1: function(i,ndotv,t1q1) {
		var v0 = this.vertices[i];
		var this_viewdep_curv = t1q1[i][2];
		var this1 = this.pdir1[i];
		var rhs = t1q1[i][0];
		var this2 = new Array(3);
		var this3 = this2;
		this3[0] = this1[0] * rhs;
		this3[1] = this1[1] * rhs;
		this3[2] = this1[2] * rhs;
		var this1 = this3;
		var this2 = this.pdir2[i];
		var rhs = t1q1[i][1];
		var this3 = new Array(3);
		var this4 = this3;
		this4[0] = this2[0] * rhs;
		this4[1] = this2[1] * rhs;
		this4[2] = this2[2] * rhs;
		var rhs = this4;
		var this2 = new Array(3);
		var this3 = this2;
		this3[0] = this1[0] + rhs[0];
		this3[1] = this1[1] + rhs[1];
		this3[2] = this1[2] + rhs[2];
		var world_t1 = this3;
		var v1 = this.normals[i];
		var this1 = new Array(3);
		var this2 = this1;
		this2[0] = v1[1] * world_t1[2] - v1[2] * world_t1[1];
		this2[1] = v1[2] * world_t1[0] - v1[0] * world_t1[2];
		this2[2] = v1[0] * world_t1[1] - v1[1] * world_t1[0];
		var world_t2 = this2;
		var v0_dot_t2 = v0[0] * world_t2[0] + v0[1] * world_t2[1] + v0[2] * world_t2[2];
		var Dt1q1 = 0.0;
		var n = 0;
		var naf = this.adjacentFaces[i].length;
		var _g = 0;
		var _g1 = naf;
		while(_g < _g1) {
			var j = _g++;
			var f = this.adjacentFaces[i][j];
			var this1 = this.faces[f];
			var ind = this1[0] == i ? 0 : this1[1] == i ? 1 : this1[2] == i ? 2 : -1;
			var i1 = this.faces[f][ind < 2 ? ind + 1 : ind - 2];
			var i2 = this.faces[f][ind > 0 ? ind - 1 : ind + 2];
			var v1 = this.vertices[i1];
			var v2 = this.vertices[i2];
			var v1_dot_t2 = v1[0] * world_t2[0] + v1[1] * world_t2[1] + v1[2] * world_t2[2];
			var v2_dot_t2 = v2[0] * world_t2[0] + v2[1] * world_t2[1] + v2[2] * world_t2[2];
			var w1 = (v2_dot_t2 - v0_dot_t2) / (v2_dot_t2 - v1_dot_t2);
			if(w1 < 0.0 || w1 >= 1.0) {
				continue;
			}
			var w2 = 1.0 - w1;
			var this2 = new Array(3);
			var this3 = this2;
			this3[0] = v1[0] * w1;
			this3[1] = v1[1] * w1;
			this3[2] = v1[2] * w1;
			var this4 = this3;
			var this5 = new Array(3);
			var this6 = this5;
			this6[0] = v2[0] * w2;
			this6[1] = v2[1] * w2;
			this6[2] = v2[2] * w2;
			var rhs = this6;
			var this7 = new Array(3);
			var this8 = this7;
			this8[0] = this4[0] + rhs[0];
			this8[1] = this4[1] + rhs[1];
			this8[2] = this4[2] + rhs[2];
			var p = this8;
			var interp_viewdep_curv = w1 * t1q1[i1][2] + w2 * t1q1[i2][2];
			var this9 = new Array(3);
			var this10 = this9;
			this10[0] = p[0] - v0[0];
			this10[1] = p[1] - v0[1];
			this10[2] = p[2] - v0[2];
			var v11 = this10;
			var proj_dist = v11[0] * world_t1[0] + v11[1] * world_t1[1] + v11[2] * world_t1[2];
			proj_dist *= Math.abs(ndotv);
			Dt1q1 += (interp_viewdep_curv - this_viewdep_curv) / proj_dist;
			++n;
			if(n == 2) {
				Dt1q1 *= 0.5;
				return Dt1q1;
			}
		}
		return Dt1q1;
	}
	,segmentApparentRidge: function(v0,v1,v2,emax0,emax1,emax2,kmax0,kmax1,kmax2,tmax0,tmax1,tmax2,thresh,to_center,do_test) {
		var w10 = Math.abs(emax0) / (Math.abs(emax0) + Math.abs(emax1));
		var w01 = 1.0 - w10;
		var this1 = this.vertices[v0];
		var this2 = new Array(3);
		var this3 = this2;
		this3[0] = this1[0] * w01;
		this3[1] = this1[1] * w01;
		this3[2] = this1[2] * w01;
		var this1 = this3;
		var this2 = this.vertices[v1];
		var this3 = new Array(3);
		var this4 = this3;
		this4[0] = this2[0] * w10;
		this4[1] = this2[1] * w10;
		this4[2] = this2[2] * w10;
		var rhs = this4;
		var this2 = new Array(3);
		var this3 = this2;
		this3[0] = this1[0] + rhs[0];
		this3[1] = this1[1] + rhs[1];
		this3[2] = this1[2] + rhs[2];
		var p01 = this3;
		var k01 = Math.abs(w01 * kmax0 + w10 * kmax1);
		var p12;
		var k12;
		if(to_center) {
			var this1 = this.vertices[v0];
			var rhs = this.vertices[v1];
			var this2 = new Array(3);
			var this3 = this2;
			this3[0] = this1[0] + rhs[0];
			this3[1] = this1[1] + rhs[1];
			this3[2] = this1[2] + rhs[2];
			var this1 = this3;
			var rhs = this.vertices[v2];
			var this2 = new Array(3);
			var this3 = this2;
			this3[0] = this1[0] + rhs[0];
			this3[1] = this1[1] + rhs[1];
			this3[2] = this1[2] + rhs[2];
			var this1 = this3;
			var this2 = new Array(3);
			var this3 = this2;
			this3[0] = this1[0] * 0.333333333333333315;
			this3[1] = this1[1] * 0.333333333333333315;
			this3[2] = this1[2] * 0.333333333333333315;
			p12 = this3;
			k12 = Math.abs(kmax0 + kmax1 + kmax2) / 3.0;
		} else {
			var w21 = Math.abs(emax1) / (Math.abs(emax1) + Math.abs(emax2));
			var w12 = 1.0 - w21;
			var this1 = this.vertices[v1];
			var this2 = new Array(3);
			var this3 = this2;
			this3[0] = this1[0] * w12;
			this3[1] = this1[1] * w12;
			this3[2] = this1[2] * w12;
			var this1 = this3;
			var this2 = this.vertices[v2];
			var this3 = new Array(3);
			var this4 = this3;
			this4[0] = this2[0] * w21;
			this4[1] = this2[1] * w21;
			this4[2] = this2[2] * w21;
			var rhs = this4;
			var this2 = new Array(3);
			var this3 = this2;
			this3[0] = this1[0] + rhs[0];
			this3[1] = this1[1] + rhs[1];
			this3[2] = this1[2] + rhs[2];
			p12 = this3;
			k12 = Math.abs(w12 * kmax1 + w21 * kmax2);
		}
		k01 -= thresh;
		if(k01 < 0.0) {
			k01 = 0.0;
		}
		k12 -= thresh;
		if(k12 < 0.0) {
			k12 = 0.0;
		}
		if(k01 == 0.0 && k12 == 0.0) {
			return null;
		}
		if(do_test) {
			var v01 = this.vertices[v0];
			var v11 = this.vertices[v1];
			var v21 = this.vertices[v2];
			var this1 = new Array(3);
			var this2 = this1;
			this2[0] = v11[0] - v01[0];
			this2[1] = v11[1] - v01[1];
			this2[2] = v11[2] - v01[2];
			var v1 = this2;
			var this1 = new Array(3);
			var this2 = this1;
			this2[0] = v21[0] - v01[0];
			this2[1] = v21[1] - v01[1];
			this2[2] = v21[2] - v01[2];
			var v2 = this2;
			var this1 = new Array(3);
			var this2 = this1;
			this2[0] = v1[1] * v2[2] - v1[2] * v2[1];
			this2[1] = v1[2] * v2[0] - v1[0] * v2[2];
			this2[2] = v1[0] * v2[1] - v1[1] * v2[0];
			var this1 = this2;
			var this2 = new Array(3);
			var this3 = this2;
			this3[0] = this1[0] * 0.5;
			this3[1] = this1[1] * 0.5;
			this3[2] = this1[2] * 0.5;
			var v1 = this3;
			var this1 = new Array(3);
			var this2 = this1;
			this2[0] = p01[0] - p12[0];
			this2[1] = p01[1] - p12[1];
			this2[2] = p01[2] - p12[2];
			var v2 = this2;
			var this1 = new Array(3);
			var this2 = this1;
			this2[0] = v1[1] * v2[2] - v1[2] * v2[1];
			this2[1] = v1[2] * v2[0] - v1[0] * v2[2];
			this2[2] = v1[0] * v2[1] - v1[1] * v2[0];
			var perp = this2;
			if(tmax0[0] * perp[0] + tmax0[1] * perp[1] + tmax0[2] * perp[2] <= 0.0 || tmax1[0] * perp[0] + tmax1[1] * perp[1] + tmax1[2] * perp[2] >= 0.0 || tmax2[0] * perp[0] + tmax2[1] * perp[1] + tmax2[2] * perp[2] <= 0.0) {
				return null;
			}
		}
		k01 /= k01 + thresh;
		k12 /= k12 + thresh;
		return new apparentridges_Ridge(p01,k01,p12,k12);
	}
	,facesApparentRidges: function(ndotv,t1q1,Dt1q1,do_bfcull,do_test,thresh) {
		var ridges = [];
		var _g = 0;
		var _g1 = this.faces;
		while(_g < _g1.length) {
			var f = _g1[_g];
			++_g;
			var v0 = f[0];
			var v1 = f[1];
			var v2 = f[2];
			if(do_bfcull && ndotv[v0] <= 0 && ndotv[v1] <= 0 && ndotv[v2] <= 0) {
				continue;
			}
			var kmax0 = t1q1[v0][2];
			var kmax1 = t1q1[v1][2];
			var kmax2 = t1q1[v2][2];
			if(kmax0 <= thresh && kmax1 <= thresh && kmax2 <= thresh) {
				continue;
			}
			var emax0 = Dt1q1[v0];
			var emax1 = Dt1q1[v1];
			var emax2 = Dt1q1[v2];
			var this1 = this.pdir1[v0];
			var rhs = t1q1[v0][0];
			var this2 = new Array(3);
			var this3 = this2;
			this3[0] = this1[0] * rhs;
			this3[1] = this1[1] * rhs;
			this3[2] = this1[2] * rhs;
			var this4 = this3;
			var this5 = this.pdir2[v0];
			var rhs1 = t1q1[v0][1];
			var this6 = new Array(3);
			var this7 = this6;
			this7[0] = this5[0] * rhs1;
			this7[1] = this5[1] * rhs1;
			this7[2] = this5[2] * rhs1;
			var rhs2 = this7;
			var this8 = new Array(3);
			var this9 = this8;
			this9[0] = this4[0] + rhs2[0];
			this9[1] = this4[1] + rhs2[1];
			this9[2] = this4[2] + rhs2[2];
			var world_t1_0 = this9;
			var this10 = this.pdir1[v1];
			var rhs3 = t1q1[v1][0];
			var this11 = new Array(3);
			var this12 = this11;
			this12[0] = this10[0] * rhs3;
			this12[1] = this10[1] * rhs3;
			this12[2] = this10[2] * rhs3;
			var this13 = this12;
			var this14 = this.pdir2[v1];
			var rhs4 = t1q1[v1][1];
			var this15 = new Array(3);
			var this16 = this15;
			this16[0] = this14[0] * rhs4;
			this16[1] = this14[1] * rhs4;
			this16[2] = this14[2] * rhs4;
			var rhs5 = this16;
			var this17 = new Array(3);
			var this18 = this17;
			this18[0] = this13[0] + rhs5[0];
			this18[1] = this13[1] + rhs5[1];
			this18[2] = this13[2] + rhs5[2];
			var world_t1_1 = this18;
			var this19 = this.pdir1[v2];
			var rhs6 = t1q1[v2][0];
			var this20 = new Array(3);
			var this21 = this20;
			this21[0] = this19[0] * rhs6;
			this21[1] = this19[1] * rhs6;
			this21[2] = this19[2] * rhs6;
			var this22 = this21;
			var this23 = this.pdir2[v2];
			var rhs7 = t1q1[v2][1];
			var this24 = new Array(3);
			var this25 = this24;
			this25[0] = this23[0] * rhs7;
			this25[1] = this23[1] * rhs7;
			this25[2] = this23[2] * rhs7;
			var rhs8 = this25;
			var this26 = new Array(3);
			var this27 = this26;
			this27[0] = this22[0] + rhs8[0];
			this27[1] = this22[1] + rhs8[1];
			this27[2] = this22[2] + rhs8[2];
			var world_t1_2 = this27;
			var rhs9 = Dt1q1[v0];
			var this28 = new Array(3);
			var this29 = this28;
			this29[0] = world_t1_0[0] * rhs9;
			this29[1] = world_t1_0[1] * rhs9;
			this29[2] = world_t1_0[2] * rhs9;
			var tmax0 = this29;
			var rhs10 = Dt1q1[v1];
			var this30 = new Array(3);
			var this31 = this30;
			this31[0] = world_t1_1[0] * rhs10;
			this31[1] = world_t1_1[1] * rhs10;
			this31[2] = world_t1_1[2] * rhs10;
			var tmax1 = this31;
			var rhs11 = Dt1q1[v2];
			var this32 = new Array(3);
			var this33 = this32;
			this33[0] = world_t1_2[0] * rhs11;
			this33[1] = world_t1_2[1] * rhs11;
			this33[2] = world_t1_2[2] * rhs11;
			var tmax2 = this33;
			var z01 = tmax0[0] * tmax1[0] + tmax0[1] * tmax1[1] + tmax0[2] * tmax1[2] <= 0.0;
			var z12 = tmax1[0] * tmax2[0] + tmax1[1] * tmax2[1] + tmax1[2] * tmax2[2] <= 0.0;
			var z20 = tmax2[0] * tmax0[0] + tmax2[1] * tmax0[1] + tmax2[2] * tmax0[2] <= 0.0;
			if((z01 ? 1 : 0) + (z12 ? 1 : 0) + (z20 ? 1 : 0) < 2) {
				continue;
			}
			if(!z01) {
				var r = this.segmentApparentRidge(v1,v2,v0,emax1,emax2,emax0,kmax1,kmax2,kmax0,tmax1,tmax2,tmax0,thresh,false,do_test);
				if(r != null) {
					ridges.push(r);
				}
			} else if(!z12) {
				var r1 = this.segmentApparentRidge(v2,v0,v1,emax2,emax0,emax1,kmax2,kmax0,kmax1,tmax2,tmax0,tmax1,thresh,false,do_test);
				if(r1 != null) {
					ridges.push(r1);
				}
			} else if(!z20) {
				var r2 = this.segmentApparentRidge(v0,v1,v2,emax0,emax1,emax2,kmax0,kmax1,kmax2,tmax0,tmax1,tmax2,thresh,false,do_test);
				if(r2 != null) {
					ridges.push(r2);
				}
			} else {
				var r0 = this.segmentApparentRidge(v1,v2,v0,emax1,emax2,emax0,kmax1,kmax2,kmax0,tmax1,tmax2,tmax0,thresh,true,do_test);
				var r11 = this.segmentApparentRidge(v2,v0,v1,emax2,emax0,emax1,kmax2,kmax0,kmax1,tmax2,tmax0,tmax1,thresh,true,do_test);
				var r21 = this.segmentApparentRidge(v0,v1,v2,emax0,emax1,emax2,kmax0,kmax1,kmax2,tmax0,tmax1,tmax2,thresh,true,do_test);
				if(r0 != null) {
					ridges.push(r0);
				}
				if(r11 != null) {
					ridges.push(r11);
				}
				if(r21 != null) {
					ridges.push(r21);
				}
			}
		}
		return ridges;
	}
	,apparentRidges: function(eye,thresh) {
		var nv = this.vertices.length;
		var _g = 0;
		var _g1 = nv;
		while(_g < _g1) {
			var i = _g++;
			var rhs = this.vertices[i];
			var this1 = new Array(3);
			var this2 = this1;
			this2[0] = eye[0] - rhs[0];
			this2[1] = eye[1] - rhs[1];
			this2[2] = eye[2] - rhs[2];
			var viewdir = this2;
			var rlv = 1.0 / Math.sqrt(viewdir[0] * viewdir[0] + viewdir[1] * viewdir[1] + viewdir[2] * viewdir[2]);
			var this3 = new Array(3);
			var this4 = this3;
			this4[0] = viewdir[0] * rlv;
			this4[1] = viewdir[1] * rlv;
			this4[2] = viewdir[2] * rlv;
			viewdir = this4;
			var v2 = this.normals[i];
			this.ndotv[i] = viewdir[0] * v2[0] + viewdir[1] * v2[1] + viewdir[2] * v2[2];
			var v21 = this.pdir1[i];
			var u = viewdir[0] * v21[0] + viewdir[1] * v21[1] + viewdir[2] * v21[2];
			var u2 = u * u;
			var v22 = this.pdir2[i];
			var v = viewdir[0] * v22[0] + viewdir[1] * v22[1] + viewdir[2] * v22[2];
			var v23 = v * v;
			var csc2theta = 1.0 / (u2 + v23);
			this.t1q1[i] = this.computeVertViewDepCurv(i,this.ndotv[i],u2 * csc2theta,u * v * csc2theta,v23 * csc2theta);
		}
		var _g = 0;
		var _g1 = nv;
		while(_g < _g1) {
			var i = _g++;
			this.Dt1q1[i] = this.computeVertDt1q1(i,this.ndotv[i],this.t1q1);
		}
		var x = this.featureSize;
		return this.facesApparentRidges(this.ndotv,this.t1q1,this.Dt1q1,false,true,thresh / (x * x));
	}
	,computeBVHTrivial: function() {
		this.bvh = new apparentridges_BVHTree(this,this.faces.length);
		this.bvh.build();
	}
	,computeBVH: function() {
		this.bvh = new apparentridges_BVHTree(this);
		this.bvh.build();
	}
	,visible: function(eye,p,tolerance) {
		if(tolerance == null) {
			tolerance = 2;
		}
		var epsilon = this.bsphere.r / Math.sqrt(this.faces.length) * tolerance;
		var r_tmin;
		var r_tmax;
		var r_o;
		var r_d;
		var this1 = new Array(3);
		var this2 = this1;
		this2[0] = p[0] - eye[0];
		this2[1] = p[1] - eye[1];
		this2[2] = p[2] - eye[2];
		var x = this2;
		var this1 = new Array(3);
		var this2 = this1;
		this2[0] = x[0];
		this2[1] = x[1];
		this2[2] = x[2];
		r_d = this2;
		var this1 = r_d;
		var l = Math.sqrt(this1[0] * this1[0] + this1[1] * this1[1] + this1[2] * this1[2]);
		if(l > 0) {
			l = 1 / l;
			this1[0] *= l;
			this1[1] *= l;
			this1[2] *= l;
		} else {
			this1[0] = 0;
			this1[1] = 0;
			this1[2] = 1;
		}
		r_o = eye;
		r_tmin = 0;
		r_tmax = Math.sqrt(x[0] * x[0] + x[1] * x[1] + x[2] * x[2]) - epsilon;
		var bvh = this.bvh;
		var hitNode = null;
		hitNode = function(node) {
			if(node.left == null && node.right == null) {
				var tmin = Infinity;
				var closest = null;
				var _g = node.begin;
				var _g1 = node.end;
				while(_g < _g1) {
					var i = _g++;
					var p0 = bvh.mesh.vertices[bvh.faces[i][0]];
					var p1 = bvh.mesh.vertices[bvh.faces[i][1]];
					var p2 = bvh.mesh.vertices[bvh.faces[i][2]];
					var this1 = new Array(3);
					var this2 = this1;
					this2[0] = p1[0] - p0[0];
					this2[1] = p1[1] - p0[1];
					this2[2] = p1[2] - p0[2];
					var e1 = this2;
					var this3 = new Array(3);
					var this4 = this3;
					this4[0] = p2[0] - p0[0];
					this4[1] = p2[1] - p0[1];
					this4[2] = p2[2] - p0[2];
					var e2 = this4;
					var this5 = r_o;
					var this6 = new Array(3);
					var this7 = this6;
					this7[0] = this5[0] - p0[0];
					this7[1] = this5[1] - p0[1];
					this7[2] = this5[2] - p0[2];
					var s = this7;
					var this8 = r_d;
					var this9 = new Array(3);
					var this10 = this9;
					this10[0] = this8[0] * -1.0;
					this10[1] = this8[1] * -1.0;
					this10[2] = this8[2] * -1.0;
					var _d = this10;
					var this11 = new Array(3);
					var this12 = this11;
					this12[0] = e1[1] * e2[2] - e1[2] * e2[1];
					this12[1] = e1[2] * e2[0] - e1[0] * e2[2];
					this12[2] = e1[0] * e2[1] - e1[1] * e2[0];
					var v1 = this12;
					var denom = v1[0] * _d[0] + v1[1] * _d[1] + v1[2] * _d[2];
					var h;
					if(denom == 0) {
						h = null;
					} else {
						var this13 = new Array(3);
						var this14 = this13;
						this14[0] = s[1] * e2[2] - s[2] * e2[1];
						this14[1] = s[2] * e2[0] - s[0] * e2[2];
						this14[2] = s[0] * e2[1] - s[1] * e2[0];
						var v11 = this14;
						var _x = v11[0] * _d[0] + v11[1] * _d[1] + v11[2] * _d[2];
						var this15 = new Array(3);
						var this16 = this15;
						this16[0] = e1[1] * s[2] - e1[2] * s[1];
						this16[1] = e1[2] * s[0] - e1[0] * s[2];
						this16[2] = e1[0] * s[1] - e1[1] * s[0];
						var v12 = this16;
						var _y = v12[0] * _d[0] + v12[1] * _d[1] + v12[2] * _d[2];
						var this17 = new Array(3);
						var this18 = this17;
						this18[0] = e1[1] * e2[2] - e1[2] * e2[1];
						this18[1] = e1[2] * e2[0] - e1[0] * e2[2];
						this18[2] = e1[0] * e2[1] - e1[1] * e2[0];
						var v13 = this18;
						var _z = v13[0] * s[0] + v13[1] * s[1] + v13[2] * s[2];
						var this19 = new Array(3);
						var this20 = this19;
						this20[0] = _x;
						this20[1] = _y;
						this20[2] = _z;
						var this21 = this20;
						var rhs = 1 / denom;
						var this22 = new Array(3);
						var this23 = this22;
						this23[0] = this21[0] * rhs;
						this23[1] = this21[1] * rhs;
						this23[2] = this21[2] * rhs;
						var uvt = this23;
						var u = uvt[0];
						var v = uvt[1];
						var t = uvt[2];
						if(u < 0 || v < 0 || 1 - u - v < 0 || t < r_tmin || t > r_tmax) {
							h = null;
						} else {
							var h1 = new apparentridges_RayHit(t);
							h1.u = u;
							h1.v = v;
							h = h1;
						}
					}
					if(h != null) {
						h.face = bvh.faces[i];
						if(tmin > h.t) {
							tmin = h.t;
							closest = h;
						}
					}
				}
				return closest;
			}
			var bb = node.left.bbox;
			var tx1 = (bb.min[0] - r_o[0]) / r_d[0];
			var tx2 = (bb.max[0] - r_o[0]) / r_d[0];
			var ty1 = (bb.min[1] - r_o[1]) / r_d[1];
			var ty2 = (bb.max[1] - r_o[1]) / r_d[1];
			var tz1 = (bb.min[2] - r_o[2]) / r_d[2];
			var tz2 = (bb.max[2] - r_o[2]) / r_d[2];
			var t1 = Math.max(Math.max(Math.min(tx1,tx2),Math.min(ty1,ty2)),Math.min(tz1,tz2));
			var t2 = Math.min(Math.min(Math.max(tx1,tx2),Math.max(ty1,ty2)),Math.max(tz1,tz2));
			var hitL;
			if(t2 - t1 < 0) {
				hitL = null;
			} else if(t1 > r_tmax || t2 < r_tmin) {
				hitL = null;
			} else {
				var h = new apparentridges_RayHit(t1);
				h.t2 = t2;
				hitL = h;
			}
			var bb = node.right.bbox;
			var tx1 = (bb.min[0] - r_o[0]) / r_d[0];
			var tx2 = (bb.max[0] - r_o[0]) / r_d[0];
			var ty1 = (bb.min[1] - r_o[1]) / r_d[1];
			var ty2 = (bb.max[1] - r_o[1]) / r_d[1];
			var tz1 = (bb.min[2] - r_o[2]) / r_d[2];
			var tz2 = (bb.max[2] - r_o[2]) / r_d[2];
			var t1 = Math.max(Math.max(Math.min(tx1,tx2),Math.min(ty1,ty2)),Math.min(tz1,tz2));
			var t2 = Math.min(Math.min(Math.max(tx1,tx2),Math.max(ty1,ty2)),Math.max(tz1,tz2));
			var hitR;
			if(t2 - t1 < 0) {
				hitR = null;
			} else if(t1 > r_tmax || t2 < r_tmin) {
				hitR = null;
			} else {
				var h = new apparentridges_RayHit(t1);
				h.t2 = t2;
				hitR = h;
			}
			if(hitL != null && hitR == null) {
				return hitNode(node.left);
			} else if(hitL == null && hitR != null) {
				return hitNode(node.right);
			} else if(hitL == null && hitR == null) {
				return null;
			}
			var first;
			var second;
			if(hitL.t < hitR.t) {
				first = node.left;
				second = node.right;
			} else {
				first = node.right;
				second = node.left;
			}
			var h = hitNode(first);
			if(h == null || h.t >= Math.max(hitL.t,hitR.t)) {
				var h2 = hitNode(second);
				if(h2 != null) {
					if(h == null || h2.t < h.t) {
						return h2;
					}
				}
			}
			return h;
		};
		var h = hitNode(bvh.root);
		return h == null;
	}
};
var apparentridges_Ray = $hx_exports["apparentridges"]["Ray"] = function() {
};
apparentridges_Ray.__name__ = true;
apparentridges_Ray.prototype = {
	hitBBox: function(bb) {
		var tx1 = (bb.min[0] - this.o[0]) / this.d[0];
		var tx2 = (bb.max[0] - this.o[0]) / this.d[0];
		var ty1 = (bb.min[1] - this.o[1]) / this.d[1];
		var ty2 = (bb.max[1] - this.o[1]) / this.d[1];
		var tz1 = (bb.min[2] - this.o[2]) / this.d[2];
		var tz2 = (bb.max[2] - this.o[2]) / this.d[2];
		var t1 = Math.max(Math.max(Math.min(tx1,tx2),Math.min(ty1,ty2)),Math.min(tz1,tz2));
		var t2 = Math.min(Math.min(Math.max(tx1,tx2),Math.max(ty1,ty2)),Math.max(tz1,tz2));
		if(t2 - t1 < 0) {
			return null;
		}
		if(t1 > this.tmax || t2 < this.tmin) {
			return null;
		}
		var h = new apparentridges_RayHit(t1);
		h.t2 = t2;
		return h;
	}
	,hitTriangle: function(p0,p1,p2) {
		var this1 = new Array(3);
		var this2 = this1;
		this2[0] = p1[0] - p0[0];
		this2[1] = p1[1] - p0[1];
		this2[2] = p1[2] - p0[2];
		var e1 = this2;
		var this1 = new Array(3);
		var this2 = this1;
		this2[0] = p2[0] - p0[0];
		this2[1] = p2[1] - p0[1];
		this2[2] = p2[2] - p0[2];
		var e2 = this2;
		var this1 = this.o;
		var this2 = new Array(3);
		var this3 = this2;
		this3[0] = this1[0] - p0[0];
		this3[1] = this1[1] - p0[1];
		this3[2] = this1[2] - p0[2];
		var s = this3;
		var this1 = this.d;
		var this2 = new Array(3);
		var this3 = this2;
		this3[0] = this1[0] * -1.0;
		this3[1] = this1[1] * -1.0;
		this3[2] = this1[2] * -1.0;
		var _d = this3;
		var this1 = new Array(3);
		var this2 = this1;
		this2[0] = e1[1] * e2[2] - e1[2] * e2[1];
		this2[1] = e1[2] * e2[0] - e1[0] * e2[2];
		this2[2] = e1[0] * e2[1] - e1[1] * e2[0];
		var v1 = this2;
		var denom = v1[0] * _d[0] + v1[1] * _d[1] + v1[2] * _d[2];
		if(denom == 0) {
			return null;
		}
		var this1 = new Array(3);
		var this2 = this1;
		this2[0] = s[1] * e2[2] - s[2] * e2[1];
		this2[1] = s[2] * e2[0] - s[0] * e2[2];
		this2[2] = s[0] * e2[1] - s[1] * e2[0];
		var v1 = this2;
		var _x = v1[0] * _d[0] + v1[1] * _d[1] + v1[2] * _d[2];
		var this1 = new Array(3);
		var this2 = this1;
		this2[0] = e1[1] * s[2] - e1[2] * s[1];
		this2[1] = e1[2] * s[0] - e1[0] * s[2];
		this2[2] = e1[0] * s[1] - e1[1] * s[0];
		var v1 = this2;
		var _y = v1[0] * _d[0] + v1[1] * _d[1] + v1[2] * _d[2];
		var this1 = new Array(3);
		var this2 = this1;
		this2[0] = e1[1] * e2[2] - e1[2] * e2[1];
		this2[1] = e1[2] * e2[0] - e1[0] * e2[2];
		this2[2] = e1[0] * e2[1] - e1[1] * e2[0];
		var v1 = this2;
		var _z = v1[0] * s[0] + v1[1] * s[1] + v1[2] * s[2];
		var this1 = new Array(3);
		var this2 = this1;
		this2[0] = _x;
		this2[1] = _y;
		this2[2] = _z;
		var this1 = this2;
		var rhs = 1 / denom;
		var this2 = new Array(3);
		var this3 = this2;
		this3[0] = this1[0] * rhs;
		this3[1] = this1[1] * rhs;
		this3[2] = this1[2] * rhs;
		var uvt = this3;
		var u = uvt[0];
		var v = uvt[1];
		var t = uvt[2];
		if(u < 0 || v < 0 || 1 - u - v < 0 || t < this.tmin || t > this.tmax) {
			return null;
		}
		var h = new apparentridges_RayHit(t);
		h.u = u;
		h.v = v;
		return h;
	}
	,hitBVH: function(bvh) {
		var _gthis = this;
		var hitNode = null;
		hitNode = function(node) {
			if(node.left == null && node.right == null) {
				var tmin = Infinity;
				var closest = null;
				var _g = node.begin;
				var _g1 = node.end;
				while(_g < _g1) {
					var i = _g++;
					var p0 = bvh.mesh.vertices[bvh.faces[i][0]];
					var p1 = bvh.mesh.vertices[bvh.faces[i][1]];
					var p2 = bvh.mesh.vertices[bvh.faces[i][2]];
					var this1 = new Array(3);
					var this2 = this1;
					this2[0] = p1[0] - p0[0];
					this2[1] = p1[1] - p0[1];
					this2[2] = p1[2] - p0[2];
					var e1 = this2;
					var this3 = new Array(3);
					var this4 = this3;
					this4[0] = p2[0] - p0[0];
					this4[1] = p2[1] - p0[1];
					this4[2] = p2[2] - p0[2];
					var e2 = this4;
					var this5 = _gthis.o;
					var this6 = new Array(3);
					var this7 = this6;
					this7[0] = this5[0] - p0[0];
					this7[1] = this5[1] - p0[1];
					this7[2] = this5[2] - p0[2];
					var s = this7;
					var this8 = _gthis.d;
					var this9 = new Array(3);
					var this10 = this9;
					this10[0] = this8[0] * -1.0;
					this10[1] = this8[1] * -1.0;
					this10[2] = this8[2] * -1.0;
					var _d = this10;
					var this11 = new Array(3);
					var this12 = this11;
					this12[0] = e1[1] * e2[2] - e1[2] * e2[1];
					this12[1] = e1[2] * e2[0] - e1[0] * e2[2];
					this12[2] = e1[0] * e2[1] - e1[1] * e2[0];
					var v1 = this12;
					var denom = v1[0] * _d[0] + v1[1] * _d[1] + v1[2] * _d[2];
					var h;
					if(denom == 0) {
						h = null;
					} else {
						var this13 = new Array(3);
						var this14 = this13;
						this14[0] = s[1] * e2[2] - s[2] * e2[1];
						this14[1] = s[2] * e2[0] - s[0] * e2[2];
						this14[2] = s[0] * e2[1] - s[1] * e2[0];
						var v11 = this14;
						var _x = v11[0] * _d[0] + v11[1] * _d[1] + v11[2] * _d[2];
						var this15 = new Array(3);
						var this16 = this15;
						this16[0] = e1[1] * s[2] - e1[2] * s[1];
						this16[1] = e1[2] * s[0] - e1[0] * s[2];
						this16[2] = e1[0] * s[1] - e1[1] * s[0];
						var v12 = this16;
						var _y = v12[0] * _d[0] + v12[1] * _d[1] + v12[2] * _d[2];
						var this17 = new Array(3);
						var this18 = this17;
						this18[0] = e1[1] * e2[2] - e1[2] * e2[1];
						this18[1] = e1[2] * e2[0] - e1[0] * e2[2];
						this18[2] = e1[0] * e2[1] - e1[1] * e2[0];
						var v13 = this18;
						var _z = v13[0] * s[0] + v13[1] * s[1] + v13[2] * s[2];
						var this19 = new Array(3);
						var this20 = this19;
						this20[0] = _x;
						this20[1] = _y;
						this20[2] = _z;
						var this21 = this20;
						var rhs = 1 / denom;
						var this22 = new Array(3);
						var this23 = this22;
						this23[0] = this21[0] * rhs;
						this23[1] = this21[1] * rhs;
						this23[2] = this21[2] * rhs;
						var uvt = this23;
						var u = uvt[0];
						var v = uvt[1];
						var t = uvt[2];
						if(u < 0 || v < 0 || 1 - u - v < 0 || t < _gthis.tmin || t > _gthis.tmax) {
							h = null;
						} else {
							var h1 = new apparentridges_RayHit(t);
							h1.u = u;
							h1.v = v;
							h = h1;
						}
					}
					if(h != null) {
						h.face = bvh.faces[i];
						if(tmin > h.t) {
							tmin = h.t;
							closest = h;
						}
					}
				}
				return closest;
			}
			var bb = node.left.bbox;
			var tx1 = (bb.min[0] - _gthis.o[0]) / _gthis.d[0];
			var tx2 = (bb.max[0] - _gthis.o[0]) / _gthis.d[0];
			var ty1 = (bb.min[1] - _gthis.o[1]) / _gthis.d[1];
			var ty2 = (bb.max[1] - _gthis.o[1]) / _gthis.d[1];
			var tz1 = (bb.min[2] - _gthis.o[2]) / _gthis.d[2];
			var tz2 = (bb.max[2] - _gthis.o[2]) / _gthis.d[2];
			var t1 = Math.max(Math.max(Math.min(tx1,tx2),Math.min(ty1,ty2)),Math.min(tz1,tz2));
			var t2 = Math.min(Math.min(Math.max(tx1,tx2),Math.max(ty1,ty2)),Math.max(tz1,tz2));
			var hitL;
			if(t2 - t1 < 0) {
				hitL = null;
			} else if(t1 > _gthis.tmax || t2 < _gthis.tmin) {
				hitL = null;
			} else {
				var h = new apparentridges_RayHit(t1);
				h.t2 = t2;
				hitL = h;
			}
			var bb = node.right.bbox;
			var tx1 = (bb.min[0] - _gthis.o[0]) / _gthis.d[0];
			var tx2 = (bb.max[0] - _gthis.o[0]) / _gthis.d[0];
			var ty1 = (bb.min[1] - _gthis.o[1]) / _gthis.d[1];
			var ty2 = (bb.max[1] - _gthis.o[1]) / _gthis.d[1];
			var tz1 = (bb.min[2] - _gthis.o[2]) / _gthis.d[2];
			var tz2 = (bb.max[2] - _gthis.o[2]) / _gthis.d[2];
			var t1 = Math.max(Math.max(Math.min(tx1,tx2),Math.min(ty1,ty2)),Math.min(tz1,tz2));
			var t2 = Math.min(Math.min(Math.max(tx1,tx2),Math.max(ty1,ty2)),Math.max(tz1,tz2));
			var hitR;
			if(t2 - t1 < 0) {
				hitR = null;
			} else if(t1 > _gthis.tmax || t2 < _gthis.tmin) {
				hitR = null;
			} else {
				var h = new apparentridges_RayHit(t1);
				h.t2 = t2;
				hitR = h;
			}
			if(hitL != null && hitR == null) {
				return hitNode(node.left);
			} else if(hitL == null && hitR != null) {
				return hitNode(node.right);
			} else if(hitL == null && hitR == null) {
				return null;
			}
			var first;
			var second;
			if(hitL.t < hitR.t) {
				first = node.left;
				second = node.right;
			} else {
				first = node.right;
				second = node.left;
			}
			var h = hitNode(first);
			if(h == null || h.t >= Math.max(hitL.t,hitR.t)) {
				var h2 = hitNode(second);
				if(h2 != null) {
					if(h == null || h2.t < h.t) {
						return h2;
					}
				}
			}
			return h;
		};
		return hitNode(bvh.root);
	}
};
var apparentridges_RayHit = $hx_exports["apparentridges"]["RayHit"] = function(_t) {
	this.t = _t;
};
apparentridges_RayHit.__name__ = true;
var apparentridges_BBox = $hx_exports["apparentridges"]["BBox"] = function() {
	var _x = Infinity;
	var _y = Infinity;
	var _z = Infinity;
	var this1 = new Array(3);
	var this2 = this1;
	this2[0] = _x;
	this2[1] = _y;
	this2[2] = _z;
	this.min = this2;
	var _x = -Infinity;
	var _y = -Infinity;
	var _z = -Infinity;
	var this1 = new Array(3);
	var this2 = this1;
	this2[0] = _x;
	this2[1] = _y;
	this2[2] = _z;
	this.max = this2;
};
apparentridges_BBox.__name__ = true;
apparentridges_BBox.prototype = {
	centroid: function() {
		var this1 = this.min;
		var rhs = this.max;
		var this2 = new Array(3);
		var this3 = this2;
		this3[0] = this1[0] + rhs[0];
		this3[1] = this1[1] + rhs[1];
		this3[2] = this1[2] + rhs[2];
		var this1 = this3;
		var this2 = new Array(3);
		var this3 = this2;
		this3[0] = this1[0] * 0.5;
		this3[1] = this1[1] * 0.5;
		this3[2] = this1[2] * 0.5;
		return this3;
	}
	,add: function(p) {
		this.min[0] = Math.min(this.min[0],p[0]);
		this.min[1] = Math.min(this.min[1],p[1]);
		this.min[2] = Math.min(this.min[2],p[2]);
		this.max[0] = Math.max(this.max[0],p[0]);
		this.max[1] = Math.max(this.max[1],p[1]);
		this.max[2] = Math.max(this.max[2],p[2]);
	}
	,merge: function(bb) {
		this.min[0] = Math.min(this.min[0],bb.min[0]);
		this.min[1] = Math.min(this.min[1],bb.min[1]);
		this.min[2] = Math.min(this.min[2],bb.min[2]);
		this.max[0] = Math.max(this.max[0],bb.max[0]);
		this.max[1] = Math.max(this.max[1],bb.max[1]);
		this.max[2] = Math.max(this.max[2],bb.max[2]);
	}
	,surfaceArea: function() {
		var this1 = this.max;
		var rhs = this.min;
		var this2 = new Array(3);
		var this3 = this2;
		this3[0] = this1[0] - rhs[0];
		this3[1] = this1[1] - rhs[1];
		this3[2] = this1[2] - rhs[2];
		var extent = this3;
		var x = Math.max(extent[0],0);
		var y = Math.max(extent[1],0);
		var z = Math.max(extent[2],0);
		return 2 * (x * z + x * y + y * z);
	}
};
var apparentridges_BVHNode = $hx_exports["apparentridges"]["BVHNode"] = function(box,i0,i1) {
	this.bbox = box;
	this.begin = i0;
	this.end = i1;
	this.left = null;
	this.right = null;
};
apparentridges_BVHNode.__name__ = true;
apparentridges_BVHNode.prototype = {
	isLeaf: function() {
		if(this.left == null) {
			return this.right == null;
		} else {
			return false;
		}
	}
};
var apparentridges_BVHTree = $hx_exports["apparentridges"]["BVHTree"] = function(_mesh,_maxLeafSize,_bucketCount) {
	if(_bucketCount == null) {
		_bucketCount = 8;
	}
	if(_maxLeafSize == null) {
		_maxLeafSize = 4;
	}
	this.maxLeafSize = _maxLeafSize;
	this.bucketCount = _bucketCount;
	this.faces = _mesh.faces.slice(0);
	this.mesh = _mesh;
};
apparentridges_BVHTree.__name__ = true;
apparentridges_BVHTree.prototype = {
	build: function() {
		var _gthis = this;
		var bboxAddFace = function(bbox,f) {
			var p = _gthis.mesh.vertices[f[0]];
			bbox.min[0] = Math.min(bbox.min[0],p[0]);
			bbox.min[1] = Math.min(bbox.min[1],p[1]);
			bbox.min[2] = Math.min(bbox.min[2],p[2]);
			bbox.max[0] = Math.max(bbox.max[0],p[0]);
			bbox.max[1] = Math.max(bbox.max[1],p[1]);
			bbox.max[2] = Math.max(bbox.max[2],p[2]);
			var p = _gthis.mesh.vertices[f[1]];
			bbox.min[0] = Math.min(bbox.min[0],p[0]);
			bbox.min[1] = Math.min(bbox.min[1],p[1]);
			bbox.min[2] = Math.min(bbox.min[2],p[2]);
			bbox.max[0] = Math.max(bbox.max[0],p[0]);
			bbox.max[1] = Math.max(bbox.max[1],p[1]);
			bbox.max[2] = Math.max(bbox.max[2],p[2]);
			var p = _gthis.mesh.vertices[f[2]];
			bbox.min[0] = Math.min(bbox.min[0],p[0]);
			bbox.min[1] = Math.min(bbox.min[1],p[1]);
			bbox.min[2] = Math.min(bbox.min[2],p[2]);
			bbox.max[0] = Math.max(bbox.max[0],p[0]);
			bbox.max[1] = Math.max(bbox.max[1],p[1]);
			bbox.max[2] = Math.max(bbox.max[2],p[2]);
		};
		var buildRange = null;
		buildRange = function(i0,i1) {
			var bbox = new apparentridges_BBox();
			var _g = i0;
			var _g1 = i1;
			while(_g < _g1) {
				var i = _g++;
				bboxAddFace(bbox,_gthis.faces[i]);
			}
			var node = new apparentridges_BVHNode(bbox,i0,i1);
			if(i1 - i0 <= _gthis.maxLeafSize) {
				return node;
			}
			var parts = [];
			var _g = 0;
			while(_g < 3) {
				var ax = _g++;
				var buckets = [];
				var lo = bbox.min[ax];
				var hi = bbox.max[ax];
				var _g1 = 0;
				var _g2 = _gthis.bucketCount;
				while(_g1 < _g2) {
					var i = _g1++;
					var b = new apparentridges_BVHBucket();
					b.min = lo + i / _gthis.bucketCount * (hi - lo);
					b.max = b.min + (hi - lo) / _gthis.bucketCount;
					buckets.push(b);
				}
				var _g3 = i0;
				var _g4 = i1;
				while(_g3 < _g4) {
					var i2 = _g3++;
					var bb = new apparentridges_BBox();
					bboxAddFace(bb,_gthis.faces[i2]);
					var this1 = bb.min;
					var rhs = bb.max;
					var this2 = new Array(3);
					var this3 = this2;
					this3[0] = this1[0] + rhs[0];
					this3[1] = this1[1] + rhs[1];
					this3[2] = this1[2] + rhs[2];
					var this4 = this3;
					var this5 = new Array(3);
					var this6 = this5;
					this6[0] = this4[0] * 0.5;
					this6[1] = this4[1] * 0.5;
					this6[2] = this4[2] * 0.5;
					var c = this6;
					var _g5 = 0;
					var _g6 = _gthis.bucketCount;
					while(_g5 < _g6) {
						var j = _g5++;
						if(buckets[j].min <= c[ax] && c[ax] <= buckets[j].max) {
							buckets[j].count++;
							var _this = buckets[j].bbox;
							_this.min[0] = Math.min(_this.min[0],bb.min[0]);
							_this.min[1] = Math.min(_this.min[1],bb.min[1]);
							_this.min[2] = Math.min(_this.min[2],bb.min[2]);
							_this.max[0] = Math.max(_this.max[0],bb.max[0]);
							_this.max[1] = Math.max(_this.max[1],bb.max[1]);
							_this.max[2] = Math.max(_this.max[2],bb.max[2]);
							var buckets1 = buckets[j].area;
							var this7 = bb.max;
							var rhs1 = bb.min;
							var this8 = new Array(3);
							var this9 = this8;
							this9[0] = this7[0] - rhs1[0];
							this9[1] = this7[1] - rhs1[1];
							this9[2] = this7[2] - rhs1[2];
							var extent = this9;
							var x = Math.max(extent[0],0);
							var y = Math.max(extent[1],0);
							var z = Math.max(extent[2],0);
							buckets[j].area = buckets1 + 2 * (x * z + x * y + y * z);
							break;
						}
					}
				}
				var _g7 = 0;
				var _g8 = _gthis.bucketCount;
				while(_g7 < _g8) {
					var i3 = _g7++;
					var part = new apparentridges_BVHPartition();
					part.planeIndex = i3;
					part.axis = ax;
					var _g9 = 0;
					var _g10 = i3;
					while(_g9 < _g10) {
						var j1 = _g9++;
						part.leftCount += buckets[j1].count;
						part.leftArea += buckets[j1].area;
						var _this1 = part.leftBBox;
						var bb1 = buckets[j1].bbox;
						_this1.min[0] = Math.min(_this1.min[0],bb1.min[0]);
						_this1.min[1] = Math.min(_this1.min[1],bb1.min[1]);
						_this1.min[2] = Math.min(_this1.min[2],bb1.min[2]);
						_this1.max[0] = Math.max(_this1.max[0],bb1.max[0]);
						_this1.max[1] = Math.max(_this1.max[1],bb1.max[1]);
						_this1.max[2] = Math.max(_this1.max[2],bb1.max[2]);
					}
					var _g11 = i3;
					var _g12 = _gthis.bucketCount;
					while(_g11 < _g12) {
						var j2 = _g11++;
						part.rightCount += buckets[j2].count;
						part.rightArea += buckets[j2].area;
						var _this2 = part.rightBBox;
						var bb2 = buckets[j2].bbox;
						_this2.min[0] = Math.min(_this2.min[0],bb2.min[0]);
						_this2.min[1] = Math.min(_this2.min[1],bb2.min[1]);
						_this2.min[2] = Math.min(_this2.min[2],bb2.min[2]);
						_this2.max[0] = Math.max(_this2.max[0],bb2.max[0]);
						_this2.max[1] = Math.max(_this2.max[1],bb2.max[1]);
						_this2.max[2] = Math.max(_this2.max[2],bb2.max[2]);
					}
					if(part.leftCount > 0 && part.rightCount > 0) {
						var _this3 = part.leftBBox;
						var this10 = _this3.max;
						var rhs2 = _this3.min;
						var this11 = new Array(3);
						var this12 = this11;
						this12[0] = this10[0] - rhs2[0];
						this12[1] = this10[1] - rhs2[1];
						this12[2] = this10[2] - rhs2[2];
						var extent1 = this12;
						var x1 = Math.max(extent1[0],0);
						var y1 = Math.max(extent1[1],0);
						var z1 = Math.max(extent1[2],0);
						var buildRange1 = 2 * (x1 * z1 + x1 * y1 + y1 * z1) / part.leftCount;
						var _this4 = part.rightBBox;
						var this13 = _this4.max;
						var rhs3 = _this4.min;
						var this14 = new Array(3);
						var this15 = this14;
						this15[0] = this13[0] - rhs3[0];
						this15[1] = this13[1] - rhs3[1];
						this15[2] = this13[2] - rhs3[2];
						var extent2 = this15;
						var x2 = Math.max(extent2[0],0);
						var y2 = Math.max(extent2[1],0);
						var z2 = Math.max(extent2[2],0);
						part.SAH = buildRange1 + 2 * (x2 * z2 + x2 * y2 + y2 * z2) / part.rightCount;
						parts.push(part);
					}
				}
			}
			if(parts.length == 0) {
				return node;
			}
			var minSAH = Infinity;
			var minPart = null;
			var _g = 0;
			while(_g < parts.length) {
				var p = parts[_g];
				++_g;
				if(p.SAH < minSAH) {
					minSAH = p.SAH;
					minPart = p;
				}
			}
			var comp = function(f0,f1) {
				var bb0 = new apparentridges_BBox();
				var bb1 = new apparentridges_BBox();
				bboxAddFace(bb0,f0);
				bboxAddFace(bb1,f1);
				var this1 = bb0.min;
				var rhs = bb0.max;
				var this2 = new Array(3);
				var this3 = this2;
				this3[0] = this1[0] + rhs[0];
				this3[1] = this1[1] + rhs[1];
				this3[2] = this1[2] + rhs[2];
				var this1 = this3;
				var this2 = new Array(3);
				var this3 = this2;
				this3[0] = this1[0] * 0.5;
				this3[1] = this1[1] * 0.5;
				this3[2] = this1[2] * 0.5;
				var v = this3[minPart.axis];
				var this1 = bb1.min;
				var rhs = bb1.max;
				var this2 = new Array(3);
				var this3 = this2;
				this3[0] = this1[0] + rhs[0];
				this3[1] = this1[1] + rhs[1];
				this3[2] = this1[2] + rhs[2];
				var this1 = this3;
				var this2 = new Array(3);
				var this3 = this2;
				this3[0] = this1[0] * 0.5;
				this3[1] = this1[1] * 0.5;
				this3[2] = this1[2] * 0.5;
				var v1 = v - this3[minPart.axis];
				if(v1 < 0) {
					return -1;
				}
				if(v1 > 0) {
					return 1;
				}
				return 0;
			};
			var sorted = _gthis.faces.slice(i0,i1);
			sorted.sort(comp);
			var _g = i0;
			var _g1 = i1;
			while(_g < _g1) {
				var i = _g++;
				_gthis.faces[i] = sorted[i - i0];
			}
			var m = i0 + minPart.leftCount;
			node.left = buildRange(i0,m);
			node.right = buildRange(m,i1);
			return node;
		};
		this.root = buildRange(0,this.faces.length);
	}
};
var apparentridges_BVHBucket = function() {
	this.bbox = new apparentridges_BBox();
	this.area = 0;
	this.count = 0;
};
apparentridges_BVHBucket.__name__ = true;
var apparentridges_BVHPartition = function() {
	this.SAH = 0;
	this.rightArea = 0;
	this.leftArea = 0;
	this.rightCount = 0;
	this.leftCount = 0;
	this.leftBBox = new apparentridges_BBox();
	this.rightBBox = new apparentridges_BBox();
};
apparentridges_BVHPartition.__name__ = true;
var apparentridges_OBJParser = $hx_exports["apparentridges"]["OBJParser"] = function() { };
apparentridges_OBJParser.__name__ = true;
apparentridges_OBJParser.fromString = function(str) {
	var mesh = new apparentridges_Mesh();
	mesh.vertices = [];
	mesh.faces = [];
	var lines = str.split("\n");
	var _g = 0;
	var _g1 = lines.length;
	while(_g < _g1) {
		var i = _g++;
		lines[i] = StringTools.trim(lines[i]);
		if(lines[i].charAt(0) == "#") {
			continue;
		}
		if(lines[i].length <= 2) {
			continue;
		}
		var tok = lines[i].split(" ");
		var cmd = tok[0];
		if(cmd == "v") {
			var _x = parseFloat(tok[1]);
			var _y = parseFloat(tok[2]);
			var _z = parseFloat(tok[3]);
			var this1 = new Array(3);
			var this2 = this1;
			this2[0] = _x;
			this2[1] = _y;
			this2[2] = _z;
			var v = this2;
			mesh.vertices.push(v);
		} else if(cmd == "f") {
			var a = Std.parseInt(tok[1].split("/")[0]);
			var b = Std.parseInt(tok[2].split("/")[0]);
			var c = Std.parseInt(tok[3].split("/")[0]);
			var nv = mesh.vertices.length;
			var mesh1 = mesh.faces;
			var this3 = new Array(3);
			var this4 = this3;
			this4[0] = a < 0 ? nv + a : a - 1;
			this4[1] = b < 0 ? nv + b : b - 1;
			this4[2] = c < 0 ? nv + c : c - 1;
			mesh1.push(this4);
		}
	}
	return mesh;
};
var apparentridges_Line = $hx_exports["apparentridges"]["Line"] = function(_x1,_y1,_x2,_y2) {
	this.opacity2 = 1;
	this.opacity1 = 1;
	this.x1 = _x1;
	this.y1 = _y1;
	this.x2 = _x2;
	this.y2 = _y2;
};
apparentridges_Line.__name__ = true;
apparentridges_Line.prototype = {
	setOpacity: function(o1,o2) {
		this.opacity1 = o1;
		this.opacity2 = o2;
	}
	,flip: function() {
		var tmp = this.x1;
		this.x1 = this.x2;
		this.x2 = tmp;
		tmp = this.y1;
		this.y1 = this.y2;
		this.y2 = tmp;
		tmp = this.opacity1;
		this.opacity1 = this.opacity2;
		this.opacity2 = tmp;
	}
};
var apparentridges_Polyline = $hx_exports["apparentridges"]["Polyline"] = {};
apparentridges_Polyline._new = function() {
	var this1 = [];
	return this1;
};
apparentridges_Polyline.get_length = function(this1) {
	return this1.length;
};
apparentridges_Polyline.set_length = function(this1,v) {
	return this1.length;
};
apparentridges_Polyline.startY = function(this1) {
	return Math.round(this1[0][1]) | 0;
};
apparentridges_Polyline.endY = function(this1) {
	return Math.round(this1[this1.length - 1][1]) | 0;
};
apparentridges_Polyline.startX = function(this1) {
	return this1[0][0];
};
apparentridges_Polyline.endX = function(this1) {
	return this1[this1.length - 1][0];
};
apparentridges_Polyline.get = function(this1,i) {
	return this1[i];
};
apparentridges_Polyline.set = function(this1,i,v) {
	this1[i] = v;
	return v;
};
apparentridges_Polyline.push = function(this1,v) {
	this1.push(v);
	return this1.length;
};
apparentridges_Polyline.unshift = function(this1,v) {
	this1.unshift(v);
};
var apparentridges_Render = $hx_exports["apparentridges"]["Render"] = function(_mesh,w,h) {
	this.didPrecompute = false;
	this.verbose = true;
	this.focal = 1000;
	this.mesh = _mesh;
	this.lines = [];
	this.width = w;
	this.height = h;
};
apparentridges_Render.__name__ = true;
apparentridges_Render.prototype = {
	clear: function() {
		if(this.lines != null) {
			this.lines.splice(0,this.lines.length);
		}
		if(this.polylines != null) {
			this.polylines.splice(0,this.polylines.length);
		}
	}
	,setFocal: function(f) {
		this.focal = f;
	}
	,setVerbose: function(v) {
		this.verbose = v > 0;
	}
	,transform: function(mat4x4) {
		var _g = 0;
		var _g1 = this.mesh.vertices.length;
		while(_g < _g1) {
			var i = _g++;
			var tmp = this.mesh.vertices;
			var v = this.mesh.vertices[i];
			var this1 = new Array(3);
			var this2 = this1;
			this2[0] = (mat4x4[0] * v[0] + mat4x4[1] * v[1] + mat4x4[2] * v[2] + mat4x4[3]) / (mat4x4[12] * v[0] + mat4x4[13] * v[1] + mat4x4[14] * v[2] + mat4x4[15]);
			this2[1] = (mat4x4[4] * v[0] + mat4x4[5] * v[1] + mat4x4[6] * v[2] + mat4x4[7]) / (mat4x4[12] * v[0] + mat4x4[13] * v[1] + mat4x4[14] * v[2] + mat4x4[15]);
			this2[2] = (mat4x4[8] * v[0] + mat4x4[9] * v[1] + mat4x4[10] * v[2] + mat4x4[11]) / (mat4x4[12] * v[0] + mat4x4[13] * v[1] + mat4x4[14] * v[2] + mat4x4[15]);
			tmp[i] = this2;
		}
	}
	,scaleRotateTranslate: function(sx,sy,sz,rx,ry,rz,dx,dy,dz) {
		var scl = [sx,0,0,0,0,sy,0,0,0,0,sz,0,0,0,0,1];
		var rotx_0 = 1;
		var rotx_1 = 0;
		var rotx_2 = 0;
		var rotx_3 = 0;
		var rotx_4 = 0;
		var rotx_5 = Math.cos(rx);
		var rotx_6 = -Math.sin(rx);
		var rotx_7 = 0;
		var rotx_8 = 0;
		var rotx_9 = Math.sin(rx);
		var rotx_10 = Math.cos(rx);
		var rotx_11 = 0;
		var rotx_12 = 0;
		var rotx_13 = 0;
		var rotx_14 = 0;
		var rotx_15 = 1;
		var roty_0 = Math.cos(ry);
		var roty_1 = 0;
		var roty_2 = Math.sin(ry);
		var roty_3 = 0;
		var roty_4 = 0;
		var roty_5 = 1;
		var roty_6 = 0;
		var roty_7 = 0;
		var roty_8 = -Math.sin(ry);
		var roty_9 = 0;
		var roty_10 = Math.cos(ry);
		var roty_11 = 0;
		var roty_12 = 0;
		var roty_13 = 0;
		var roty_14 = 0;
		var roty_15 = 1;
		var rotz_0 = Math.cos(rz);
		var rotz_1 = -Math.sin(rz);
		var rotz_2 = 0;
		var rotz_3 = 0;
		var rotz_4 = Math.sin(rz);
		var rotz_5 = Math.cos(rz);
		var rotz_6 = 0;
		var rotz_7 = 0;
		var rotz_8 = 0;
		var rotz_9 = 0;
		var rotz_10 = 1;
		var rotz_11 = 0;
		var rotz_12 = 0;
		var rotz_13 = 0;
		var rotz_14 = 0;
		var rotz_15 = 1;
		var trsl_0 = 1;
		var trsl_1 = 0;
		var trsl_2 = 0;
		var trsl_3 = dx;
		var trsl_4 = 0;
		var trsl_5 = 1;
		var trsl_6 = 0;
		var trsl_7 = dy;
		var trsl_8 = 0;
		var trsl_9 = 0;
		var trsl_10 = 1;
		var trsl_11 = dz;
		var trsl_12 = 0;
		var trsl_13 = 0;
		var trsl_14 = 0;
		var trsl_15 = 1;
		this.transform(scl);
		var B_0 = roty_0 * rotx_0 + roty_1 * rotx_4 + roty_2 * rotx_8 + roty_3 * rotx_12;
		var B_1 = roty_0 * rotx_1 + roty_1 * rotx_5 + roty_2 * rotx_9 + roty_3 * rotx_13;
		var B_2 = roty_0 * rotx_2 + roty_1 * rotx_6 + roty_2 * rotx_10 + roty_3 * rotx_14;
		var B_3 = roty_0 * rotx_3 + roty_1 * rotx_7 + roty_2 * rotx_11 + roty_3 * rotx_15;
		var B_4 = roty_4 * rotx_0 + roty_5 * rotx_4 + roty_6 * rotx_8 + roty_7 * rotx_12;
		var B_5 = roty_4 * rotx_1 + roty_5 * rotx_5 + roty_6 * rotx_9 + roty_7 * rotx_13;
		var B_6 = roty_4 * rotx_2 + roty_5 * rotx_6 + roty_6 * rotx_10 + roty_7 * rotx_14;
		var B_7 = roty_4 * rotx_3 + roty_5 * rotx_7 + roty_6 * rotx_11 + roty_7 * rotx_15;
		var B_8 = roty_8 * rotx_0 + roty_9 * rotx_4 + roty_10 * rotx_8 + roty_11 * rotx_12;
		var B_9 = roty_8 * rotx_1 + roty_9 * rotx_5 + roty_10 * rotx_9 + roty_11 * rotx_13;
		var B_10 = roty_8 * rotx_2 + roty_9 * rotx_6 + roty_10 * rotx_10 + roty_11 * rotx_14;
		var B_11 = roty_8 * rotx_3 + roty_9 * rotx_7 + roty_10 * rotx_11 + roty_11 * rotx_15;
		var B_12 = roty_12 * rotx_0 + roty_13 * rotx_4 + roty_14 * rotx_8 + roty_15 * rotx_12;
		var B_13 = roty_12 * rotx_1 + roty_13 * rotx_5 + roty_14 * rotx_9 + roty_15 * rotx_13;
		var B_14 = roty_12 * rotx_2 + roty_13 * rotx_6 + roty_14 * rotx_10 + roty_15 * rotx_14;
		var B_15 = roty_12 * rotx_3 + roty_13 * rotx_7 + roty_14 * rotx_11 + roty_15 * rotx_15;
		var B_01 = rotz_0 * B_0 + rotz_1 * B_4 + rotz_2 * B_8 + rotz_3 * B_12;
		var B_16 = rotz_0 * B_1 + rotz_1 * B_5 + rotz_2 * B_9 + rotz_3 * B_13;
		var B_21 = rotz_0 * B_2 + rotz_1 * B_6 + rotz_2 * B_10 + rotz_3 * B_14;
		var B_31 = rotz_0 * B_3 + rotz_1 * B_7 + rotz_2 * B_11 + rotz_3 * B_15;
		var B_41 = rotz_4 * B_0 + rotz_5 * B_4 + rotz_6 * B_8 + rotz_7 * B_12;
		var B_51 = rotz_4 * B_1 + rotz_5 * B_5 + rotz_6 * B_9 + rotz_7 * B_13;
		var B_61 = rotz_4 * B_2 + rotz_5 * B_6 + rotz_6 * B_10 + rotz_7 * B_14;
		var B_71 = rotz_4 * B_3 + rotz_5 * B_7 + rotz_6 * B_11 + rotz_7 * B_15;
		var B_81 = rotz_8 * B_0 + rotz_9 * B_4 + rotz_10 * B_8 + rotz_11 * B_12;
		var B_91 = rotz_8 * B_1 + rotz_9 * B_5 + rotz_10 * B_9 + rotz_11 * B_13;
		var B_101 = rotz_8 * B_2 + rotz_9 * B_6 + rotz_10 * B_10 + rotz_11 * B_14;
		var B_111 = rotz_8 * B_3 + rotz_9 * B_7 + rotz_10 * B_11 + rotz_11 * B_15;
		var B_121 = rotz_12 * B_0 + rotz_13 * B_4 + rotz_14 * B_8 + rotz_15 * B_12;
		var B_131 = rotz_12 * B_1 + rotz_13 * B_5 + rotz_14 * B_9 + rotz_15 * B_13;
		var B_141 = rotz_12 * B_2 + rotz_13 * B_6 + rotz_14 * B_10 + rotz_15 * B_14;
		var B_151 = rotz_12 * B_3 + rotz_13 * B_7 + rotz_14 * B_11 + rotz_15 * B_15;
		this.transform([trsl_0 * B_01 + trsl_1 * B_41 + trsl_2 * B_81 + trsl_3 * B_121,trsl_0 * B_16 + trsl_1 * B_51 + trsl_2 * B_91 + trsl_3 * B_131,trsl_0 * B_21 + trsl_1 * B_61 + trsl_2 * B_101 + trsl_3 * B_141,trsl_0 * B_31 + trsl_1 * B_71 + trsl_2 * B_111 + trsl_3 * B_151,trsl_4 * B_01 + trsl_5 * B_41 + trsl_6 * B_81 + trsl_7 * B_121,trsl_4 * B_16 + trsl_5 * B_51 + trsl_6 * B_91 + trsl_7 * B_131,trsl_4 * B_21 + trsl_5 * B_61 + trsl_6 * B_101 + trsl_7 * B_141,trsl_4 * B_31 + trsl_5 * B_71 + trsl_6 * B_111 + trsl_7 * B_151,trsl_8 * B_01 + trsl_9 * B_41 + trsl_10 * B_81 + trsl_11 * B_121,trsl_8 * B_16 + trsl_9 * B_51 + trsl_10 * B_91 + trsl_11 * B_131,trsl_8 * B_21 + trsl_9 * B_61 + trsl_10 * B_101 + trsl_11 * B_141,trsl_8 * B_31 + trsl_9 * B_71 + trsl_10 * B_111 + trsl_11 * B_151,trsl_12 * B_01 + trsl_13 * B_41 + trsl_14 * B_81 + trsl_15 * B_121,trsl_12 * B_16 + trsl_13 * B_51 + trsl_14 * B_91 + trsl_15 * B_131,trsl_12 * B_21 + trsl_13 * B_61 + trsl_14 * B_101 + trsl_15 * B_141,trsl_12 * B_31 + trsl_13 * B_71 + trsl_14 * B_111 + trsl_15 * B_151]);
	}
	,autoPlace: function(zFactor,fFactor) {
		if(fFactor == null) {
			fFactor = 1.25;
		}
		if(zFactor == null) {
			zFactor = 1.5;
		}
		this.mesh.computeBSphere();
		this.transform([1,0,0,-this.mesh.bsphere.o[0],0,1,0,-this.mesh.bsphere.o[1],0,0,1,-this.mesh.bsphere.o[2],0,0,0,1]);
		var a = this.width;
		var b = this.height;
		var r = (a > b ? b : a) / 2;
		this.transform([r / this.mesh.bsphere.r,0,0,0,0,r / this.mesh.bsphere.r,0,0,0,0,r / this.mesh.bsphere.r,0,0,0,0,1]);
		this.transform([1,0,0,0,0,1,0,0,0,0,1,r * zFactor,0,0,0,1]);
		this.setFocal(r * fFactor);
	}
	,vertices: function() {
		var _x = this.width / 2;
		var _y = this.height / 2;
		var this1 = new Array(3);
		var this2 = this1;
		this2[0] = _x;
		this2[1] = _y;
		this2[2] = 0;
		var offs = this2;
		var this1 = new Array(3);
		var this2 = this1;
		this2[0] = -1;
		this2[1] = -1;
		this2[2] = 1;
		var yflip = this2;
		var _g = 0;
		var _g1 = this.mesh.vertices.length;
		while(_g < _g1) {
			var i = _g++;
			var v = this.mesh.vertices[i];
			var f = this.focal;
			var this1 = new Array(3);
			var this2 = this1;
			this2[0] = f * v[0] / v[2];
			this2[1] = f * v[1] / v[2];
			this2[2] = 0;
			var this3 = this2;
			var this4 = new Array(3);
			var this5 = this4;
			this5[0] = this3[0] * yflip[0];
			this5[1] = this3[1] * yflip[1];
			this5[2] = this3[2] * yflip[2];
			var this6 = this5;
			var this7 = new Array(3);
			var this8 = this7;
			this8[0] = this6[0] + offs[0];
			this8[1] = this6[1] + offs[1];
			this8[2] = this6[2] + offs[2];
			var p = this8;
			this.lines.push(new apparentridges_Line(p[0] - 1,p[1] - 1,p[0] + 1,p[1] + 1));
			this.lines.push(new apparentridges_Line(p[0] + 1,p[1] - 1,p[0] - 1,p[1] + 1));
		}
	}
	,edges: function() {
		var _x = this.width / 2;
		var _y = this.height / 2;
		var this1 = new Array(3);
		var this2 = this1;
		this2[0] = _x;
		this2[1] = _y;
		this2[2] = 0;
		var offs = this2;
		var this1 = new Array(3);
		var this2 = this1;
		this2[0] = -1;
		this2[1] = -1;
		this2[2] = 1;
		var yflip = this2;
		var _g = 0;
		var _g1 = this.mesh.faces.length;
		while(_g < _g1) {
			var i = _g++;
			var f = this.mesh.faces[i];
			var f1 = this.focal;
			var v = this.mesh.vertices[f[0]];
			var this1 = new Array(3);
			var this2 = this1;
			this2[0] = f1 * v[0] / v[2];
			this2[1] = f1 * v[1] / v[2];
			this2[2] = 0;
			var this3 = this2;
			var this4 = new Array(3);
			var this5 = this4;
			this5[0] = this3[0] * yflip[0];
			this5[1] = this3[1] * yflip[1];
			this5[2] = this3[2] * yflip[2];
			var this6 = this5;
			var this7 = new Array(3);
			var this8 = this7;
			this8[0] = this6[0] + offs[0];
			this8[1] = this6[1] + offs[1];
			this8[2] = this6[2] + offs[2];
			var p0 = this8;
			var f2 = this.focal;
			var v1 = this.mesh.vertices[f[1]];
			var this9 = new Array(3);
			var this10 = this9;
			this10[0] = f2 * v1[0] / v1[2];
			this10[1] = f2 * v1[1] / v1[2];
			this10[2] = 0;
			var this11 = this10;
			var this12 = new Array(3);
			var this13 = this12;
			this13[0] = this11[0] * yflip[0];
			this13[1] = this11[1] * yflip[1];
			this13[2] = this11[2] * yflip[2];
			var this14 = this13;
			var this15 = new Array(3);
			var this16 = this15;
			this16[0] = this14[0] + offs[0];
			this16[1] = this14[1] + offs[1];
			this16[2] = this14[2] + offs[2];
			var p1 = this16;
			var f3 = this.focal;
			var v2 = this.mesh.vertices[f[2]];
			var this17 = new Array(3);
			var this18 = this17;
			this18[0] = f3 * v2[0] / v2[2];
			this18[1] = f3 * v2[1] / v2[2];
			this18[2] = 0;
			var this19 = this18;
			var this20 = new Array(3);
			var this21 = this20;
			this21[0] = this19[0] * yflip[0];
			this21[1] = this19[1] * yflip[1];
			this21[2] = this19[2] * yflip[2];
			var this22 = this21;
			var this23 = new Array(3);
			var this24 = this23;
			this24[0] = this22[0] + offs[0];
			this24[1] = this22[1] + offs[1];
			this24[2] = this22[2] + offs[2];
			var p2 = this24;
			this.lines.push(new apparentridges_Line(p0[0],p0[1],p1[0],p1[1]));
			this.lines.push(new apparentridges_Line(p1[0],p1[1],p2[0],p2[1]));
			this.lines.push(new apparentridges_Line(p2[0],p2[1],p0[0],p0[1]));
		}
	}
	,apparentRidges: function(thresh,cull) {
		if(cull == null) {
			cull = 2;
		}
		if(!this.didPrecompute) {
			if(this.verbose) {
				console.log("apparentridges/ApparentRidges.hx:1537:","precomputing mesh properties...");
			}
			this.mesh.precompute(cull >= 0,this.verbose);
			this.didPrecompute = true;
		}
		var _x = this.width / 2;
		var _y = this.height / 2;
		var this1 = new Array(3);
		var this2 = this1;
		this2[0] = _x;
		this2[1] = _y;
		this2[2] = 0;
		var offs = this2;
		var this1 = new Array(3);
		var this2 = this1;
		this2[0] = -1;
		this2[1] = -1;
		this2[2] = 1;
		var yflip = this2;
		var this1 = new Array(3);
		var this2 = this1;
		this2[0] = 0;
		this2[1] = 0;
		this2[2] = 0;
		var eye = this2;
		if(this.verbose) {
			console.log("apparentridges/ApparentRidges.hx:1545:","generating apparent ridges...");
		}
		var ridges = this.mesh.apparentRidges(eye,thresh);
		if(this.verbose) {
			console.log("apparentridges/ApparentRidges.hx:1547:","projecting apparent ridges onto 2D plane...");
		}
		var _g = 0;
		var _g1 = ridges.length;
		while(_g < _g1) {
			var i = _g++;
			if(cull >= 0) {
				if(!this.mesh.visible(eye,ridges[i].A,cull) && !this.mesh.visible(eye,ridges[i].B,cull)) {
					continue;
				}
			}
			var f = this.focal;
			var v = ridges[i].A;
			var this1 = new Array(3);
			var this2 = this1;
			this2[0] = f * v[0] / v[2];
			this2[1] = f * v[1] / v[2];
			this2[2] = 0;
			var this3 = this2;
			var this4 = new Array(3);
			var this5 = this4;
			this5[0] = this3[0] * yflip[0];
			this5[1] = this3[1] * yflip[1];
			this5[2] = this3[2] * yflip[2];
			var this6 = this5;
			var this7 = new Array(3);
			var this8 = this7;
			this8[0] = this6[0] + offs[0];
			this8[1] = this6[1] + offs[1];
			this8[2] = this6[2] + offs[2];
			var p0 = this8;
			var f1 = this.focal;
			var v1 = ridges[i].B;
			var this9 = new Array(3);
			var this10 = this9;
			this10[0] = f1 * v1[0] / v1[2];
			this10[1] = f1 * v1[1] / v1[2];
			this10[2] = 0;
			var this11 = this10;
			var this12 = new Array(3);
			var this13 = this12;
			this13[0] = this11[0] * yflip[0];
			this13[1] = this11[1] * yflip[1];
			this13[2] = this11[2] * yflip[2];
			var this14 = this13;
			var this15 = new Array(3);
			var this16 = this15;
			this16[0] = this14[0] + offs[0];
			this16[1] = this14[1] + offs[1];
			this16[2] = this14[2] + offs[2];
			var p1 = this16;
			var l = new apparentridges_Line(p0[0],p0[1],p1[0],p1[1]);
			l.opacity1 = ridges[i].strengthA;
			l.opacity2 = ridges[i].strengthB;
			this.lines.push(l);
		}
		if(this.verbose) {
			console.log("apparentridges/ApparentRidges.hx:1561:","apparent ridges computation finished.");
		}
	}
	,buildPolylines: function(epsilon) {
		if(epsilon == null) {
			epsilon = 1;
		}
		var _gthis = this;
		if(this.verbose) {
			console.log("apparentridges/ApparentRidges.hx:1565:","building polylines from ridge segments...");
		}
		this.polylines = [];
		var _g = [];
		var _g1 = 0;
		var _g2 = this.lines;
		while(_g1 < _g2.length) {
			var v = _g2[_g1];
			++_g1;
			if(!(v.y1 < 0 || v.y1 > _gthis.height - 1 || v.y2 < 0 || v.y2 > _gthis.height - 1)) {
				_g.push(v);
			}
		}
		this.lines = _g;
		var _g = 0;
		var _g1 = this.lines.length;
		while(_g < _g1) {
			var i = _g++;
			var y1 = this.lines[i].y1;
			var y2 = this.lines[i].y2;
			if(y1 > y2) {
				this.lines[i].flip();
			} else if(y1 == y2) {
				if(this.lines[i].x1 > this.lines[i].x2) {
					this.lines[i].flip();
				}
			}
		}
		var _g = [];
		var _g1 = 0;
		var _g2 = this.height;
		while(_g1 < _g2) {
			var i = _g1++;
			_g.push([]);
		}
		var rows = _g;
		var _g = [];
		var _g1 = 0;
		var _g2 = this.height;
		while(_g1 < _g2) {
			var i = _g1++;
			_g.push([]);
		}
		var ends = _g;
		var singleton = function(a) {
			var this1 = [];
			var p = this1;
			var _x = a.x1;
			var _y = a.y1;
			var _z = a.opacity1;
			var this1 = new Array(3);
			var this2 = this1;
			this2[0] = _x;
			this2[1] = _y;
			this2[2] = _z;
			p.push(this2);
			var _x = a.x2;
			var _y = a.y2;
			var _z = a.opacity2;
			var this1 = new Array(3);
			var this2 = this1;
			this2[0] = _x;
			this2[1] = _y;
			this2[2] = _z;
			p.push(this2);
			return p;
		};
		var _g = 0;
		var _g1 = this.lines.length;
		while(_g < _g1) {
			var i = _g++;
			var p = singleton(this.lines[i]);
			rows[Math.round(this.lines[i].y1) | 0].push(p);
			ends[Math.round(this.lines[i].y2) | 0].push(p);
		}
		var _g = 0;
		var _g1 = rows.length;
		while(_g < _g1) {
			var i = _g++;
			var nj = rows[i].length;
			var _g2 = 0;
			var _g3 = nj;
			while(_g2 < _g3) {
				var _j = _g2++;
				var j = nj - _j - 1;
				if(rows[i][j] == null) {
					continue;
				}
				var nk = ends[i].length;
				var _g4 = 0;
				var _g5 = nk;
				while(_g4 < _g5) {
					var _k = _g4++;
					var k = nk - _k - 1;
					if(ends[i][k] == null) {
						continue;
					}
					if(rows[i][j] == ends[i][k]) {
						continue;
					}
					var this1 = rows[i][j];
					var r = Math.round(this1[this1.length - 1][1]) | 0;
					var this2 = ends[i][k];
					var d = Math.abs(rows[i][j][0][0] - this2[this2.length - 1][0]);
					if(d <= epsilon) {
						if(d < 1) {
							ends[i][k][ends[i][k].length - 1][2] = (ends[i][k][ends[i][k].length - 1][2] + rows[i][j][0][2]) / 2;
						}
						var _g6 = d < 1 ? 1 : 0;
						var _g7 = rows[i][j].length;
						while(_g6 < _g7) {
							var t = _g6++;
							var this3 = ends[i][k];
							this3.push(rows[i][j][t]);
						}
						HxOverrides.remove(ends[r],rows[i][j]);
						ends[r].push(ends[i][k]);
						ends[i][k] = null;
						break;
					}
				}
			}
		}
		var _g = 0;
		var _g1 = ends.length;
		while(_g < _g1) {
			var i = _g++;
			var _g2 = 0;
			var _g3 = ends[i].length;
			while(_g2 < _g3) {
				var j = _g2++;
				if(ends[i][j] != null) {
					this.polylines.push(ends[i][j]);
				}
			}
		}
		var _g = [];
		var _g1 = 0;
		var _g2 = this.polylines;
		while(_g1 < _g2.length) {
			var v = _g2[_g1];
			++_g1;
			var tmp;
			if(v.length > 2) {
				tmp = true;
			} else if(v.length < 2) {
				tmp = false;
			} else {
				var v1 = v[0];
				var v2 = v[1];
				var x = v1[0] - v2[0];
				var x1 = v1[1] - v2[1];
				var x2 = v1[2] - v2[2];
				tmp = Math.sqrt(x * x + x1 * x1 + x2 * x2) < epsilon ? false : true;
			}
			if(tmp) {
				_g.push(v);
			}
		}
		this.polylines = _g;
		if(this.verbose) {
			console.log("apparentridges/ApparentRidges.hx:1656:","polylines built.");
		}
	}
};
var apparentridges_PixelMap = $hx_exports["apparentridges"]["PixelMap"] = function() { };
apparentridges_PixelMap.__name__ = true;
apparentridges_PixelMap.raycast = function(render,fun) {
	var min = Infinity;
	var max = -Infinity;
	var width = render.width;
	var height = render.height;
	var hw = width / 2 | 0;
	var hh = height / 2 | 0;
	var _g = -hh;
	var _g1 = height - hh;
	while(_g < _g1) {
		var y = _g++;
		var _g2 = -hw;
		var _g3 = width - hw;
		while(_g2 < _g3) {
			var x = _g2++;
			var r_tmin = [];
			var r_tmax = [];
			var r_o = [];
			var r_d = [];
			var r_o1 = r_o;
			var this1 = new Array(3);
			var this2 = this1;
			this2[0] = 0;
			this2[1] = 0;
			this2[2] = 0;
			r_o1[0] = this2;
			var r_d1 = r_d;
			var _z = render.focal;
			var this3 = new Array(3);
			var this4 = this3;
			this4[0] = -x;
			this4[1] = -y;
			this4[2] = _z;
			r_d1[0] = this4;
			r_tmax[0] = Infinity;
			r_tmin[0] = 0;
			var this5 = r_d[0];
			var l = Math.sqrt(this5[0] * this5[0] + this5[1] * this5[1] + this5[2] * this5[2]);
			if(l > 0) {
				l = 1 / l;
				this5[0] *= l;
				this5[1] *= l;
				this5[2] *= l;
			} else {
				this5[0] = 0;
				this5[1] = 0;
				this5[2] = 1;
			}
			var bvh = [render.mesh.bvh];
			var hitNode = [null];
			hitNode[0] = (function(r_tmax,r_tmin,r_d,r_o,hitNode,bvh) {
				return function(node) {
					if(node.left == null && node.right == null) {
						var tmin = Infinity;
						var closest = null;
						var _g = node.begin;
						var _g1 = node.end;
						while(_g < _g1) {
							var i = _g++;
							var p0 = bvh[0].mesh.vertices[bvh[0].faces[i][0]];
							var p1 = bvh[0].mesh.vertices[bvh[0].faces[i][1]];
							var p2 = bvh[0].mesh.vertices[bvh[0].faces[i][2]];
							var this1 = new Array(3);
							var this2 = this1;
							this2[0] = p1[0] - p0[0];
							this2[1] = p1[1] - p0[1];
							this2[2] = p1[2] - p0[2];
							var e1 = this2;
							var this3 = new Array(3);
							var this4 = this3;
							this4[0] = p2[0] - p0[0];
							this4[1] = p2[1] - p0[1];
							this4[2] = p2[2] - p0[2];
							var e2 = this4;
							var this5 = r_o[0];
							var this6 = new Array(3);
							var this7 = this6;
							this7[0] = this5[0] - p0[0];
							this7[1] = this5[1] - p0[1];
							this7[2] = this5[2] - p0[2];
							var s = this7;
							var this8 = r_d[0];
							var this9 = new Array(3);
							var this10 = this9;
							this10[0] = this8[0] * -1.0;
							this10[1] = this8[1] * -1.0;
							this10[2] = this8[2] * -1.0;
							var _d = this10;
							var this11 = new Array(3);
							var this12 = this11;
							this12[0] = e1[1] * e2[2] - e1[2] * e2[1];
							this12[1] = e1[2] * e2[0] - e1[0] * e2[2];
							this12[2] = e1[0] * e2[1] - e1[1] * e2[0];
							var v1 = this12;
							var denom = v1[0] * _d[0] + v1[1] * _d[1] + v1[2] * _d[2];
							var h;
							if(denom == 0) {
								h = null;
							} else {
								var this13 = new Array(3);
								var this14 = this13;
								this14[0] = s[1] * e2[2] - s[2] * e2[1];
								this14[1] = s[2] * e2[0] - s[0] * e2[2];
								this14[2] = s[0] * e2[1] - s[1] * e2[0];
								var v11 = this14;
								var _x = v11[0] * _d[0] + v11[1] * _d[1] + v11[2] * _d[2];
								var this15 = new Array(3);
								var this16 = this15;
								this16[0] = e1[1] * s[2] - e1[2] * s[1];
								this16[1] = e1[2] * s[0] - e1[0] * s[2];
								this16[2] = e1[0] * s[1] - e1[1] * s[0];
								var v12 = this16;
								var _y = v12[0] * _d[0] + v12[1] * _d[1] + v12[2] * _d[2];
								var this17 = new Array(3);
								var this18 = this17;
								this18[0] = e1[1] * e2[2] - e1[2] * e2[1];
								this18[1] = e1[2] * e2[0] - e1[0] * e2[2];
								this18[2] = e1[0] * e2[1] - e1[1] * e2[0];
								var v13 = this18;
								var _z = v13[0] * s[0] + v13[1] * s[1] + v13[2] * s[2];
								var this19 = new Array(3);
								var this20 = this19;
								this20[0] = _x;
								this20[1] = _y;
								this20[2] = _z;
								var this21 = this20;
								var rhs = 1 / denom;
								var this22 = new Array(3);
								var this23 = this22;
								this23[0] = this21[0] * rhs;
								this23[1] = this21[1] * rhs;
								this23[2] = this21[2] * rhs;
								var uvt = this23;
								var u = uvt[0];
								var v = uvt[1];
								var t = uvt[2];
								if(u < 0 || v < 0 || 1 - u - v < 0 || t < r_tmin[0] || t > r_tmax[0]) {
									h = null;
								} else {
									var h1 = new apparentridges_RayHit(t);
									h1.u = u;
									h1.v = v;
									h = h1;
								}
							}
							if(h != null) {
								h.face = bvh[0].faces[i];
								if(tmin > h.t) {
									tmin = h.t;
									closest = h;
								}
							}
						}
						return closest;
					}
					var bb = node.left.bbox;
					var tx1 = (bb.min[0] - r_o[0][0]) / r_d[0][0];
					var tx2 = (bb.max[0] - r_o[0][0]) / r_d[0][0];
					var ty1 = (bb.min[1] - r_o[0][1]) / r_d[0][1];
					var ty2 = (bb.max[1] - r_o[0][1]) / r_d[0][1];
					var tz1 = (bb.min[2] - r_o[0][2]) / r_d[0][2];
					var tz2 = (bb.max[2] - r_o[0][2]) / r_d[0][2];
					var t1 = Math.max(Math.max(Math.min(tx1,tx2),Math.min(ty1,ty2)),Math.min(tz1,tz2));
					var t2 = Math.min(Math.min(Math.max(tx1,tx2),Math.max(ty1,ty2)),Math.max(tz1,tz2));
					var hitL;
					if(t2 - t1 < 0) {
						hitL = null;
					} else if(t1 > r_tmax[0] || t2 < r_tmin[0]) {
						hitL = null;
					} else {
						var h = new apparentridges_RayHit(t1);
						h.t2 = t2;
						hitL = h;
					}
					var bb = node.right.bbox;
					var tx1 = (bb.min[0] - r_o[0][0]) / r_d[0][0];
					var tx2 = (bb.max[0] - r_o[0][0]) / r_d[0][0];
					var ty1 = (bb.min[1] - r_o[0][1]) / r_d[0][1];
					var ty2 = (bb.max[1] - r_o[0][1]) / r_d[0][1];
					var tz1 = (bb.min[2] - r_o[0][2]) / r_d[0][2];
					var tz2 = (bb.max[2] - r_o[0][2]) / r_d[0][2];
					var t1 = Math.max(Math.max(Math.min(tx1,tx2),Math.min(ty1,ty2)),Math.min(tz1,tz2));
					var t2 = Math.min(Math.min(Math.max(tx1,tx2),Math.max(ty1,ty2)),Math.max(tz1,tz2));
					var hitR;
					if(t2 - t1 < 0) {
						hitR = null;
					} else if(t1 > r_tmax[0] || t2 < r_tmin[0]) {
						hitR = null;
					} else {
						var h = new apparentridges_RayHit(t1);
						h.t2 = t2;
						hitR = h;
					}
					if(hitL != null && hitR == null) {
						return hitNode[0](node.left);
					} else if(hitL == null && hitR != null) {
						return hitNode[0](node.right);
					} else if(hitL == null && hitR == null) {
						return null;
					}
					var first;
					var second;
					if(hitL.t < hitR.t) {
						first = node.left;
						second = node.right;
					} else {
						first = node.right;
						second = node.left;
					}
					var h = hitNode[0](first);
					if(h == null || h.t >= Math.max(hitL.t,hitR.t)) {
						var h2 = hitNode[0](second);
						if(h2 != null) {
							if(h == null || h2.t < h.t) {
								return h2;
							}
						}
					}
					return h;
				};
			})(r_tmax,r_tmin,r_d,r_o,hitNode,bvh);
			var h = hitNode[0](bvh[0].root);
			fun(h,x + hh,y + hh);
		}
	}
};
apparentridges_PixelMap.depth = function(render,normalize) {
	if(normalize == null) {
		normalize = false;
	}
	var this1 = new Array(render.width * render.height);
	var data = this1;
	var min = Infinity;
	var max = -Infinity;
	apparentridges_PixelMap.raycast(render,function(h,x,y) {
		if(h == null) {
			var index = y * render.width + x;
			var val = Infinity;
			data[index] = val;
		} else {
			min = Math.min(min,h.t);
			max = Math.max(max,h.t);
			data[y * render.width + x] = h.t;
		}
	});
	if(normalize) {
		var _g = 0;
		var _g1 = data.length;
		while(_g < _g1) {
			var i = _g++;
			if(data[i] != Infinity) {
				data[i] = 1 - (data[i] - min) / (max - min);
			} else {
				data[i] = 0;
			}
		}
	}
	return data;
};
apparentridges_PixelMap.normal = function(render) {
	var this1 = new Array(render.width * render.height * 3);
	var data = this1;
	apparentridges_PixelMap.raycast(render,function(h,x,y) {
		var idx = (y * render.width + x) * 3;
		if(h == null) {
			data[idx] = 0;
			data[idx + 1] = 0;
			data[idx + 2] = 0;
		} else {
			var f = h.face;
			var n0 = render.mesh.normals[f[0]];
			var n1 = render.mesh.normals[f[1]];
			var n2 = render.mesh.normals[f[2]];
			var rhs = 1 - h.u - h.v;
			var this1 = new Array(3);
			var this2 = this1;
			this2[0] = n0[0] * rhs;
			this2[1] = n0[1] * rhs;
			this2[2] = n0[2] * rhs;
			var this1 = this2;
			var rhs = h.u;
			var this2 = new Array(3);
			var this3 = this2;
			this3[0] = n1[0] * rhs;
			this3[1] = n1[1] * rhs;
			this3[2] = n1[2] * rhs;
			var rhs = this3;
			var this2 = new Array(3);
			var this3 = this2;
			this3[0] = this1[0] + rhs[0];
			this3[1] = this1[1] + rhs[1];
			this3[2] = this1[2] + rhs[2];
			var this1 = this3;
			var rhs = h.v;
			var this2 = new Array(3);
			var this3 = this2;
			this3[0] = n2[0] * rhs;
			this3[1] = n2[1] * rhs;
			this3[2] = n2[2] * rhs;
			var rhs = this3;
			var this2 = new Array(3);
			var this3 = this2;
			this3[0] = this1[0] + rhs[0];
			this3[1] = this1[1] + rhs[1];
			this3[2] = this1[2] + rhs[2];
			var n = this3;
			data[idx] = n[0];
			data[idx + 1] = n[1];
			data[idx + 2] = n[2];
		}
	});
	return data;
};
apparentridges_PixelMap.curvature = function(render) {
	var this1 = new Array(render.width * render.height * 2);
	var data = this1;
	apparentridges_PixelMap.raycast(render,function(h,x,y) {
		var idx = (y * render.width + x) * 2;
		if(h == null) {
			data[idx] = 0;
			data[idx + 1] = 0;
		} else {
			var f = h.face;
			var c1a = render.mesh.curv1[f[0]];
			var c1b = render.mesh.curv1[f[1]];
			var c1c = render.mesh.curv1[f[2]];
			var c2a = render.mesh.curv2[f[0]];
			var c2b = render.mesh.curv2[f[1]];
			var c2c = render.mesh.curv2[f[2]];
			var c1 = c1a * (1 - h.u - h.v) + c1b * h.u + c1c * h.v;
			var c2 = c2a * (1 - h.u - h.v) + c2b * h.u + c2c * h.v;
			data[idx] = c1;
			data[idx + 1] = c2;
		}
	});
	return data;
};
apparentridges_PixelMap.lambertian = function(render,light,normalize) {
	if(normalize == null) {
		normalize = true;
	}
	var this1 = new Array(render.width * render.height);
	var data = this1;
	var min = Infinity;
	var max = -Infinity;
	apparentridges_PixelMap.raycast(render,function(h,x,y) {
		var idx = y * render.width + x;
		if(h == null) {
			var val = -Infinity;
			data[idx] = val;
		} else {
			var f = h.face;
			var n0 = render.mesh.normals[f[0]];
			var n1 = render.mesh.normals[f[1]];
			var n2 = render.mesh.normals[f[2]];
			var rhs = 1 - h.u - h.v;
			var this1 = new Array(3);
			var this2 = this1;
			this2[0] = n0[0] * rhs;
			this2[1] = n0[1] * rhs;
			this2[2] = n0[2] * rhs;
			var this1 = this2;
			var rhs = h.u;
			var this2 = new Array(3);
			var this3 = this2;
			this3[0] = n1[0] * rhs;
			this3[1] = n1[1] * rhs;
			this3[2] = n1[2] * rhs;
			var rhs = this3;
			var this2 = new Array(3);
			var this3 = this2;
			this3[0] = this1[0] + rhs[0];
			this3[1] = this1[1] + rhs[1];
			this3[2] = this1[2] + rhs[2];
			var this1 = this3;
			var rhs = h.v;
			var this2 = new Array(3);
			var this3 = this2;
			this3[0] = n2[0] * rhs;
			this3[1] = n2[1] * rhs;
			this3[2] = n2[2] * rhs;
			var rhs = this3;
			var this2 = new Array(3);
			var this3 = this2;
			this3[0] = this1[0] + rhs[0];
			this3[1] = this1[1] + rhs[1];
			this3[2] = this1[2] + rhs[2];
			var n = this3;
			var ndotl = n[0] * light[0] + n[1] * light[1] + n[2] * light[2];
			min = Math.min(min,ndotl);
			max = Math.max(max,ndotl);
			data[idx] = ndotl;
		}
	});
	if(normalize) {
		var _g = 0;
		var _g1 = data.length;
		while(_g < _g1) {
			var i = _g++;
			if(data[i] != -Infinity) {
				data[i] = (data[i] - min) / (max - min);
			} else {
				data[i] = 0;
			}
		}
	}
	return data;
};
apparentridges_PixelMap.ambientOcclusion = function(render,numSamples,normalize) {
	if(normalize == null) {
		normalize = true;
	}
	if(numSamples == null) {
		numSamples = 32;
	}
	var this1 = new Array(render.width * render.height);
	var data = this1;
	var min = Infinity;
	var max = -Infinity;
	apparentridges_PixelMap.raycast(render,function(h,x,y) {
		var idx = y * render.width + x;
		if(h == null) {
			var val = -Infinity;
			data[idx] = val;
		} else {
			var f = h.face;
			var p0 = render.mesh.vertices[f[0]];
			var p1 = render.mesh.vertices[f[1]];
			var p2 = render.mesh.vertices[f[2]];
			var rhs = 1 - h.u - h.v;
			var this1 = new Array(3);
			var this2 = this1;
			this2[0] = p0[0] * rhs;
			this2[1] = p0[1] * rhs;
			this2[2] = p0[2] * rhs;
			var this1 = this2;
			var rhs = h.u;
			var this2 = new Array(3);
			var this3 = this2;
			this3[0] = p1[0] * rhs;
			this3[1] = p1[1] * rhs;
			this3[2] = p1[2] * rhs;
			var rhs = this3;
			var this2 = new Array(3);
			var this3 = this2;
			this3[0] = this1[0] + rhs[0];
			this3[1] = this1[1] + rhs[1];
			this3[2] = this1[2] + rhs[2];
			var this1 = this3;
			var rhs = h.v;
			var this2 = new Array(3);
			var this3 = this2;
			this3[0] = p2[0] * rhs;
			this3[1] = p2[1] * rhs;
			this3[2] = p2[2] * rhs;
			var rhs = this3;
			var this2 = new Array(3);
			var this3 = this2;
			this3[0] = this1[0] + rhs[0];
			this3[1] = this1[1] + rhs[1];
			this3[2] = this1[2] + rhs[2];
			var o = this3;
			var cnt = 0;
			var _g = 0;
			var _g1 = numSamples;
			while(_g < _g1) {
				var i = _g++;
				var Xi1 = Math.random();
				var Xi2 = Math.random();
				var theta = Math.acos(Xi1);
				var phi = 2 * Math.PI * Xi2;
				var xs = Math.sin(theta) * Math.cos(phi);
				var ys = Math.sin(theta) * Math.sin(phi);
				var zs = Math.cos(theta);
				var this1 = new Array(3);
				var this2 = this1;
				this2[0] = xs;
				this2[1] = ys;
				this2[2] = zs;
				var v = this2;
				var d = v;
				if(Math.random() < 0.5) {
					d[2] = -d[2];
				}
				var r_tmin = [];
				var r_tmax = [];
				var r_o = [];
				var r_d = [];
				r_d[0] = d;
				r_o[0] = o;
				r_tmin[0] = 0.1;
				r_tmax[0] = Infinity;
				var bvh = [render.mesh.bvh];
				var hitNode = [null];
				hitNode[0] = (function(r_tmax,r_tmin,r_d,r_o,hitNode,bvh) {
					return function(node) {
						if(node.left == null && node.right == null) {
							var tmin = Infinity;
							var closest = null;
							var _g = node.begin;
							var _g1 = node.end;
							while(_g < _g1) {
								var i = _g++;
								var p0 = bvh[0].mesh.vertices[bvh[0].faces[i][0]];
								var p1 = bvh[0].mesh.vertices[bvh[0].faces[i][1]];
								var p2 = bvh[0].mesh.vertices[bvh[0].faces[i][2]];
								var this1 = new Array(3);
								var this2 = this1;
								this2[0] = p1[0] - p0[0];
								this2[1] = p1[1] - p0[1];
								this2[2] = p1[2] - p0[2];
								var e1 = this2;
								var this3 = new Array(3);
								var this4 = this3;
								this4[0] = p2[0] - p0[0];
								this4[1] = p2[1] - p0[1];
								this4[2] = p2[2] - p0[2];
								var e2 = this4;
								var this5 = r_o[0];
								var this6 = new Array(3);
								var this7 = this6;
								this7[0] = this5[0] - p0[0];
								this7[1] = this5[1] - p0[1];
								this7[2] = this5[2] - p0[2];
								var s = this7;
								var this8 = r_d[0];
								var this9 = new Array(3);
								var this10 = this9;
								this10[0] = this8[0] * -1.0;
								this10[1] = this8[1] * -1.0;
								this10[2] = this8[2] * -1.0;
								var _d = this10;
								var this11 = new Array(3);
								var this12 = this11;
								this12[0] = e1[1] * e2[2] - e1[2] * e2[1];
								this12[1] = e1[2] * e2[0] - e1[0] * e2[2];
								this12[2] = e1[0] * e2[1] - e1[1] * e2[0];
								var v1 = this12;
								var denom = v1[0] * _d[0] + v1[1] * _d[1] + v1[2] * _d[2];
								var h;
								if(denom == 0) {
									h = null;
								} else {
									var this13 = new Array(3);
									var this14 = this13;
									this14[0] = s[1] * e2[2] - s[2] * e2[1];
									this14[1] = s[2] * e2[0] - s[0] * e2[2];
									this14[2] = s[0] * e2[1] - s[1] * e2[0];
									var v11 = this14;
									var _x = v11[0] * _d[0] + v11[1] * _d[1] + v11[2] * _d[2];
									var this15 = new Array(3);
									var this16 = this15;
									this16[0] = e1[1] * s[2] - e1[2] * s[1];
									this16[1] = e1[2] * s[0] - e1[0] * s[2];
									this16[2] = e1[0] * s[1] - e1[1] * s[0];
									var v12 = this16;
									var _y = v12[0] * _d[0] + v12[1] * _d[1] + v12[2] * _d[2];
									var this17 = new Array(3);
									var this18 = this17;
									this18[0] = e1[1] * e2[2] - e1[2] * e2[1];
									this18[1] = e1[2] * e2[0] - e1[0] * e2[2];
									this18[2] = e1[0] * e2[1] - e1[1] * e2[0];
									var v13 = this18;
									var _z = v13[0] * s[0] + v13[1] * s[1] + v13[2] * s[2];
									var this19 = new Array(3);
									var this20 = this19;
									this20[0] = _x;
									this20[1] = _y;
									this20[2] = _z;
									var this21 = this20;
									var rhs = 1 / denom;
									var this22 = new Array(3);
									var this23 = this22;
									this23[0] = this21[0] * rhs;
									this23[1] = this21[1] * rhs;
									this23[2] = this21[2] * rhs;
									var uvt = this23;
									var u = uvt[0];
									var v = uvt[1];
									var t = uvt[2];
									if(u < 0 || v < 0 || 1 - u - v < 0 || t < r_tmin[0] || t > r_tmax[0]) {
										h = null;
									} else {
										var h1 = new apparentridges_RayHit(t);
										h1.u = u;
										h1.v = v;
										h = h1;
									}
								}
								if(h != null) {
									h.face = bvh[0].faces[i];
									if(tmin > h.t) {
										tmin = h.t;
										closest = h;
									}
								}
							}
							return closest;
						}
						var bb = node.left.bbox;
						var tx1 = (bb.min[0] - r_o[0][0]) / r_d[0][0];
						var tx2 = (bb.max[0] - r_o[0][0]) / r_d[0][0];
						var ty1 = (bb.min[1] - r_o[0][1]) / r_d[0][1];
						var ty2 = (bb.max[1] - r_o[0][1]) / r_d[0][1];
						var tz1 = (bb.min[2] - r_o[0][2]) / r_d[0][2];
						var tz2 = (bb.max[2] - r_o[0][2]) / r_d[0][2];
						var t1 = Math.max(Math.max(Math.min(tx1,tx2),Math.min(ty1,ty2)),Math.min(tz1,tz2));
						var t2 = Math.min(Math.min(Math.max(tx1,tx2),Math.max(ty1,ty2)),Math.max(tz1,tz2));
						var hitL;
						if(t2 - t1 < 0) {
							hitL = null;
						} else if(t1 > r_tmax[0] || t2 < r_tmin[0]) {
							hitL = null;
						} else {
							var h = new apparentridges_RayHit(t1);
							h.t2 = t2;
							hitL = h;
						}
						var bb = node.right.bbox;
						var tx1 = (bb.min[0] - r_o[0][0]) / r_d[0][0];
						var tx2 = (bb.max[0] - r_o[0][0]) / r_d[0][0];
						var ty1 = (bb.min[1] - r_o[0][1]) / r_d[0][1];
						var ty2 = (bb.max[1] - r_o[0][1]) / r_d[0][1];
						var tz1 = (bb.min[2] - r_o[0][2]) / r_d[0][2];
						var tz2 = (bb.max[2] - r_o[0][2]) / r_d[0][2];
						var t1 = Math.max(Math.max(Math.min(tx1,tx2),Math.min(ty1,ty2)),Math.min(tz1,tz2));
						var t2 = Math.min(Math.min(Math.max(tx1,tx2),Math.max(ty1,ty2)),Math.max(tz1,tz2));
						var hitR;
						if(t2 - t1 < 0) {
							hitR = null;
						} else if(t1 > r_tmax[0] || t2 < r_tmin[0]) {
							hitR = null;
						} else {
							var h = new apparentridges_RayHit(t1);
							h.t2 = t2;
							hitR = h;
						}
						if(hitL != null && hitR == null) {
							return hitNode[0](node.left);
						} else if(hitL == null && hitR != null) {
							return hitNode[0](node.right);
						} else if(hitL == null && hitR == null) {
							return null;
						}
						var first;
						var second;
						if(hitL.t < hitR.t) {
							first = node.left;
							second = node.right;
						} else {
							first = node.right;
							second = node.left;
						}
						var h = hitNode[0](first);
						if(h == null || h.t >= Math.max(hitL.t,hitR.t)) {
							var h2 = hitNode[0](second);
							if(h2 != null) {
								if(h == null || h2.t < h.t) {
									return h2;
								}
							}
						}
						return h;
					};
				})(r_tmax,r_tmin,r_d,r_o,hitNode,bvh);
				var h = hitNode[0](bvh[0].root);
				if(h != null) {
					++cnt;
				}
			}
			var v = 1 - cnt / numSamples;
			min = Math.min(min,v);
			max = Math.max(max,v);
			data[idx] = v;
		}
	});
	if(normalize) {
		var _g = 0;
		var _g1 = data.length;
		while(_g < _g1) {
			var i = _g++;
			if(data[i] != -Infinity) {
				data[i] = (data[i] - min) / (max - min);
			} else {
				data[i] = 0;
			}
		}
	}
	return data;
};
apparentridges_PixelMap.toPPMString = function(data,w,h,min,max) {
	var chan = data.length / (w * h) | 0;
	var out_b = "";
	out_b += Std.string("P3\n" + w + " " + h + "\n255\n");
	var _g = 0;
	var _g1 = data.length / chan | 0;
	while(_g < _g1) {
		var i = _g++;
		var u = Math.min(Math.max((data[i * chan] - min) / (max - min) * 255,0),255) | 0;
		var v = chan == 1 ? u : Math.min(Math.max((data[i * chan + 1] - min) / (max - min) * 255,0),255) | 0;
		var w = chan == 1 ? u : chan == 2 ? 128 : Math.min(Math.max((data[i * chan + 2] - min) / (max - min) * 255,0),255) | 0;
		out_b += Std.string("" + u + " " + v + " " + w + " ");
	}
	return out_b;
};
var apparentridges_SVGWriter = $hx_exports["apparentridges"]["SVGWriter"] = function() { };
apparentridges_SVGWriter.__name__ = true;
apparentridges_SVGWriter.rd = function(x) {
	return Math.round(x * 100) / 100;
};
apparentridges_SVGWriter.lines = function(render,useOpacity) {
	if(useOpacity == null) {
		useOpacity = true;
	}
	var w = render.width;
	var h = render.height;
	var out_b = "";
	out_b += Std.string("<svg version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" width=\"" + w + "\" height=\"" + h + "\">\n");
	var _g = 0;
	var _g1 = render.lines.length;
	while(_g < _g1) {
		var i = _g++;
		var x1 = Math.round(render.lines[i].x1 * 100) / 100;
		var y1 = Math.round(render.lines[i].y1 * 100) / 100;
		var x2 = Math.round(render.lines[i].x2 * 100) / 100;
		var y2 = Math.round(render.lines[i].y2 * 100) / 100;
		var o = useOpacity ? (render.lines[i].opacity1 + render.lines[i].opacity2) / 2 : 1;
		var oi = 255 - o * 255 | 0;
		out_b += Std.string("  <line x1=\"" + x1 + "\" y1=\"" + y1 + "\" x2=\"" + x2 + "\" y2=\"" + y2 + "\" fill=\"none\" stroke=\"rgb(" + oi + "," + oi + "," + oi + ")\" stroke-width=\"1\" stroke-linecap=\"round\"/>\n");
	}
	out_b += "</svg>\n";
	return out_b;
};
apparentridges_SVGWriter.polylines = function(render,colorful) {
	if(colorful == null) {
		colorful = false;
	}
	var w = render.width;
	var h = render.height;
	var out_b = "";
	out_b += Std.string("<svg version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" width=\"" + w + "\" height=\"" + h + "\">\n");
	var color = "black";
	var _g = 0;
	var _g1 = render.polylines.length;
	while(_g < _g1) {
		var i = _g++;
		out_b += "  <polyline points=\"";
		var _g2 = 0;
		var _g3 = render.polylines[i].length;
		while(_g2 < _g3) {
			var j = _g2++;
			var p = render.polylines[i][j];
			out_b += Std.string("" + Math.round(p[0] * 100) / 100 + "," + Math.round(p[1] * 100) / 100 + " ");
		}
		if(colorful) {
			color = "rgb(" + (Math.random() * 128 | 0) + "," + (Math.random() * 128 | 0) + "," + (Math.random() * 128 | 0) + ")";
		}
		out_b += Std.string("\" fill=\"none\" stroke=\"" + color + "\" stroke-width=\"1\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/>\n");
	}
	out_b += "</svg>\n";
	return out_b;
};
apparentridges_SVGWriter.gradients = function(render,acc) {
	if(acc == null) {
		acc = 1;
	}
	var w = render.width;
	var h = render.height;
	var out_b = "";
	out_b += Std.string("<svg version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" width=\"" + w + "\" height=\"" + h + "\">\n");
	var gid = 0;
	var _g = 0;
	var _g1 = render.polylines.length;
	while(_g < _g1) {
		var i = _g++;
		var _g2 = 0;
		var _g3 = render.polylines[i].length;
		while(_g2 < _g3) {
			var j = _g2++;
			var p = render.polylines[i][j];
			var oi = 255 - p[2] * 255 | 0;
			out_b += Std.string("  <circle cx=\"" + Math.round(p[0] * 100) / 100 + "\" cy=\"" + Math.round(p[1] * 100) / 100 + "\" r=\"0.5\" stroke=\"none\" fill=\"rgb(" + oi + "," + oi + "," + oi + ")\"/>\n");
		}
	}
	var _g = 0;
	var _g1 = render.polylines.length;
	while(_g < _g1) {
		var i = _g++;
		out_b += "  <g fill=\"none\" stroke-width=\"1\">\n";
		var _g2 = 0;
		var _g3 = render.polylines[i].length - 1;
		while(_g2 < _g3) {
			var j = _g2++;
			var p = render.polylines[i][j];
			var q = render.polylines[i][j + 1];
			var d = (Math.abs(p[2] - q[2]) * 10 * acc | 0) + 1;
			var _g4 = 0;
			var _g5 = d;
			while(_g4 < _g5) {
				var k = _g4++;
				var t = k / d - 0.01;
				var s = (k + 1) / d + 0.01;
				var rhs = 1 - t;
				var this1 = new Array(3);
				var this2 = this1;
				this2[0] = p[0] * rhs;
				this2[1] = p[1] * rhs;
				this2[2] = p[2] * rhs;
				var this3 = this2;
				var this4 = new Array(3);
				var this5 = this4;
				this5[0] = q[0] * t;
				this5[1] = q[1] * t;
				this5[2] = q[2] * t;
				var rhs1 = this5;
				var this6 = new Array(3);
				var this7 = this6;
				this7[0] = this3[0] + rhs1[0];
				this7[1] = this3[1] + rhs1[1];
				this7[2] = this3[2] + rhs1[2];
				var a = this7;
				var rhs2 = 1 - s;
				var this8 = new Array(3);
				var this9 = this8;
				this9[0] = p[0] * rhs2;
				this9[1] = p[1] * rhs2;
				this9[2] = p[2] * rhs2;
				var this10 = this9;
				var this11 = new Array(3);
				var this12 = this11;
				this12[0] = q[0] * s;
				this12[1] = q[1] * s;
				this12[2] = q[2] * s;
				var rhs3 = this12;
				var this13 = new Array(3);
				var this14 = this13;
				this14[0] = this10[0] + rhs3[0];
				this14[1] = this10[1] + rhs3[1];
				this14[2] = this10[2] + rhs3[2];
				var b = this14;
				var o = (a[2] + b[2]) / 2;
				var oi = 255 - o * 255 | 0;
				out_b += Std.string("    <line x1=\"" + Math.round(a[0] * 100) / 100 + "\" y1=\"" + Math.round(a[1] * 100) / 100 + "\" x2=\"" + Math.round(b[0] * 100) / 100 + "\" y2=\"" + Math.round(b[1] * 100) / 100 + "\" stroke=\"rgb(" + oi + "," + oi + "," + oi + ")\"/>\n");
			}
			++gid;
		}
		out_b += "  </g>\n";
	}
	out_b += "</svg>\n";
	return out_b;
};
var haxe_iterators_ArrayIterator = function(array) {
	this.current = 0;
	this.array = array;
};
haxe_iterators_ArrayIterator.__name__ = true;
haxe_iterators_ArrayIterator.prototype = {
	hasNext: function() {
		return this.current < this.array.length;
	}
	,next: function() {
		return this.array[this.current++];
	}
};
var js_Boot = function() { };
js_Boot.__name__ = true;
js_Boot.__string_rec = function(o,s) {
	if(o == null) {
		return "null";
	}
	if(s.length >= 5) {
		return "<...>";
	}
	var t = typeof(o);
	if(t == "function" && (o.__name__ || o.__ename__)) {
		t = "object";
	}
	switch(t) {
	case "function":
		return "<function>";
	case "object":
		if(((o) instanceof Array)) {
			var str = "[";
			s += "\t";
			var _g = 0;
			var _g1 = o.length;
			while(_g < _g1) {
				var i = _g++;
				str += (i > 0 ? "," : "") + js_Boot.__string_rec(o[i],s);
			}
			str += "]";
			return str;
		}
		var tostr;
		try {
			tostr = o.toString;
		} catch( _g ) {
			return "???";
		}
		if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
			var s2 = o.toString();
			if(s2 != "[object Object]") {
				return s2;
			}
		}
		var str = "{\n";
		s += "\t";
		var hasp = o.hasOwnProperty != null;
		var k = null;
		for( k in o ) {
		if(hasp && !o.hasOwnProperty(k)) {
			continue;
		}
		if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
			continue;
		}
		if(str.length != 2) {
			str += ", \n";
		}
		str += s + k + " : " + js_Boot.__string_rec(o[k],s);
		}
		s = s.substring(1);
		str += "\n" + s + "}";
		return str;
	case "string":
		return o;
	default:
		return String(o);
	}
};
if(typeof(performance) != "undefined" ? typeof(performance.now) == "function" : false) {
	HxOverrides.now = performance.now.bind(performance);
}
String.__name__ = true;
Array.__name__ = true;
js_Boot.__toStr = ({ }).toString;
})(typeof exports != "undefined" ? exports : typeof window != "undefined" ? window : typeof self != "undefined" ? self : this, {});
