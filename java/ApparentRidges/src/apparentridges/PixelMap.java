// Generated by Haxe 4.1.3
package apparentridges;

import haxe.root.*;

@SuppressWarnings(value={"rawtypes", "unchecked"})
public class PixelMap extends haxe.lang.HxObject
{
	public PixelMap(haxe.lang.EmptyObject empty)
	{
	}
	
	
	public PixelMap()
	{
		apparentridges.PixelMap.__hx_ctor_apparentridges_PixelMap(this);
	}
	
	
	protected static void __hx_ctor_apparentridges_PixelMap(apparentridges.PixelMap __hx_this)
	{
	}
	
	
	public static void raycast(apparentridges.Render render, haxe.lang.Function fun)
	{
		double min = java.lang.Double.POSITIVE_INFINITY;
		double max = java.lang.Double.NEGATIVE_INFINITY;
		int width = render.width;
		int height = render.height;
		int hw = ((int) (( ((double) (width) ) / 2 )) );
		int hh = ((int) (( ((double) (height) ) / 2 )) );
		{
			int _g =  - (hh) ;
			int _g1 = ( height - hh );
			while (( _g < _g1 ))
			{
				int y = _g++;
				{
					int _g2 =  - (hw) ;
					int _g3 = ( width - hw );
					while (( _g2 < _g3 ))
					{
						int x = _g2++;
						double r_tmin = 0.0;
						double r_tmax = 0.0;
						double[] r_o = null;
						double[] r_d = null;
						double[] this1 = new double[3];
						double[] this2 = ((double[]) (this1) );
						((double[]) (this2) )[0] = ((double) (0) );
						((double[]) (this2) )[1] = ((double) (0) );
						((double[]) (this2) )[2] = ((double) (0) );
						r_o = ((double[]) (this2) );
						double _z = render.focal;
						double[] this3 = new double[3];
						double[] this4 = ((double[]) (this3) );
						((double[]) (this4) )[0] = ((double) ( - (x) ) );
						((double[]) (this4) )[1] = ((double) ( - (y) ) );
						((double[]) (this4) )[2] = _z;
						r_d = ((double[]) (this4) );
						r_tmax = java.lang.Double.POSITIVE_INFINITY;
						r_tmin = ((double) (0) );
						{
							double[] this5 = r_d;
							double l = java.lang.Math.sqrt(( ( ( ((double[]) (this5) )[0] * ((double[]) (this5) )[0] ) + ( ((double[]) (this5) )[1] * ((double[]) (this5) )[1] ) ) + ( ((double[]) (this5) )[2] * ((double[]) (this5) )[2] ) ));
							if (( l > 0 )) 
							{
								l = ( 1 / l );
								((double[]) (this5) )[0] *= l;
								((double[]) (this5) )[1] *= l;
								((double[]) (this5) )[2] *= l;
							}
							else
							{
								((double[]) (this5) )[0] = ((double) (0) );
								((double[]) (this5) )[1] = ((double) (0) );
								((double[]) (this5) )[2] = ((double) (1) );
							}
							
						}
						
						apparentridges.BVHTree bvh = render.mesh.bvh;
						haxe.lang.Function[] hitNode = new haxe.lang.Function[]{null};
						hitNode[0] = new apparentridges.PixelMap_raycast_1691__Fun(r_tmin, r_tmax, r_o, r_d, hitNode, bvh);
						apparentridges.RayHit h = ((apparentridges.RayHit) (hitNode[0].__hx_invoke1_o(0.0, bvh.root)) );
						fun.__hx_invoke3_o(0.0, h, ((double) (( x + hh )) ), haxe.lang.Runtime.undefined, ((double) (( y + hh )) ), haxe.lang.Runtime.undefined);
					}
					
				}
				
			}
			
		}
		
	}
	
	
	public static double[] depth(apparentridges.Render render, java.lang.Object normalize)
	{
		boolean normalize1 = ( (haxe.lang.Runtime.eq(normalize, null)) ? (false) : (haxe.lang.Runtime.toBool(((java.lang.Boolean) (normalize) ))) );
		double[] this1 = new double[( render.width * render.height )];
		double[] data = ((double[]) (this1) );
		double[] min = new double[]{((double) (java.lang.Double.POSITIVE_INFINITY) )};
		double[] max = new double[]{((double) (java.lang.Double.NEGATIVE_INFINITY) )};
		apparentridges.PixelMap.raycast(render, new apparentridges.PixelMap_depth_1705__Fun(render, min, max, data));
		if (normalize1) 
		{
			int _g = 0;
			int _g1 = ((double[]) (data) ).length;
			while (( _g < _g1 ))
			{
				int i = _g++;
				if (( ((double[]) (data) )[i] != java.lang.Double.POSITIVE_INFINITY )) 
				{
					((double[]) (data) )[i] = ( 1 - ( (( ((double[]) (data) )[i] - min[0] )) / (( max[0] - min[0] )) ) );
				}
				else
				{
					((double[]) (data) )[i] = ((double) (0) );
				}
				
			}
			
		}
		
		return data;
	}
	
	
	public static double[] normal(apparentridges.Render render)
	{
		double[] this1 = new double[( ( render.width * render.height ) * 3 )];
		double[] data = ((double[]) (this1) );
		apparentridges.PixelMap.raycast(render, new apparentridges.PixelMap_normal_1730__Fun(render, data));
		return data;
	}
	
	
	public static double[] curvature(apparentridges.Render render)
	{
		double[] this1 = new double[( ( render.width * render.height ) * 2 )];
		double[] data = ((double[]) (this1) );
		apparentridges.PixelMap.raycast(render, new apparentridges.PixelMap_curvature_1755__Fun(render, data));
		return data;
	}
	
	
	public static double[] lambertian(apparentridges.Render render, double[] light, java.lang.Object normalize)
	{
		boolean normalize1 = ( (haxe.lang.Runtime.eq(normalize, null)) ? (true) : (haxe.lang.Runtime.toBool(((java.lang.Boolean) (normalize) ))) );
		double[] this1 = new double[( render.width * render.height )];
		double[] data = ((double[]) (this1) );
		double[] min = new double[]{((double) (java.lang.Double.POSITIVE_INFINITY) )};
		double[] max = new double[]{((double) (java.lang.Double.NEGATIVE_INFINITY) )};
		apparentridges.PixelMap.raycast(render, new apparentridges.PixelMap_lambertian_1783__Fun(render, min, max, light, data));
		if (normalize1) 
		{
			int _g = 0;
			int _g1 = ((double[]) (data) ).length;
			while (( _g < _g1 ))
			{
				int i = _g++;
				if (( ((double[]) (data) )[i] != java.lang.Double.NEGATIVE_INFINITY )) 
				{
					((double[]) (data) )[i] = ( (( ((double[]) (data) )[i] - min[0] )) / (( max[0] - min[0] )) );
				}
				else
				{
					((double[]) (data) )[i] = ((double) (0) );
				}
				
			}
			
		}
		
		return data;
	}
	
	
	public static double[] ambientOcclusion(apparentridges.Render render, java.lang.Object numSamples, java.lang.Object normalize)
	{
		boolean normalize1 = ( (haxe.lang.Runtime.eq(normalize, null)) ? (true) : (haxe.lang.Runtime.toBool(((java.lang.Boolean) (normalize) ))) );
		int numSamples1 = ( (haxe.lang.Runtime.eq(numSamples, null)) ? (32) : (((int) (haxe.lang.Runtime.toInt(numSamples)) )) );
		double[] this1 = new double[( render.width * render.height )];
		double[] data = ((double[]) (this1) );
		double[] min = new double[]{((double) (java.lang.Double.POSITIVE_INFINITY) )};
		double[] max = new double[]{((double) (java.lang.Double.NEGATIVE_INFINITY) )};
		apparentridges.PixelMap.raycast(render, new apparentridges.PixelMap_ambientOcclusion_1816__Fun(render, numSamples1, min, max, data));
		if (normalize1) 
		{
			int _g = 0;
			int _g1 = ((double[]) (data) ).length;
			while (( _g < _g1 ))
			{
				int i = _g++;
				if (( ((double[]) (data) )[i] != java.lang.Double.NEGATIVE_INFINITY )) 
				{
					((double[]) (data) )[i] = ( (( ((double[]) (data) )[i] - min[0] )) / (( max[0] - min[0] )) );
				}
				else
				{
					((double[]) (data) )[i] = ((double) (0) );
				}
				
			}
			
		}
		
		return data;
	}
	
	
	public static java.lang.String toPPMString(double[] data, int w, int h, double min, double max)
	{
		int chan = ((int) (( ((double) (((double[]) (data) ).length) ) / (( w * h )) )) );
		haxe.root.StringBuf out = new haxe.root.StringBuf();
		out.add(haxe.lang.Runtime.toString(( ( ( ( "P3\n" + w ) + " " ) + h ) + "\n255\n" )));
		java.lang.Object __temp_expr1 = ((java.lang.Object) (null) );
		{
			int _g = 0;
			int _g1 = ((int) (( ((double) (((double[]) (data) ).length) ) / chan )) );
			while (( _g < _g1 ))
			{
				int i = _g++;
				int u = ((int) (java.lang.Math.min(java.lang.Math.max(( ( (( ((double[]) (data) )[( i * chan )] - min )) / (( max - min )) ) * 255 ), ((double) (0) )), ((double) (255) ))) );
				int v = ( (( chan == 1 )) ? (u) : (((int) (java.lang.Math.min(java.lang.Math.max(( ( (( ((double[]) (data) )[( ( i * chan ) + 1 )] - min )) / (( max - min )) ) * 255 ), ((double) (0) )), ((double) (255) ))) )) );
				int w1 = ( (( chan == 1 )) ? (u) : (( (( chan == 2 )) ? (128) : (((int) (java.lang.Math.min(java.lang.Math.max(( ( (( ((double[]) (data) )[( ( i * chan ) + 2 )] - min )) / (( max - min )) ) * 255 ), ((double) (0) )), ((double) (255) ))) )) )) );
				out.add(haxe.lang.Runtime.toString(( ( ( ( ( ( "" + u ) + " " ) + v ) + " " ) + w1 ) + " " )));
				java.lang.Object __temp_expr2 = ((java.lang.Object) (null) );
			}
			
		}
		
		return out.toString();
	}
	
	
}


