// Generated by Haxe 4.1.3
package apparentridges;

import haxe.root.*;

@SuppressWarnings(value={"rawtypes", "unchecked"})
public class PixelMap_ambientOcclusion_1816__Fun extends haxe.lang.Function
{
	public PixelMap_ambientOcclusion_1816__Fun(apparentridges.Render render, int numSamples1, double[] min, double[] max, double[] data)
	{
		super(3, 0);
		this.render = render;
		this.numSamples1 = numSamples1;
		this.min = min;
		this.max = max;
		this.data = data;
	}
	
	
	@Override public java.lang.Object __hx_invoke3_o(double __fn_float1, java.lang.Object __fn_dyn1, double __fn_float2, java.lang.Object __fn_dyn2, double __fn_float3, java.lang.Object __fn_dyn3)
	{
		int y = ( (( __fn_dyn3 == haxe.lang.Runtime.undefined )) ? (((int) (__fn_float3) )) : (((int) (haxe.lang.Runtime.toInt(__fn_dyn3)) )) );
		int x = ( (( __fn_dyn2 == haxe.lang.Runtime.undefined )) ? (((int) (__fn_float2) )) : (((int) (haxe.lang.Runtime.toInt(__fn_dyn2)) )) );
		apparentridges.RayHit h = ( (( __fn_dyn1 == haxe.lang.Runtime.undefined )) ? (((apparentridges.RayHit) (((java.lang.Object) (__fn_float1) )) )) : (((apparentridges.RayHit) (__fn_dyn1) )) );
		int idx = ( ( y * this.render.width ) + x );
		if (( h == null )) 
		{
			((double[]) (this.data) )[idx] = java.lang.Double.NEGATIVE_INFINITY;
		}
		else
		{
			int[] f = h.face;
			double[] p0 = this.render.mesh.vertices.__get(((int[]) (f) )[0]);
			double[] p1 = this.render.mesh.vertices.__get(((int[]) (f) )[1]);
			double[] p2 = this.render.mesh.vertices.__get(((int[]) (f) )[2]);
			double rhs = ( ( 1 - h.u ) - h.v );
			double[] this1 = new double[3];
			double[] this2 = ((double[]) (this1) );
			((double[]) (this2) )[0] = ( ((double[]) (p0) )[0] * rhs );
			((double[]) (this2) )[1] = ( ((double[]) (p0) )[1] * rhs );
			((double[]) (this2) )[2] = ( ((double[]) (p0) )[2] * rhs );
			double[] this3 = ((double[]) (this2) );
			double rhs1 = h.u;
			double[] this4 = new double[3];
			double[] this5 = ((double[]) (this4) );
			((double[]) (this5) )[0] = ( ((double[]) (p1) )[0] * rhs1 );
			((double[]) (this5) )[1] = ( ((double[]) (p1) )[1] * rhs1 );
			((double[]) (this5) )[2] = ( ((double[]) (p1) )[2] * rhs1 );
			double[] rhs2 = ((double[]) (this5) );
			double[] this6 = new double[3];
			double[] this7 = ((double[]) (this6) );
			((double[]) (this7) )[0] = ( ((double[]) (this3) )[0] + ((double[]) (rhs2) )[0] );
			((double[]) (this7) )[1] = ( ((double[]) (this3) )[1] + ((double[]) (rhs2) )[1] );
			((double[]) (this7) )[2] = ( ((double[]) (this3) )[2] + ((double[]) (rhs2) )[2] );
			double[] this8 = ((double[]) (this7) );
			double rhs3 = h.v;
			double[] this9 = new double[3];
			double[] this10 = ((double[]) (this9) );
			((double[]) (this10) )[0] = ( ((double[]) (p2) )[0] * rhs3 );
			((double[]) (this10) )[1] = ( ((double[]) (p2) )[1] * rhs3 );
			((double[]) (this10) )[2] = ( ((double[]) (p2) )[2] * rhs3 );
			double[] rhs4 = ((double[]) (this10) );
			double[] this11 = new double[3];
			double[] this12 = ((double[]) (this11) );
			((double[]) (this12) )[0] = ( ((double[]) (this8) )[0] + ((double[]) (rhs4) )[0] );
			((double[]) (this12) )[1] = ( ((double[]) (this8) )[1] + ((double[]) (rhs4) )[1] );
			((double[]) (this12) )[2] = ( ((double[]) (this8) )[2] + ((double[]) (rhs4) )[2] );
			double[] o = ((double[]) (this12) );
			int cnt = 0;
			{
				int _g = 0;
				int _g1 = this.numSamples1;
				while (( _g < _g1 ))
				{
					int i = _g++;
					double Xi1 = java.lang.Math.random();
					double Xi2 = java.lang.Math.random();
					double theta = java.lang.Math.acos(Xi1);
					double phi = ( ( 2 * java.lang.Math.PI ) * Xi2 );
					double xs = ( java.lang.Math.sin(theta) * java.lang.Math.cos(phi) );
					double ys = ( java.lang.Math.sin(theta) * java.lang.Math.sin(phi) );
					double zs = java.lang.Math.cos(theta);
					double[] this13 = new double[3];
					double[] this14 = ((double[]) (this13) );
					((double[]) (this14) )[0] = xs;
					((double[]) (this14) )[1] = ys;
					((double[]) (this14) )[2] = zs;
					double[] v = ((double[]) (this14) );
					double[] d = v;
					if (( java.lang.Math.random() < 0.5 )) 
					{
						((double[]) (d) )[2] =  - (((double[]) (d) )[2]) ;
					}
					
					double r_tmin = 0.0;
					double r_tmax = 0.0;
					double[] r_o = null;
					double[] r_d = d;
					r_o = o;
					r_tmin = 0.1;
					r_tmax = java.lang.Double.POSITIVE_INFINITY;
					apparentridges.BVHTree bvh = this.render.mesh.bvh;
					haxe.lang.Function[] hitNode = new haxe.lang.Function[]{null};
					hitNode[0] = new apparentridges.PixelMap_ambientOcclusion_1839__Fun(r_tmin, r_tmax, r_o, r_d, hitNode, bvh);
					apparentridges.RayHit h1 = ((apparentridges.RayHit) (hitNode[0].__hx_invoke1_o(0.0, bvh.root)) );
					if (( h1 != null )) 
					{
						 ++ cnt;
					}
					
				}
				
			}
			
			double v1 = ( 1 - ( ((double) (cnt) ) / this.numSamples1 ) );
			this.min[0] = java.lang.Math.min(this.min[0], v1);
			this.max[0] = java.lang.Math.max(this.max[0], v1);
			((double[]) (this.data) )[idx] = v1;
		}
		
		return null;
	}
	
	
	public apparentridges.Render render;
	
	public int numSamples1;
	
	public double[] min;
	
	public double[] max;
	
	public double[] data;
	
}


