# Generated by Haxe 4.1.3
# coding: utf-8
import sys

import math as python_lib_Math
import math as Math
import inspect as python_lib_Inspect
import sys as python_lib_Sys
import builtins as python_lib_Builtins
import functools as python_lib_Functools
import random as python_lib_Random
import traceback as python_lib_Traceback
from io import StringIO as python_lib_io_StringIO


class _hx_AnonObject:
    _hx_disable_getattr = False
    def __init__(self, fields):
        self.__dict__ = fields
    def __repr__(self):
        return repr(self.__dict__)
    def __contains__(self, item):
        return item in self.__dict__
    def __getitem__(self, item):
        return self.__dict__[item]
    def __getattr__(self, name):
        if (self._hx_disable_getattr):
            raise AttributeError('field does not exist')
        else:
            return None
    def _hx_hasattr(self,field):
        self._hx_disable_getattr = True
        try:
            getattr(self, field)
            self._hx_disable_getattr = False
            return True
        except AttributeError:
            self._hx_disable_getattr = False
            return False



class Enum:
    _hx_class_name = "Enum"
    __slots__ = ("tag", "index", "params")
    _hx_fields = ["tag", "index", "params"]
    _hx_methods = ["__str__"]

    def __init__(self,tag,index,params):
        self.tag = tag
        self.index = index
        self.params = params

    def __str__(self):
        if (self.params is None):
            return self.tag
        else:
            return self.tag + '(' + (', '.join(str(v) for v in self.params)) + ')'



class Class: pass


class Reflect:
    _hx_class_name = "Reflect"
    __slots__ = ()
    _hx_statics = ["field"]

    @staticmethod
    def field(o,field):
        return python_Boot.field(o,field)


class Std:
    _hx_class_name = "Std"
    __slots__ = ()
    _hx_statics = ["isOfType", "string", "parseInt", "shortenPossibleNumber", "parseFloat"]

    @staticmethod
    def isOfType(v,t):
        if ((v is None) and ((t is None))):
            return False
        if (t is None):
            return False
        if (t == Dynamic):
            return (v is not None)
        isBool = isinstance(v,bool)
        if ((t == Bool) and isBool):
            return True
        if ((((not isBool) and (not (t == Bool))) and (t == Int)) and isinstance(v,int)):
            return True
        vIsFloat = isinstance(v,float)
        tmp = None
        tmp1 = None
        if (((not isBool) and vIsFloat) and (t == Int)):
            f = v
            tmp1 = (((f != Math.POSITIVE_INFINITY) and ((f != Math.NEGATIVE_INFINITY))) and (not python_lib_Math.isnan(f)))
        else:
            tmp1 = False
        if tmp1:
            tmp1 = None
            try:
                tmp1 = int(v)
            except BaseException as _g:
                None
                tmp1 = None
            tmp = (v == tmp1)
        else:
            tmp = False
        if ((tmp and ((v <= 2147483647))) and ((v >= -2147483648))):
            return True
        if (((not isBool) and (t == Float)) and isinstance(v,(float, int))):
            return True
        if (t == str):
            return isinstance(v,str)
        isEnumType = (t == Enum)
        if ((isEnumType and python_lib_Inspect.isclass(v)) and hasattr(v,"_hx_constructs")):
            return True
        if isEnumType:
            return False
        isClassType = (t == Class)
        if ((((isClassType and (not isinstance(v,Enum))) and python_lib_Inspect.isclass(v)) and hasattr(v,"_hx_class_name")) and (not hasattr(v,"_hx_constructs"))):
            return True
        if isClassType:
            return False
        tmp = None
        try:
            tmp = isinstance(v,t)
        except BaseException as _g:
            None
            tmp = False
        if tmp:
            return True
        if python_lib_Inspect.isclass(t):
            cls = t
            loop = None
            def _hx_local_1(intf):
                f = (intf._hx_interfaces if (hasattr(intf,"_hx_interfaces")) else [])
                if (f is not None):
                    _g = 0
                    while (_g < len(f)):
                        i = (f[_g] if _g >= 0 and _g < len(f) else None)
                        _g = (_g + 1)
                        if (i == cls):
                            return True
                        else:
                            l = loop(i)
                            if l:
                                return True
                    return False
                else:
                    return False
            loop = _hx_local_1
            currentClass = v.__class__
            result = False
            while (currentClass is not None):
                if loop(currentClass):
                    result = True
                    break
                currentClass = python_Boot.getSuperClass(currentClass)
            return result
        else:
            return False

    @staticmethod
    def string(s):
        return python_Boot.toString1(s,"")

    @staticmethod
    def parseInt(x):
        if (x is None):
            return None
        try:
            return int(x)
        except BaseException as _g:
            None
            base = 10
            _hx_len = len(x)
            foundCount = 0
            sign = 0
            firstDigitIndex = 0
            lastDigitIndex = -1
            previous = 0
            _g = 0
            _g1 = _hx_len
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                c = (-1 if ((i >= len(x))) else ord(x[i]))
                if (((c > 8) and ((c < 14))) or ((c == 32))):
                    if (foundCount > 0):
                        return None
                    continue
                else:
                    c1 = c
                    if (c1 == 43):
                        if (foundCount == 0):
                            sign = 1
                        elif (not (((48 <= c) and ((c <= 57))))):
                            if (not (((base == 16) and ((((97 <= c) and ((c <= 122))) or (((65 <= c) and ((c <= 90))))))))):
                                break
                    elif (c1 == 45):
                        if (foundCount == 0):
                            sign = -1
                        elif (not (((48 <= c) and ((c <= 57))))):
                            if (not (((base == 16) and ((((97 <= c) and ((c <= 122))) or (((65 <= c) and ((c <= 90))))))))):
                                break
                    elif (c1 == 48):
                        if (not (((foundCount == 0) or (((foundCount == 1) and ((sign != 0))))))):
                            if (not (((48 <= c) and ((c <= 57))))):
                                if (not (((base == 16) and ((((97 <= c) and ((c <= 122))) or (((65 <= c) and ((c <= 90))))))))):
                                    break
                    elif ((c1 == 120) or ((c1 == 88))):
                        if ((previous == 48) and ((((foundCount == 1) and ((sign == 0))) or (((foundCount == 2) and ((sign != 0))))))):
                            base = 16
                        elif (not (((48 <= c) and ((c <= 57))))):
                            if (not (((base == 16) and ((((97 <= c) and ((c <= 122))) or (((65 <= c) and ((c <= 90))))))))):
                                break
                    elif (not (((48 <= c) and ((c <= 57))))):
                        if (not (((base == 16) and ((((97 <= c) and ((c <= 122))) or (((65 <= c) and ((c <= 90))))))))):
                            break
                if (((foundCount == 0) and ((sign == 0))) or (((foundCount == 1) and ((sign != 0))))):
                    firstDigitIndex = i
                foundCount = (foundCount + 1)
                lastDigitIndex = i
                previous = c
            if (firstDigitIndex <= lastDigitIndex):
                digits = HxString.substring(x,firstDigitIndex,(lastDigitIndex + 1))
                try:
                    return (((-1 if ((sign == -1)) else 1)) * int(digits,base))
                except BaseException as _g:
                    return None
            return None

    @staticmethod
    def shortenPossibleNumber(x):
        r = ""
        _g = 0
        _g1 = len(x)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            c = ("" if (((i < 0) or ((i >= len(x))))) else x[i])
            _g2 = HxString.charCodeAt(c,0)
            if (_g2 is None):
                break
            else:
                _g3 = _g2
                if (((((((((((_g3 == 57) or ((_g3 == 56))) or ((_g3 == 55))) or ((_g3 == 54))) or ((_g3 == 53))) or ((_g3 == 52))) or ((_g3 == 51))) or ((_g3 == 50))) or ((_g3 == 49))) or ((_g3 == 48))) or ((_g3 == 46))):
                    r = (("null" if r is None else r) + ("null" if c is None else c))
                else:
                    break
        return r

    @staticmethod
    def parseFloat(x):
        try:
            return float(x)
        except BaseException as _g:
            None
            if (x is not None):
                r1 = Std.shortenPossibleNumber(x)
                if (r1 != x):
                    return Std.parseFloat(r1)
            return Math.NaN


class Float: pass


class Int: pass


class Bool: pass


class Dynamic: pass


class StringTools:
    _hx_class_name = "StringTools"
    __slots__ = ()
    _hx_statics = ["isSpace", "ltrim", "rtrim", "trim"]

    @staticmethod
    def isSpace(s,pos):
        if (((len(s) == 0) or ((pos < 0))) or ((pos >= len(s)))):
            return False
        c = HxString.charCodeAt(s,pos)
        if (not (((c > 8) and ((c < 14))))):
            return (c == 32)
        else:
            return True

    @staticmethod
    def ltrim(s):
        l = len(s)
        r = 0
        while ((r < l) and StringTools.isSpace(s,r)):
            r = (r + 1)
        if (r > 0):
            return HxString.substr(s,r,(l - r))
        else:
            return s

    @staticmethod
    def rtrim(s):
        l = len(s)
        r = 0
        while ((r < l) and StringTools.isSpace(s,((l - r) - 1))):
            r = (r + 1)
        if (r > 0):
            return HxString.substr(s,0,(l - r))
        else:
            return s

    @staticmethod
    def trim(s):
        return StringTools.ltrim(StringTools.rtrim(s))


class python_HaxeIterator:
    _hx_class_name = "python.HaxeIterator"
    __slots__ = ("it", "x", "has", "checked")
    _hx_fields = ["it", "x", "has", "checked"]
    _hx_methods = ["next", "hasNext"]

    def __init__(self,it):
        self.checked = False
        self.has = False
        self.x = None
        self.it = it

    def next(self):
        if (not self.checked):
            self.hasNext()
        self.checked = False
        return self.x

    def hasNext(self):
        if (not self.checked):
            try:
                self.x = self.it.__next__()
                self.has = True
            except BaseException as _g:
                None
                if Std.isOfType(haxe_Exception.caught(_g).unwrap(),StopIteration):
                    self.has = False
                    self.x = None
                else:
                    raise _g
            self.checked = True
        return self.has



class apparentridges_Util:
    _hx_class_name = "apparentridges.Util"
    __slots__ = ()
    _hx_statics = ["rndInt", "min", "sq", "nextMod3", "prevMod3", "trinorm", "ldltdc", "ldltsl", "largestEig2x2", "matIden", "matRotx", "matRoty", "matRotz", "matTrsl", "matScal", "matMult", "matTrfm", "matProj", "uniformHemisphereSampler", "writeFile"]

    @staticmethod
    def rndInt(x):
        x1 = Math.floor((x + 0.5))
        try:
            return int(x1)
        except BaseException as _g:
            None
            return None

    @staticmethod
    def min(a,b):
        if (a > b):
            return b
        else:
            return a

    @staticmethod
    def sq(x):
        return (x * x)

    @staticmethod
    def nextMod3(i):
        if (i < 2):
            return (i + 1)
        else:
            return (i - 2)

    @staticmethod
    def prevMod3(i):
        if (i > 0):
            return (i - 1)
        else:
            return (i + 2)

    @staticmethod
    def trinorm(v0,v1,v2):
        _x = (v1[0] - v0[0])
        _y = (v1[1] - v0[1])
        _z = (v1[2] - v0[2])
        this1 = [None]*3
        this2 = this1
        this2[0] = _x
        this2[1] = _y
        this2[2] = _z
        v1 = this2
        _x = (v2[0] - v0[0])
        _y = (v2[1] - v0[1])
        _z = (v2[2] - v0[2])
        this1 = [None]*3
        this2 = this1
        this2[0] = _x
        this2[1] = _y
        this2[2] = _z
        v2 = this2
        _x = ((v1[1] * v2[2]) - ((v1[2] * v2[1])))
        _y = ((v1[2] * v2[0]) - ((v1[0] * v2[2])))
        _z = ((v1[0] * v2[1]) - ((v1[1] * v2[0])))
        this1 = [None]*3
        this2 = this1
        this2[0] = _x
        this2[1] = _y
        this2[2] = _z
        this1 = this2
        _x = (this1[0] * 0.5)
        _y = (this1[1] * 0.5)
        _z = (this1[2] * 0.5)
        this1 = [None]*3
        this2 = this1
        this2[0] = _x
        this2[1] = _y
        this2[2] = _z
        return this2

    @staticmethod
    def ldltdc(A,rdiag):
        N = len(rdiag)
        if (N < 1):
            return False
        elif (N <= 3):
            d0 = python_internal_ArrayImpl._get((A[0] if 0 < len(A) else None), 0)
            python_internal_ArrayImpl._set(rdiag, 0, (1 / d0))
            if (N == 1):
                return (d0 != 0)
            python_internal_ArrayImpl._set((A[1] if 1 < len(A) else None), 0, python_internal_ArrayImpl._get((A[0] if 0 < len(A) else None), 1))
            l10 = ((rdiag[0] if 0 < len(rdiag) else None) * python_internal_ArrayImpl._get((A[1] if 1 < len(A) else None), 0))
            d1 = (python_internal_ArrayImpl._get((A[1] if 1 < len(A) else None), 1) - ((l10 * python_internal_ArrayImpl._get((A[1] if 1 < len(A) else None), 0))))
            python_internal_ArrayImpl._set(rdiag, 1, (1 / d1))
            if (N == 2):
                if (d0 != 0):
                    return (d1 != 0)
                else:
                    return False
            x = python_internal_ArrayImpl._get((A[2] if 2 < len(A) else None), 0)
            x1 = python_internal_ArrayImpl._get((A[2] if 2 < len(A) else None), 1)
            d2 = ((python_internal_ArrayImpl._get((A[2] if 2 < len(A) else None), 2) - (((rdiag[0] if 0 < len(rdiag) else None) * ((x * x))))) - (((rdiag[1] if 1 < len(rdiag) else None) * ((x1 * x1)))))
            python_internal_ArrayImpl._set(rdiag, 2, (1 / d2))
            python_internal_ArrayImpl._set((A[2] if 2 < len(A) else None), 0, python_internal_ArrayImpl._get((A[0] if 0 < len(A) else None), 2))
            python_internal_ArrayImpl._set((A[2] if 2 < len(A) else None), 1, (python_internal_ArrayImpl._get((A[1] if 1 < len(A) else None), 2) - ((l10 * python_internal_ArrayImpl._get((A[2] if 2 < len(A) else None), 0)))))
            if ((d0 != 0) and ((d1 != 0))):
                return (d2 != 0)
            else:
                return False
        v = []
        _g = 0
        _g1 = N
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            _g2 = 0
            _g3 = i
            while (_g2 < _g3):
                k = _g2
                _g2 = (_g2 + 1)
                python_internal_ArrayImpl._set(v, k, (python_internal_ArrayImpl._get((A[i] if i >= 0 and i < len(A) else None), k) * (rdiag[k] if k >= 0 and k < len(rdiag) else None)))
            _g4 = i
            _g5 = N
            while (_g4 < _g5):
                j = _g4
                _g4 = (_g4 + 1)
                sum = python_internal_ArrayImpl._get((A[i] if i >= 0 and i < len(A) else None), j)
                _g6 = 0
                _g7 = i
                while (_g6 < _g7):
                    k1 = _g6
                    _g6 = (_g6 + 1)
                    sum = (sum - (((v[k1] if k1 >= 0 and k1 < len(v) else None) * python_internal_ArrayImpl._get((A[j] if j >= 0 and j < len(A) else None), k1))))
                if (i == j):
                    if (sum == 0):
                        return False
                    python_internal_ArrayImpl._set(rdiag, i, (1 / sum))
                else:
                    python_internal_ArrayImpl._set((A[j] if j >= 0 and j < len(A) else None), i, sum)
        return True

    @staticmethod
    def ldltsl(A,rdiag,b,x):
        N = len(rdiag)
        _g = 0
        _g1 = N
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            sum = (b[i] if i >= 0 and i < len(b) else None)
            _g2 = 0
            _g3 = i
            while (_g2 < _g3):
                k = _g2
                _g2 = (_g2 + 1)
                sum = (sum - ((python_internal_ArrayImpl._get((A[i] if i >= 0 and i < len(A) else None), k) * (x[k] if k >= 0 and k < len(x) else None))))
            python_internal_ArrayImpl._set(x, i, (sum * (rdiag[i] if i >= 0 and i < len(rdiag) else None)))
        _g = 0
        _g1 = N
        while (_g < _g1):
            _i = _g
            _g = (_g + 1)
            i = ((N - _i) - 1)
            sum = 0
            _g2 = (i + 1)
            _g3 = N
            while (_g2 < _g3):
                k = _g2
                _g2 = (_g2 + 1)
                sum = (sum + ((python_internal_ArrayImpl._get((A[k] if k >= 0 and k < len(A) else None), i) * (x[k] if k >= 0 and k < len(x) else None))))
            python_internal_ArrayImpl._set(x, i, ((x[i] if i >= 0 and i < len(x) else None) - ((sum * (rdiag[i] if i >= 0 and i < len(rdiag) else None)))))

    @staticmethod
    def largestEig2x2(m1,m12,m2):
        l1 = (0.5 * ((m1 + m2)))
        if (l1 > 0.0):
            x = (m2 - m1)
            v = ((m12 * m12) + ((0.25 * ((x * x)))))
            l1 = (l1 + (Math.NaN if ((v < 0)) else python_lib_Math.sqrt(v)))
        else:
            x = (m2 - m1)
            v = ((m12 * m12) + ((0.25 * ((x * x)))))
            l1 = (l1 - (Math.NaN if ((v < 0)) else python_lib_Math.sqrt(v)))
        _x = (m2 - l1)
        _y = -m12
        this1 = [None]*3
        this2 = this1
        this2[0] = _x
        this2[1] = _y
        this2[2] = 0
        e1 = this2
        v = (((e1[0] * e1[0]) + ((e1[1] * e1[1]))) + ((e1[2] * e1[2])))
        l = (Math.NaN if ((v < 0)) else python_lib_Math.sqrt(v))
        if (l > 0):
            l = (1 / l)
            _g = e1
            v = (_g[0] * l)
            _g[0] = v
            _g = e1
            v = (_g[1] * l)
            _g[1] = v
            _g = e1
            v = (_g[2] * l)
            _g[2] = v
        else:
            e1[0] = 0
            e1[1] = 0
            e1[2] = 1
        e1[2] = l1
        return e1

    @staticmethod
    def matIden():
        return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]

    @staticmethod
    def matRotx(a):
        return [1, 0, 0, 0, 0, (Math.NaN if (((a == Math.POSITIVE_INFINITY) or ((a == Math.NEGATIVE_INFINITY)))) else python_lib_Math.cos(a)), -((Math.NaN if (((a == Math.POSITIVE_INFINITY) or ((a == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(a))), 0, 0, (Math.NaN if (((a == Math.POSITIVE_INFINITY) or ((a == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(a)), (Math.NaN if (((a == Math.POSITIVE_INFINITY) or ((a == Math.NEGATIVE_INFINITY)))) else python_lib_Math.cos(a)), 0, 0, 0, 0, 1]

    @staticmethod
    def matRoty(a):
        return [(Math.NaN if (((a == Math.POSITIVE_INFINITY) or ((a == Math.NEGATIVE_INFINITY)))) else python_lib_Math.cos(a)), 0, (Math.NaN if (((a == Math.POSITIVE_INFINITY) or ((a == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(a)), 0, 0, 1, 0, 0, -((Math.NaN if (((a == Math.POSITIVE_INFINITY) or ((a == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(a))), 0, (Math.NaN if (((a == Math.POSITIVE_INFINITY) or ((a == Math.NEGATIVE_INFINITY)))) else python_lib_Math.cos(a)), 0, 0, 0, 0, 1]

    @staticmethod
    def matRotz(a):
        return [(Math.NaN if (((a == Math.POSITIVE_INFINITY) or ((a == Math.NEGATIVE_INFINITY)))) else python_lib_Math.cos(a)), -((Math.NaN if (((a == Math.POSITIVE_INFINITY) or ((a == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(a))), 0, 0, (Math.NaN if (((a == Math.POSITIVE_INFINITY) or ((a == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(a)), (Math.NaN if (((a == Math.POSITIVE_INFINITY) or ((a == Math.NEGATIVE_INFINITY)))) else python_lib_Math.cos(a)), 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]

    @staticmethod
    def matTrsl(x,y,z):
        return [1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1]

    @staticmethod
    def matScal(x,y,z):
        return [x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1]

    @staticmethod
    def matMult(A,B):
        return [(((((A[0] if 0 < len(A) else None) * (B[0] if 0 < len(B) else None)) + (((A[1] if 1 < len(A) else None) * (B[4] if 4 < len(B) else None)))) + (((A[2] if 2 < len(A) else None) * (B[8] if 8 < len(B) else None)))) + (((A[3] if 3 < len(A) else None) * (B[12] if 12 < len(B) else None)))), (((((A[0] if 0 < len(A) else None) * (B[1] if 1 < len(B) else None)) + (((A[1] if 1 < len(A) else None) * (B[5] if 5 < len(B) else None)))) + (((A[2] if 2 < len(A) else None) * (B[9] if 9 < len(B) else None)))) + (((A[3] if 3 < len(A) else None) * (B[13] if 13 < len(B) else None)))), (((((A[0] if 0 < len(A) else None) * (B[2] if 2 < len(B) else None)) + (((A[1] if 1 < len(A) else None) * (B[6] if 6 < len(B) else None)))) + (((A[2] if 2 < len(A) else None) * (B[10] if 10 < len(B) else None)))) + (((A[3] if 3 < len(A) else None) * (B[14] if 14 < len(B) else None)))), (((((A[0] if 0 < len(A) else None) * (B[3] if 3 < len(B) else None)) + (((A[1] if 1 < len(A) else None) * (B[7] if 7 < len(B) else None)))) + (((A[2] if 2 < len(A) else None) * (B[11] if 11 < len(B) else None)))) + (((A[3] if 3 < len(A) else None) * (B[15] if 15 < len(B) else None)))), (((((A[4] if 4 < len(A) else None) * (B[0] if 0 < len(B) else None)) + (((A[5] if 5 < len(A) else None) * (B[4] if 4 < len(B) else None)))) + (((A[6] if 6 < len(A) else None) * (B[8] if 8 < len(B) else None)))) + (((A[7] if 7 < len(A) else None) * (B[12] if 12 < len(B) else None)))), (((((A[4] if 4 < len(A) else None) * (B[1] if 1 < len(B) else None)) + (((A[5] if 5 < len(A) else None) * (B[5] if 5 < len(B) else None)))) + (((A[6] if 6 < len(A) else None) * (B[9] if 9 < len(B) else None)))) + (((A[7] if 7 < len(A) else None) * (B[13] if 13 < len(B) else None)))), (((((A[4] if 4 < len(A) else None) * (B[2] if 2 < len(B) else None)) + (((A[5] if 5 < len(A) else None) * (B[6] if 6 < len(B) else None)))) + (((A[6] if 6 < len(A) else None) * (B[10] if 10 < len(B) else None)))) + (((A[7] if 7 < len(A) else None) * (B[14] if 14 < len(B) else None)))), (((((A[4] if 4 < len(A) else None) * (B[3] if 3 < len(B) else None)) + (((A[5] if 5 < len(A) else None) * (B[7] if 7 < len(B) else None)))) + (((A[6] if 6 < len(A) else None) * (B[11] if 11 < len(B) else None)))) + (((A[7] if 7 < len(A) else None) * (B[15] if 15 < len(B) else None)))), (((((A[8] if 8 < len(A) else None) * (B[0] if 0 < len(B) else None)) + (((A[9] if 9 < len(A) else None) * (B[4] if 4 < len(B) else None)))) + (((A[10] if 10 < len(A) else None) * (B[8] if 8 < len(B) else None)))) + (((A[11] if 11 < len(A) else None) * (B[12] if 12 < len(B) else None)))), (((((A[8] if 8 < len(A) else None) * (B[1] if 1 < len(B) else None)) + (((A[9] if 9 < len(A) else None) * (B[5] if 5 < len(B) else None)))) + (((A[10] if 10 < len(A) else None) * (B[9] if 9 < len(B) else None)))) + (((A[11] if 11 < len(A) else None) * (B[13] if 13 < len(B) else None)))), (((((A[8] if 8 < len(A) else None) * (B[2] if 2 < len(B) else None)) + (((A[9] if 9 < len(A) else None) * (B[6] if 6 < len(B) else None)))) + (((A[10] if 10 < len(A) else None) * (B[10] if 10 < len(B) else None)))) + (((A[11] if 11 < len(A) else None) * (B[14] if 14 < len(B) else None)))), (((((A[8] if 8 < len(A) else None) * (B[3] if 3 < len(B) else None)) + (((A[9] if 9 < len(A) else None) * (B[7] if 7 < len(B) else None)))) + (((A[10] if 10 < len(A) else None) * (B[11] if 11 < len(B) else None)))) + (((A[11] if 11 < len(A) else None) * (B[15] if 15 < len(B) else None)))), (((((A[12] if 12 < len(A) else None) * (B[0] if 0 < len(B) else None)) + (((A[13] if 13 < len(A) else None) * (B[4] if 4 < len(B) else None)))) + (((A[14] if 14 < len(A) else None) * (B[8] if 8 < len(B) else None)))) + (((A[15] if 15 < len(A) else None) * (B[12] if 12 < len(B) else None)))), (((((A[12] if 12 < len(A) else None) * (B[1] if 1 < len(B) else None)) + (((A[13] if 13 < len(A) else None) * (B[5] if 5 < len(B) else None)))) + (((A[14] if 14 < len(A) else None) * (B[9] if 9 < len(B) else None)))) + (((A[15] if 15 < len(A) else None) * (B[13] if 13 < len(B) else None)))), (((((A[12] if 12 < len(A) else None) * (B[2] if 2 < len(B) else None)) + (((A[13] if 13 < len(A) else None) * (B[6] if 6 < len(B) else None)))) + (((A[14] if 14 < len(A) else None) * (B[10] if 10 < len(B) else None)))) + (((A[15] if 15 < len(A) else None) * (B[14] if 14 < len(B) else None)))), (((((A[12] if 12 < len(A) else None) * (B[3] if 3 < len(B) else None)) + (((A[13] if 13 < len(A) else None) * (B[7] if 7 < len(B) else None)))) + (((A[14] if 14 < len(A) else None) * (B[11] if 11 < len(B) else None)))) + (((A[15] if 15 < len(A) else None) * (B[15] if 15 < len(B) else None))))]

    @staticmethod
    def matTrfm(A,v):
        _x = (((((((A[0] if 0 < len(A) else None) * v[0]) + (((A[1] if 1 < len(A) else None) * v[1]))) + (((A[2] if 2 < len(A) else None) * v[2]))) + (A[3] if 3 < len(A) else None))) / ((((((A[12] if 12 < len(A) else None) * v[0]) + (((A[13] if 13 < len(A) else None) * v[1]))) + (((A[14] if 14 < len(A) else None) * v[2]))) + (A[15] if 15 < len(A) else None))))
        _y = (((((((A[4] if 4 < len(A) else None) * v[0]) + (((A[5] if 5 < len(A) else None) * v[1]))) + (((A[6] if 6 < len(A) else None) * v[2]))) + (A[7] if 7 < len(A) else None))) / ((((((A[12] if 12 < len(A) else None) * v[0]) + (((A[13] if 13 < len(A) else None) * v[1]))) + (((A[14] if 14 < len(A) else None) * v[2]))) + (A[15] if 15 < len(A) else None))))
        _z = (((((((A[8] if 8 < len(A) else None) * v[0]) + (((A[9] if 9 < len(A) else None) * v[1]))) + (((A[10] if 10 < len(A) else None) * v[2]))) + (A[11] if 11 < len(A) else None))) / ((((((A[12] if 12 < len(A) else None) * v[0]) + (((A[13] if 13 < len(A) else None) * v[1]))) + (((A[14] if 14 < len(A) else None) * v[2]))) + (A[15] if 15 < len(A) else None))))
        this1 = [None]*3
        this2 = this1
        this2[0] = _x
        this2[1] = _y
        this2[2] = _z
        return this2

    @staticmethod
    def matProj(f,v):
        _x = ((f * v[0]) / v[2])
        _y = ((f * v[1]) / v[2])
        this1 = [None]*3
        this2 = this1
        this2[0] = _x
        this2[1] = _y
        this2[2] = 0
        return this2

    @staticmethod
    def uniformHemisphereSampler():
        Xi1 = python_lib_Random.random()
        Xi2 = python_lib_Random.random()
        theta = Math.acos(Xi1)
        phi = ((2 * Math.PI) * Xi2)
        xs = (((Math.NaN if (((theta == Math.POSITIVE_INFINITY) or ((theta == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(theta))) * ((Math.NaN if (((phi == Math.POSITIVE_INFINITY) or ((phi == Math.NEGATIVE_INFINITY)))) else python_lib_Math.cos(phi))))
        ys = (((Math.NaN if (((theta == Math.POSITIVE_INFINITY) or ((theta == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(theta))) * ((Math.NaN if (((phi == Math.POSITIVE_INFINITY) or ((phi == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(phi))))
        zs = (Math.NaN if (((theta == Math.POSITIVE_INFINITY) or ((theta == Math.NEGATIVE_INFINITY)))) else python_lib_Math.cos(theta))
        this1 = [None]*3
        this2 = this1
        this2[0] = xs
        this2[1] = ys
        this2[2] = zs
        v = this2
        return v

    @staticmethod
    def writeFile(filename,content):
        sys_io_File.saveContent(filename,content)


class apparentridges__ApparentRidges_Vec3_Impl_:
    _hx_class_name = "apparentridges._ApparentRidges.Vec3_Impl_"
    __slots__ = ()
    _hx_statics = ["_new", "get_x", "get_y", "get_z", "set_x", "set_y", "set_z", "copy", "assign", "cross", "dot", "dist2", "dist", "len", "len2", "normalize", "scale", "get", "set", "add", "sub", "mul", "mulf"]
    x = None
    y = None
    z = None

    @staticmethod
    def _new(_x,_y,_z):
        this1 = [None]*3
        this2 = this1
        this2[0] = _x
        this2[1] = _y
        this2[2] = _z
        return this2

    @staticmethod
    def get_x(this1):
        return this1[0]

    @staticmethod
    def get_y(this1):
        return this1[1]

    @staticmethod
    def get_z(this1):
        return this1[2]

    @staticmethod
    def set_x(this1,v):
        this1[0] = v
        return v

    @staticmethod
    def set_y(this1,v):
        this1[1] = v
        return v

    @staticmethod
    def set_z(this1,v):
        this1[2] = v
        return v

    @staticmethod
    def copy(this1):
        _x = this1[0]
        _y = this1[1]
        _z = this1[2]
        this1 = [None]*3
        this2 = this1
        this2[0] = _x
        this2[1] = _y
        this2[2] = _z
        return this2

    @staticmethod
    def assign(this1,v):
        v1 = v[0]
        this1[0] = v1
        v1 = v[1]
        this1[1] = v1
        v1 = v[2]
        this1[2] = v1

    @staticmethod
    def cross(v1,v2):
        _x = ((v1[1] * v2[2]) - ((v1[2] * v2[1])))
        _y = ((v1[2] * v2[0]) - ((v1[0] * v2[2])))
        _z = ((v1[0] * v2[1]) - ((v1[1] * v2[0])))
        this1 = [None]*3
        this2 = this1
        this2[0] = _x
        this2[1] = _y
        this2[2] = _z
        return this2

    @staticmethod
    def dot(v1,v2):
        return (((v1[0] * v2[0]) + ((v1[1] * v2[1]))) + ((v1[2] * v2[2])))

    @staticmethod
    def dist2(v1,v2):
        x = (v1[0] - v2[0])
        x1 = (v1[1] - v2[1])
        x2 = (v1[2] - v2[2])
        return (((x * x) + ((x1 * x1))) + ((x2 * x2)))

    @staticmethod
    def dist(v1,v2):
        x = (v1[0] - v2[0])
        x1 = (v1[1] - v2[1])
        x2 = (v1[2] - v2[2])
        v = (((x * x) + ((x1 * x1))) + ((x2 * x2)))
        if (v < 0):
            return Math.NaN
        else:
            return python_lib_Math.sqrt(v)

    @staticmethod
    def len(this1):
        v = (((this1[0] * this1[0]) + ((this1[1] * this1[1]))) + ((this1[2] * this1[2])))
        if (v < 0):
            return Math.NaN
        else:
            return python_lib_Math.sqrt(v)

    @staticmethod
    def len2(this1):
        return (((this1[0] * this1[0]) + ((this1[1] * this1[1]))) + ((this1[2] * this1[2])))

    @staticmethod
    def normalize(this1):
        v = (((this1[0] * this1[0]) + ((this1[1] * this1[1]))) + ((this1[2] * this1[2])))
        l = (Math.NaN if ((v < 0)) else python_lib_Math.sqrt(v))
        if (l > 0):
            l = (1 / l)
            _g = this1
            v = (_g[0] * l)
            _g[0] = v
            _g = this1
            v = (_g[1] * l)
            _g[1] = v
            _g = this1
            v = (_g[2] * l)
            _g[2] = v
        else:
            this1[0] = 0
            this1[1] = 0
            this1[2] = 1

    @staticmethod
    def scale(this1,s):
        _g = this1
        v = (_g[0] * s)
        _g[0] = v
        _g = this1
        v = (_g[1] * s)
        _g[1] = v
        _g = this1
        v = (_g[2] * s)
        _g[2] = v

    @staticmethod
    def get(this1,i):
        return this1[i]

    @staticmethod
    def set(this1,i,v):
        this1[i] = v
        return v

    @staticmethod
    def add(this1,rhs):
        _x = (this1[0] + rhs[0])
        _y = (this1[1] + rhs[1])
        _z = (this1[2] + rhs[2])
        this1 = [None]*3
        this2 = this1
        this2[0] = _x
        this2[1] = _y
        this2[2] = _z
        return this2

    @staticmethod
    def sub(this1,rhs):
        _x = (this1[0] - rhs[0])
        _y = (this1[1] - rhs[1])
        _z = (this1[2] - rhs[2])
        this1 = [None]*3
        this2 = this1
        this2[0] = _x
        this2[1] = _y
        this2[2] = _z
        return this2

    @staticmethod
    def mul(this1,rhs):
        _x = (this1[0] * rhs[0])
        _y = (this1[1] * rhs[1])
        _z = (this1[2] * rhs[2])
        this1 = [None]*3
        this2 = this1
        this2[0] = _x
        this2[1] = _y
        this2[2] = _z
        return this2

    @staticmethod
    def mulf(this1,rhs):
        _x = (this1[0] * rhs)
        _y = (this1[1] * rhs)
        _z = (this1[2] * rhs)
        this1 = [None]*3
        this2 = this1
        this2[0] = _x
        this2[1] = _y
        this2[2] = _z
        return this2


class apparentridges__ApparentRidges_Face_Impl_:
    _hx_class_name = "apparentridges._ApparentRidges.Face_Impl_"
    __slots__ = ()
    _hx_statics = ["_new", "get", "set", "indexOf"]

    @staticmethod
    def _new(a,b,c):
        this1 = [None]*3
        this2 = this1
        this2[0] = a
        this2[1] = b
        this2[2] = c
        return this2

    @staticmethod
    def get(this1,i):
        return this1[i]

    @staticmethod
    def set(this1,i,v):
        this1[i] = v
        return v

    @staticmethod
    def indexOf(this1,v):
        if (this1[0] == v):
            return 0
        if (this1[1] == v):
            return 1
        if (this1[2] == v):
            return 2
        return -1


class apparentridges_Ridge:
    _hx_class_name = "apparentridges.Ridge"
    __slots__ = ("A", "B", "strengthA", "strengthB")
    _hx_fields = ["A", "B", "strengthA", "strengthB"]

    def __init__(self,a,sa,b,sb):
        self.A = a
        self.strengthA = sa
        self.B = b
        self.strengthB = sb



class apparentridges_BSphere:
    _hx_class_name = "apparentridges.BSphere"
    __slots__ = ("r", "o")
    _hx_fields = ["r", "o"]

    def __init__(self):
        self.o = None
        self.r = None



class apparentridges_Mesh:
    _hx_class_name = "apparentridges.Mesh"
    __slots__ = ("vertices", "faces", "normals", "curv1", "curv2", "pdir1", "pdir2", "pointAreas", "cornerAreas", "adjacentFaces", "ndotv", "t1q1", "Dt1q1", "bsphere", "featureSize", "bvh")
    _hx_fields = ["vertices", "faces", "normals", "curv1", "curv2", "pdir1", "pdir2", "pointAreas", "cornerAreas", "adjacentFaces", "ndotv", "t1q1", "Dt1q1", "bsphere", "featureSize", "bvh"]
    _hx_methods = ["precompute", "computeNormals", "computeBSphere", "computeFeatureSize", "computeAdjacentFaces", "getFaceEdges", "computePointAreas", "computeCurvatures", "computeVertViewDepCurv", "computeVertDt1q1", "segmentApparentRidge", "facesApparentRidges", "apparentRidges", "computeBVHTrivial", "computeBVH", "visible"]
    _hx_statics = ["rotCoordSys", "projCurv", "diagonalizeCurv"]

    def __init__(self):
        self.bvh = None
        self.featureSize = None
        self.bsphere = None
        self.Dt1q1 = []
        self.t1q1 = []
        self.ndotv = []
        self.adjacentFaces = []
        self.cornerAreas = []
        self.pointAreas = []
        self.pdir2 = []
        self.pdir1 = []
        self.curv2 = []
        self.curv1 = []
        self.normals = []
        self.faces = []
        self.vertices = []

    def precompute(self,doBVH = None,verb = None):
        if (doBVH is None):
            doBVH = True
        if (verb is None):
            verb = False
        if verb:
            print("computing normals...")
        self.computeNormals()
        if verb:
            print("computing point areas...")
        self.computePointAreas()
        if verb:
            print("computing adjacent faces...")
        self.computeAdjacentFaces()
        if verb:
            print("computing curvatures...")
        self.computeCurvatures()
        if verb:
            print("computing bounding sphere...")
        self.computeBSphere()
        if verb:
            print("computing feature size...")
        self.computeFeatureSize()
        if verb:
            print("computing bounding volume hierarchy...")
        if doBVH:
            self.computeBVH()
        else:
            self.computeBVHTrivial()
        if verb:
            print("pre-computation finished.")

    def computeNormals(self):
        _g = []
        _g1 = 0
        _g2 = len(self.vertices)
        while (_g1 < _g2):
            i = _g1
            _g1 = (_g1 + 1)
            this1 = [None]*3
            this2 = this1
            this2[0] = 0
            this2[1] = 0
            this2[2] = 0
            _g.append(this2)
        self.normals = _g
        _g = 0
        _g1 = self.faces
        while (_g < len(_g1)):
            f = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            p0 = python_internal_ArrayImpl._get(self.vertices, f[0])
            p1 = python_internal_ArrayImpl._get(self.vertices, f[1])
            p2 = python_internal_ArrayImpl._get(self.vertices, f[2])
            _x = (p0[0] - p1[0])
            _y = (p0[1] - p1[1])
            _z = (p0[2] - p1[2])
            this1 = [None]*3
            this2 = this1
            this2[0] = _x
            this2[1] = _y
            this2[2] = _z
            a = this2
            _x1 = (p1[0] - p2[0])
            _y1 = (p1[1] - p2[1])
            _z1 = (p1[2] - p2[2])
            this3 = [None]*3
            this4 = this3
            this4[0] = _x1
            this4[1] = _y1
            this4[2] = _z1
            b = this4
            _x2 = ((a[1] * b[2]) - ((a[2] * b[1])))
            _y2 = ((a[2] * b[0]) - ((a[0] * b[2])))
            _z2 = ((a[0] * b[1]) - ((a[1] * b[0])))
            this5 = [None]*3
            this6 = this5
            this6[0] = _x2
            this6[1] = _y2
            this6[2] = _z2
            fn = this6
            _g2 = self.normals
            _g3 = f[0]
            _g4 = (_g2[_g3] if _g3 >= 0 and _g3 < len(_g2) else None)
            _x3 = (_g4[0] + fn[0])
            _y3 = (_g4[1] + fn[1])
            _z3 = (_g4[2] + fn[2])
            this7 = [None]*3
            this8 = this7
            this8[0] = _x3
            this8[1] = _y3
            this8[2] = _z3
            python_internal_ArrayImpl._set(_g2, _g3, this8)
            _g5 = self.normals
            _g6 = f[1]
            _g7 = (_g5[_g6] if _g6 >= 0 and _g6 < len(_g5) else None)
            _x4 = (_g7[0] + fn[0])
            _y4 = (_g7[1] + fn[1])
            _z4 = (_g7[2] + fn[2])
            this9 = [None]*3
            this10 = this9
            this10[0] = _x4
            this10[1] = _y4
            this10[2] = _z4
            python_internal_ArrayImpl._set(_g5, _g6, this10)
            _g8 = self.normals
            _g9 = f[2]
            _g10 = (_g8[_g9] if _g9 >= 0 and _g9 < len(_g8) else None)
            _x5 = (_g10[0] + fn[0])
            _y5 = (_g10[1] + fn[1])
            _z5 = (_g10[2] + fn[2])
            this11 = [None]*3
            this12 = this11
            this12[0] = _x5
            this12[1] = _y5
            this12[2] = _z5
            python_internal_ArrayImpl._set(_g8, _g9, this12)
        _g = 0
        _g1 = self.normals
        while (_g < len(_g1)):
            n = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            v = (((n[0] * n[0]) + ((n[1] * n[1]))) + ((n[2] * n[2])))
            l = (Math.NaN if ((v < 0)) else python_lib_Math.sqrt(v))
            if (l > 0):
                l = (1 / l)
                _g2 = n
                v1 = (_g2[0] * l)
                _g2[0] = v1
                _g3 = n
                v2 = (_g3[1] * l)
                _g3[1] = v2
                _g4 = n
                v3 = (_g4[2] * l)
                _g4[2] = v3
            else:
                n[0] = 0
                n[1] = 0
                n[2] = 1

    def computeBSphere(self):
        _gthis = self
        self.bsphere = apparentridges_BSphere()
        def _hx_local_0(dir):
            nv = len(_gthis.vertices)
            far = 0
            v1 = (_gthis.vertices[0] if 0 < len(_gthis.vertices) else None)
            far_dot = (((v1[0] * dir[0]) + ((v1[1] * dir[1]))) + ((v1[2] * dir[2])))
            _g = 1
            _g1 = nv
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                v1 = (_gthis.vertices[i] if i >= 0 and i < len(_gthis.vertices) else None)
                my_dot = (((v1[0] * dir[0]) + ((v1[1] * dir[1]))) + ((v1[2] * dir[2])))
                if (my_dot > far_dot):
                    far = i
                    far_dot = my_dot
            return far
        farthestVertexAlong = _hx_local_0
        this1 = [None]*3
        this2 = this1
        this2[0] = 0
        this2[1] = 0
        this2[2] = 0
        best_min = this2
        this1 = [None]*3
        this2 = this1
        this2[0] = 0
        this2[1] = 0
        this2[2] = 0
        best_max = this2
        this1 = [None]*3
        this2 = this1
        this2[0] = 1
        this2[1] = 0
        this2[2] = 0
        this1 = [None]*3
        this3 = this1
        this3[0] = 0
        this3[1] = 1
        this3[2] = 0
        this1 = [None]*3
        this4 = this1
        this4[0] = 0
        this4[1] = 0
        this4[2] = 1
        this1 = [None]*3
        this5 = this1
        this5[0] = 1
        this5[1] = 1
        this5[2] = 1
        this1 = [None]*3
        this6 = this1
        this6[0] = 1
        this6[1] = -1
        this6[2] = 1
        this1 = [None]*3
        this7 = this1
        this7[0] = 1
        this7[1] = -1
        this7[2] = -1
        this1 = [None]*3
        this8 = this1
        this8[0] = 1
        this8[1] = 1
        this8[2] = 1
        dirs = [this2, this3, this4, this5, this6, this7, this8]
        _g = 0
        while (_g < len(dirs)):
            d = (dirs[_g] if _g >= 0 and _g < len(dirs) else None)
            _g = (_g + 1)
            p1 = self.vertices
            _x = (d[0] * -1.0)
            _y = (d[1] * -1.0)
            _z = (d[2] * -1.0)
            this1 = [None]*3
            this2 = this1
            this2[0] = _x
            this2[1] = _y
            this2[2] = _z
            p11 = python_internal_ArrayImpl._get(p1, farthestVertexAlong(this2))
            p2 = python_internal_ArrayImpl._get(self.vertices, farthestVertexAlong(d))
            x = (p11[0] - p2[0])
            x1 = (p11[1] - p2[1])
            x2 = (p11[2] - p2[2])
            x3 = (best_min[0] - best_max[0])
            x4 = (best_min[1] - best_max[1])
            x5 = (best_min[2] - best_max[2])
            if ((((x * x) + ((x1 * x1))) + ((x2 * x2))) > ((((x3 * x3) + ((x4 * x4))) + ((x5 * x5))))):
                best_min = p11
                best_max = p2
        _x = (best_min[0] + best_max[0])
        _y = (best_min[1] + best_max[1])
        _z = (best_min[2] + best_max[2])
        this1 = [None]*3
        this2 = this1
        this2[0] = _x
        this2[1] = _y
        this2[2] = _z
        this1 = this2
        _x = (this1[0] * 0.5)
        _y = (this1[1] * 0.5)
        _z = (this1[2] * 0.5)
        this1 = [None]*3
        this2 = this1
        this2[0] = _x
        this2[1] = _y
        this2[2] = _z
        self.bsphere.o = this2
        x = (best_min[0] - best_max[0])
        x1 = (best_min[1] - best_max[1])
        x2 = (best_min[2] - best_max[2])
        v = (((x * x) + ((x1 * x1))) + ((x2 * x2)))
        tmp = (Math.NaN if ((v < 0)) else python_lib_Math.sqrt(v))
        self.bsphere.r = (tmp * 0.5)
        x = self.bsphere.r
        r2 = (x * x)
        _g = 0
        _g1 = len(self.vertices)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            v1 = (self.vertices[i] if i >= 0 and i < len(self.vertices) else None)
            v2 = self.bsphere.o
            x = (v1[0] - v2[0])
            x1 = (v1[1] - v2[1])
            x2 = (v1[2] - v2[2])
            d2 = (((x * x) + ((x1 * x1))) + ((x2 * x2)))
            if (d2 <= r2):
                continue
            d = (Math.NaN if ((d2 < 0)) else python_lib_Math.sqrt(d2))
            self.bsphere.r = (0.5 * ((self.bsphere.r + d)))
            x3 = self.bsphere.r
            r2 = (x3 * x3)
            this1 = self.bsphere.o
            rhs = (self.vertices[i] if i >= 0 and i < len(self.vertices) else None)
            _x = (this1[0] - rhs[0])
            _y = (this1[1] - rhs[1])
            _z = (this1[2] - rhs[2])
            this2 = [None]*3
            this3 = this2
            this3[0] = _x
            this3[1] = _y
            this3[2] = _z
            self.bsphere.o = this3
            this4 = self.bsphere.o
            rhs1 = (self.bsphere.r * ((1.0 / d)))
            _x1 = (this4[0] * rhs1)
            _y1 = (this4[1] * rhs1)
            _z1 = (this4[2] * rhs1)
            this5 = [None]*3
            this6 = this5
            this6[0] = _x1
            this6[1] = _y1
            this6[2] = _z1
            self.bsphere.o = this6
            this7 = self.bsphere.o
            rhs2 = (self.vertices[i] if i >= 0 and i < len(self.vertices) else None)
            _x2 = (this7[0] + rhs2[0])
            _y2 = (this7[1] + rhs2[1])
            _z2 = (this7[2] + rhs2[2])
            this8 = [None]*3
            this9 = this8
            this9[0] = _x2
            this9[1] = _y2
            this9[2] = _z2
            self.bsphere.o = this9

    def computeFeatureSize(self):
        nv = len(self.curv1)
        nsamp = (500 if ((nv > 500)) else nv)
        samples = []
        s = 79
        p = 103
        q = 211
        m = (p * q)
        _g = 0
        _g1 = nsamp
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            ind = None
            try:
                ind = int((nv * ((s / m))))
            except BaseException as _g2:
                None
                ind = None
            ind1 = ind
            s = HxOverrides.mod((s * s), m)
            x = Reflect.field(Math,"fabs")((self.curv1[ind1] if ind1 >= 0 and ind1 < len(self.curv1) else None))
            samples.append(x)
            x1 = Reflect.field(Math,"fabs")((self.curv2[ind1] if ind1 >= 0 and ind1 < len(self.curv2) else None))
            samples.append(x1)
        frac = 0.1
        mult = 0.01
        max_feat_size = (0.05 * self.bsphere.r)
        x = (frac * len(samples))
        which = None
        try:
            which = int(x)
        except BaseException as _g:
            None
            which = None
        def _hx_local_0(a,b):
            if (a < b):
                return -1
            elif (a > b):
                return 1
            else:
                return 0
        samples.sort(key= python_lib_Functools.cmp_to_key(_hx_local_0))
        a = (mult / (samples[which] if which >= 0 and which < len(samples) else None))
        self.featureSize = (a if (python_lib_Math.isnan(a)) else (max_feat_size if (python_lib_Math.isnan(max_feat_size)) else min(a,max_feat_size)))

    def computeAdjacentFaces(self):
        _g = []
        _g1 = 0
        _g2 = len(self.vertices)
        while (_g1 < _g2):
            i = _g1
            _g1 = (_g1 + 1)
            x = list()
            _g.append(x)
        self.adjacentFaces = _g
        _g = 0
        _g1 = len(self.faces)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            _this = python_internal_ArrayImpl._get(self.adjacentFaces, (self.faces[i] if i >= 0 and i < len(self.faces) else None)[0])
            _this.append(i)
            _this1 = python_internal_ArrayImpl._get(self.adjacentFaces, (self.faces[i] if i >= 0 and i < len(self.faces) else None)[1])
            _this1.append(i)
            _this2 = python_internal_ArrayImpl._get(self.adjacentFaces, (self.faces[i] if i >= 0 and i < len(self.faces) else None)[2])
            _this2.append(i)

    def getFaceEdges(self,f):
        this1 = [None]*3
        e = this1
        this1 = python_internal_ArrayImpl._get(self.vertices, f[2])
        rhs = python_internal_ArrayImpl._get(self.vertices, f[1])
        _x = (this1[0] - rhs[0])
        _y = (this1[1] - rhs[1])
        _z = (this1[2] - rhs[2])
        this1 = [None]*3
        this2 = this1
        this2[0] = _x
        this2[1] = _y
        this2[2] = _z
        val = this2
        e[0] = val
        this1 = python_internal_ArrayImpl._get(self.vertices, f[0])
        rhs = python_internal_ArrayImpl._get(self.vertices, f[2])
        _x = (this1[0] - rhs[0])
        _y = (this1[1] - rhs[1])
        _z = (this1[2] - rhs[2])
        this1 = [None]*3
        this2 = this1
        this2[0] = _x
        this2[1] = _y
        this2[2] = _z
        val = this2
        e[1] = val
        this1 = python_internal_ArrayImpl._get(self.vertices, f[1])
        rhs = python_internal_ArrayImpl._get(self.vertices, f[0])
        _x = (this1[0] - rhs[0])
        _y = (this1[1] - rhs[1])
        _z = (this1[2] - rhs[2])
        this1 = [None]*3
        this2 = this1
        this2[0] = _x
        this2[1] = _y
        this2[2] = _z
        val = this2
        e[2] = val
        return e

    def computePointAreas(self):
        nf = len(self.faces)
        nv = len(self.vertices)
        _g = []
        _g1 = 0
        _g2 = nv
        while (_g1 < _g2):
            i = _g1
            _g1 = (_g1 + 1)
            _g.append(0)
        self.pointAreas = _g
        _g = []
        _g1 = 0
        _g2 = nf
        while (_g1 < _g2):
            i = _g1
            _g1 = (_g1 + 1)
            this1 = [None]*3
            this2 = this1
            this2[0] = 0
            this2[1] = 0
            this2[2] = 0
            _g.append(this2)
        self.cornerAreas = _g
        _g = 0
        _g1 = nf
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            e = self.getFaceEdges((self.faces[i] if i >= 0 and i < len(self.faces) else None))
            v1 = e[0]
            v2 = e[1]
            _x = ((v1[1] * v2[2]) - ((v1[2] * v2[1])))
            _y = ((v1[2] * v2[0]) - ((v1[0] * v2[2])))
            _z = ((v1[0] * v2[1]) - ((v1[1] * v2[0])))
            this1 = [None]*3
            this2 = this1
            this2[0] = _x
            this2[1] = _y
            this2[2] = _z
            this3 = this2
            v = (((this3[0] * this3[0]) + ((this3[1] * this3[1]))) + ((this3[2] * this3[2])))
            area = (0.5 * ((Math.NaN if ((v < 0)) else python_lib_Math.sqrt(v))))
            this4 = e[0]
            l2_0 = (((this4[0] * this4[0]) + ((this4[1] * this4[1]))) + ((this4[2] * this4[2])))
            this5 = e[1]
            l2_1 = (((this5[0] * this5[0]) + ((this5[1] * this5[1]))) + ((this5[2] * this5[2])))
            this6 = e[2]
            l2_2 = (((this6[0] * this6[0]) + ((this6[1] * this6[1]))) + ((this6[2] * this6[2])))
            bcw_0 = (l2_0 * (((l2_1 + l2_2) - l2_0)))
            bcw_1 = (l2_1 * (((l2_2 + l2_0) - l2_1)))
            bcw_2 = (l2_2 * (((l2_0 + l2_1) - l2_2)))
            if (bcw_0 <= 0):
                this7 = (self.cornerAreas[i] if i >= 0 and i < len(self.cornerAreas) else None)
                v11 = e[0]
                v21 = e[2]
                v3 = (((-0.25 * l2_2) * area) / ((((v11[0] * v21[0]) + ((v11[1] * v21[1]))) + ((v11[2] * v21[2])))))
                this7[1] = v3
                this8 = (self.cornerAreas[i] if i >= 0 and i < len(self.cornerAreas) else None)
                v12 = e[0]
                v22 = e[1]
                v4 = (((-0.25 * l2_1) * area) / ((((v12[0] * v22[0]) + ((v12[1] * v22[1]))) + ((v12[2] * v22[2])))))
                this8[2] = v4
                this9 = (self.cornerAreas[i] if i >= 0 and i < len(self.cornerAreas) else None)
                v5 = ((area - (self.cornerAreas[i] if i >= 0 and i < len(self.cornerAreas) else None)[1]) - (self.cornerAreas[i] if i >= 0 and i < len(self.cornerAreas) else None)[2])
                this9[0] = v5
            elif (bcw_1 <= 0.0):
                this10 = (self.cornerAreas[i] if i >= 0 and i < len(self.cornerAreas) else None)
                v13 = e[1]
                v23 = e[0]
                v6 = (((-0.25 * l2_0) * area) / ((((v13[0] * v23[0]) + ((v13[1] * v23[1]))) + ((v13[2] * v23[2])))))
                this10[2] = v6
                this11 = (self.cornerAreas[i] if i >= 0 and i < len(self.cornerAreas) else None)
                v14 = e[1]
                v24 = e[2]
                v7 = (((-0.25 * l2_2) * area) / ((((v14[0] * v24[0]) + ((v14[1] * v24[1]))) + ((v14[2] * v24[2])))))
                this11[0] = v7
                this12 = (self.cornerAreas[i] if i >= 0 and i < len(self.cornerAreas) else None)
                v8 = ((area - (self.cornerAreas[i] if i >= 0 and i < len(self.cornerAreas) else None)[2]) - (self.cornerAreas[i] if i >= 0 and i < len(self.cornerAreas) else None)[0])
                this12[1] = v8
            elif (bcw_2 <= 0.0):
                this13 = (self.cornerAreas[i] if i >= 0 and i < len(self.cornerAreas) else None)
                v15 = e[2]
                v25 = e[1]
                v9 = (((-0.25 * l2_1) * area) / ((((v15[0] * v25[0]) + ((v15[1] * v25[1]))) + ((v15[2] * v25[2])))))
                this13[0] = v9
                this14 = (self.cornerAreas[i] if i >= 0 and i < len(self.cornerAreas) else None)
                v16 = e[2]
                v26 = e[0]
                v10 = (((-0.25 * l2_0) * area) / ((((v16[0] * v26[0]) + ((v16[1] * v26[1]))) + ((v16[2] * v26[2])))))
                this14[1] = v10
                this15 = (self.cornerAreas[i] if i >= 0 and i < len(self.cornerAreas) else None)
                v17 = ((area - (self.cornerAreas[i] if i >= 0 and i < len(self.cornerAreas) else None)[0]) - (self.cornerAreas[i] if i >= 0 and i < len(self.cornerAreas) else None)[1])
                this15[2] = v17
            else:
                scale = ((0.5 * area) / (((bcw_0 + bcw_1) + bcw_2)))
                v18 = (scale * ((bcw_1 + bcw_2)))
                (self.cornerAreas[i] if i >= 0 and i < len(self.cornerAreas) else None)[0] = v18
                v19 = (scale * ((bcw_2 + bcw_0)))
                (self.cornerAreas[i] if i >= 0 and i < len(self.cornerAreas) else None)[1] = v19
                v20 = (scale * ((bcw_0 + bcw_1)))
                (self.cornerAreas[i] if i >= 0 and i < len(self.cornerAreas) else None)[2] = v20
            _hx_local_0 = self.pointAreas
            _hx_local_1 = (self.faces[i] if i >= 0 and i < len(self.faces) else None)[0]
            _hx_local_2 = (_hx_local_0[_hx_local_1] if _hx_local_1 >= 0 and _hx_local_1 < len(_hx_local_0) else None)
            python_internal_ArrayImpl._set(_hx_local_0, _hx_local_1, (_hx_local_2 + (self.cornerAreas[i] if i >= 0 and i < len(self.cornerAreas) else None)[0]))
            (_hx_local_0[_hx_local_1] if _hx_local_1 >= 0 and _hx_local_1 < len(_hx_local_0) else None)
            _hx_local_3 = self.pointAreas
            _hx_local_4 = (self.faces[i] if i >= 0 and i < len(self.faces) else None)[1]
            _hx_local_5 = (_hx_local_3[_hx_local_4] if _hx_local_4 >= 0 and _hx_local_4 < len(_hx_local_3) else None)
            python_internal_ArrayImpl._set(_hx_local_3, _hx_local_4, (_hx_local_5 + (self.cornerAreas[i] if i >= 0 and i < len(self.cornerAreas) else None)[1]))
            (_hx_local_3[_hx_local_4] if _hx_local_4 >= 0 and _hx_local_4 < len(_hx_local_3) else None)
            _hx_local_6 = self.pointAreas
            _hx_local_7 = (self.faces[i] if i >= 0 and i < len(self.faces) else None)[2]
            _hx_local_8 = (_hx_local_6[_hx_local_7] if _hx_local_7 >= 0 and _hx_local_7 < len(_hx_local_6) else None)
            python_internal_ArrayImpl._set(_hx_local_6, _hx_local_7, (_hx_local_8 + (self.cornerAreas[i] if i >= 0 and i < len(self.cornerAreas) else None)[2]))
            (_hx_local_6[_hx_local_7] if _hx_local_7 >= 0 and _hx_local_7 < len(_hx_local_6) else None)

    def computeCurvatures(self):
        nv = len(self.vertices)
        nf = len(self.faces)
        _g = []
        _g1 = 0
        _g2 = nv
        while (_g1 < _g2):
            i = _g1
            _g1 = (_g1 + 1)
            _g.append(0)
        self.curv1 = _g
        _g = []
        _g1 = 0
        _g2 = nv
        while (_g1 < _g2):
            i = _g1
            _g1 = (_g1 + 1)
            _g.append(0)
        self.curv2 = _g
        _g = []
        _g1 = 0
        _g2 = nv
        while (_g1 < _g2):
            i = _g1
            _g1 = (_g1 + 1)
            this1 = [None]*3
            this2 = this1
            this2[0] = 0
            this2[1] = 0
            this2[2] = 0
            _g.append(this2)
        self.pdir1 = _g
        _g = []
        _g1 = 0
        _g2 = nv
        while (_g1 < _g2):
            i = _g1
            _g1 = (_g1 + 1)
            this1 = [None]*3
            this2 = this1
            this2[0] = 0
            this2[1] = 0
            this2[2] = 0
            _g.append(this2)
        self.pdir2 = _g
        _g = []
        _g1 = 0
        _g2 = nv
        while (_g1 < _g2):
            i = _g1
            _g1 = (_g1 + 1)
            _g.append(0)
        curv12 = _g
        _g = 0
        _g1 = nf
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            tmp = self.pdir1
            tmp1 = (self.faces[i] if i >= 0 and i < len(self.faces) else None)[0]
            this1 = python_internal_ArrayImpl._get(self.vertices, (self.faces[i] if i >= 0 and i < len(self.faces) else None)[1])
            rhs = python_internal_ArrayImpl._get(self.vertices, (self.faces[i] if i >= 0 and i < len(self.faces) else None)[0])
            _x = (this1[0] - rhs[0])
            _y = (this1[1] - rhs[1])
            _z = (this1[2] - rhs[2])
            this2 = [None]*3
            this3 = this2
            this3[0] = _x
            this3[1] = _y
            this3[2] = _z
            python_internal_ArrayImpl._set(tmp, tmp1, this3)
            tmp2 = self.pdir1
            tmp3 = (self.faces[i] if i >= 0 and i < len(self.faces) else None)[1]
            this4 = python_internal_ArrayImpl._get(self.vertices, (self.faces[i] if i >= 0 and i < len(self.faces) else None)[2])
            rhs1 = python_internal_ArrayImpl._get(self.vertices, (self.faces[i] if i >= 0 and i < len(self.faces) else None)[1])
            _x1 = (this4[0] - rhs1[0])
            _y1 = (this4[1] - rhs1[1])
            _z1 = (this4[2] - rhs1[2])
            this5 = [None]*3
            this6 = this5
            this6[0] = _x1
            this6[1] = _y1
            this6[2] = _z1
            python_internal_ArrayImpl._set(tmp2, tmp3, this6)
            tmp4 = self.pdir1
            tmp5 = (self.faces[i] if i >= 0 and i < len(self.faces) else None)[2]
            this7 = python_internal_ArrayImpl._get(self.vertices, (self.faces[i] if i >= 0 and i < len(self.faces) else None)[0])
            rhs2 = python_internal_ArrayImpl._get(self.vertices, (self.faces[i] if i >= 0 and i < len(self.faces) else None)[2])
            _x2 = (this7[0] - rhs2[0])
            _y2 = (this7[1] - rhs2[1])
            _z2 = (this7[2] - rhs2[2])
            this8 = [None]*3
            this9 = this8
            this9[0] = _x2
            this9[1] = _y2
            this9[2] = _z2
            python_internal_ArrayImpl._set(tmp4, tmp5, this9)
        _g = 0
        _g1 = nv
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            tmp = self.pdir1
            v1 = (self.pdir1[i] if i >= 0 and i < len(self.pdir1) else None)
            v2 = (self.normals[i] if i >= 0 and i < len(self.normals) else None)
            _x = ((v1[1] * v2[2]) - ((v1[2] * v2[1])))
            _y = ((v1[2] * v2[0]) - ((v1[0] * v2[2])))
            _z = ((v1[0] * v2[1]) - ((v1[1] * v2[0])))
            this1 = [None]*3
            this2 = this1
            this2[0] = _x
            this2[1] = _y
            this2[2] = _z
            python_internal_ArrayImpl._set(tmp, i, this2)
            this3 = (self.pdir1[i] if i >= 0 and i < len(self.pdir1) else None)
            v = (((this3[0] * this3[0]) + ((this3[1] * this3[1]))) + ((this3[2] * this3[2])))
            l = (Math.NaN if ((v < 0)) else python_lib_Math.sqrt(v))
            if (l > 0):
                l = (1 / l)
                _g2 = this3
                v3 = (_g2[0] * l)
                _g2[0] = v3
                _g3 = this3
                v4 = (_g3[1] * l)
                _g3[1] = v4
                _g4 = this3
                v5 = (_g4[2] * l)
                _g4[2] = v5
            else:
                this3[0] = 0
                this3[1] = 0
                this3[2] = 1
            tmp1 = self.pdir2
            v11 = (self.normals[i] if i >= 0 and i < len(self.normals) else None)
            v21 = (self.pdir1[i] if i >= 0 and i < len(self.pdir1) else None)
            _x1 = ((v11[1] * v21[2]) - ((v11[2] * v21[1])))
            _y1 = ((v11[2] * v21[0]) - ((v11[0] * v21[2])))
            _z1 = ((v11[0] * v21[1]) - ((v11[1] * v21[0])))
            this4 = [None]*3
            this5 = this4
            this5[0] = _x1
            this5[1] = _y1
            this5[2] = _z1
            python_internal_ArrayImpl._set(tmp1, i, this5)
        _g = 0
        _g1 = nf
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            f = (self.faces[i] if i >= 0 and i < len(self.faces) else None)
            e = self.getFaceEdges(f)
            this1 = e[0]
            _x = this1[0]
            _y = this1[1]
            _z = this1[2]
            this2 = [None]*3
            this3 = this2
            this3[0] = _x
            this3[1] = _y
            this3[2] = _z
            t = this3
            v = (((t[0] * t[0]) + ((t[1] * t[1]))) + ((t[2] * t[2])))
            l = (Math.NaN if ((v < 0)) else python_lib_Math.sqrt(v))
            if (l > 0):
                l = (1 / l)
                _g2 = t
                v1 = (_g2[0] * l)
                _g2[0] = v1
                _g3 = t
                v2 = (_g3[1] * l)
                _g3[1] = v2
                _g4 = t
                v3 = (_g4[2] * l)
                _g4[2] = v3
            else:
                t[0] = 0
                t[1] = 0
                t[2] = 1
            v11 = e[0]
            v21 = e[1]
            _x1 = ((v11[1] * v21[2]) - ((v11[2] * v21[1])))
            _y1 = ((v11[2] * v21[0]) - ((v11[0] * v21[2])))
            _z1 = ((v11[0] * v21[1]) - ((v11[1] * v21[0])))
            this4 = [None]*3
            this5 = this4
            this5[0] = _x1
            this5[1] = _y1
            this5[2] = _z1
            n = this5
            _x2 = ((n[1] * t[2]) - ((n[2] * t[1])))
            _y2 = ((n[2] * t[0]) - ((n[0] * t[2])))
            _z2 = ((n[0] * t[1]) - ((n[1] * t[0])))
            this6 = [None]*3
            this7 = this6
            this7[0] = _x2
            this7[1] = _y2
            this7[2] = _z2
            b = this7
            v4 = (((b[0] * b[0]) + ((b[1] * b[1]))) + ((b[2] * b[2])))
            l1 = (Math.NaN if ((v4 < 0)) else python_lib_Math.sqrt(v4))
            if (l1 > 0):
                l1 = (1 / l1)
                _g5 = b
                v5 = (_g5[0] * l1)
                _g5[0] = v5
                _g6 = b
                v6 = (_g6[1] * l1)
                _g6[1] = v6
                _g7 = b
                v7 = (_g7[2] * l1)
                _g7[2] = v7
            else:
                b[0] = 0
                b[1] = 0
                b[2] = 1
            m = [0, 0, 0]
            w = [[0, 0, 0], [0, 0, 0], [0, 0, 0]]
            _g8 = 0
            while (_g8 < 3):
                j = _g8
                _g8 = (_g8 + 1)
                v12 = e[j]
                u = (((v12[0] * t[0]) + ((v12[1] * t[1]))) + ((v12[2] * t[2])))
                v13 = e[j]
                v8 = (((v13[0] * b[0]) + ((v13[1] * b[1]))) + ((v13[2] * b[2])))
                _hx_local_0 = (w[0] if 0 < len(w) else None)
                _hx_local_1 = 0
                _hx_local_2 = (_hx_local_0[_hx_local_1] if _hx_local_1 >= 0 and _hx_local_1 < len(_hx_local_0) else None)
                python_internal_ArrayImpl._set(_hx_local_0, _hx_local_1, (_hx_local_2 + ((u * u))))
                (_hx_local_0[_hx_local_1] if _hx_local_1 >= 0 and _hx_local_1 < len(_hx_local_0) else None)
                _hx_local_3 = (w[0] if 0 < len(w) else None)
                _hx_local_4 = 1
                _hx_local_5 = (_hx_local_3[_hx_local_4] if _hx_local_4 >= 0 and _hx_local_4 < len(_hx_local_3) else None)
                python_internal_ArrayImpl._set(_hx_local_3, _hx_local_4, (_hx_local_5 + ((u * v8))))
                (_hx_local_3[_hx_local_4] if _hx_local_4 >= 0 and _hx_local_4 < len(_hx_local_3) else None)
                _hx_local_6 = (w[2] if 2 < len(w) else None)
                _hx_local_7 = 2
                _hx_local_8 = (_hx_local_6[_hx_local_7] if _hx_local_7 >= 0 and _hx_local_7 < len(_hx_local_6) else None)
                python_internal_ArrayImpl._set(_hx_local_6, _hx_local_7, (_hx_local_8 + ((v8 * v8))))
                (_hx_local_6[_hx_local_7] if _hx_local_7 >= 0 and _hx_local_7 < len(_hx_local_6) else None)
                this8 = python_internal_ArrayImpl._get(self.normals, f[((j - 1) if ((j > 0)) else (j + 2))])
                rhs = python_internal_ArrayImpl._get(self.normals, f[((j + 1) if ((j < 2)) else (j - 2))])
                _x3 = (this8[0] - rhs[0])
                _y3 = (this8[1] - rhs[1])
                _z3 = (this8[2] - rhs[2])
                this9 = [None]*3
                this10 = this9
                this10[0] = _x3
                this10[1] = _y3
                this10[2] = _z3
                dn = this10
                dnu = (((dn[0] * t[0]) + ((dn[1] * t[1]))) + ((dn[2] * t[2])))
                dnv = (((dn[0] * b[0]) + ((dn[1] * b[1]))) + ((dn[2] * b[2])))
                _hx_local_9 = m
                _hx_local_10 = 0
                _hx_local_11 = (_hx_local_9[_hx_local_10] if _hx_local_10 >= 0 and _hx_local_10 < len(_hx_local_9) else None)
                python_internal_ArrayImpl._set(_hx_local_9, _hx_local_10, (_hx_local_11 + ((dnu * u))))
                (_hx_local_9[_hx_local_10] if _hx_local_10 >= 0 and _hx_local_10 < len(_hx_local_9) else None)
                _hx_local_12 = m
                _hx_local_13 = 1
                _hx_local_14 = (_hx_local_12[_hx_local_13] if _hx_local_13 >= 0 and _hx_local_13 < len(_hx_local_12) else None)
                python_internal_ArrayImpl._set(_hx_local_12, _hx_local_13, (_hx_local_14 + (((dnu * v8) + ((dnv * u))))))
                (_hx_local_12[_hx_local_13] if _hx_local_13 >= 0 and _hx_local_13 < len(_hx_local_12) else None)
                _hx_local_15 = m
                _hx_local_16 = 2
                _hx_local_17 = (_hx_local_15[_hx_local_16] if _hx_local_16 >= 0 and _hx_local_16 < len(_hx_local_15) else None)
                python_internal_ArrayImpl._set(_hx_local_15, _hx_local_16, (_hx_local_17 + ((dnv * v8))))
                (_hx_local_15[_hx_local_16] if _hx_local_16 >= 0 and _hx_local_16 < len(_hx_local_15) else None)
            python_internal_ArrayImpl._set((w[1] if 1 < len(w) else None), 1, (python_internal_ArrayImpl._get((w[0] if 0 < len(w) else None), 0) + python_internal_ArrayImpl._get((w[2] if 2 < len(w) else None), 2)))
            python_internal_ArrayImpl._set((w[1] if 1 < len(w) else None), 2, python_internal_ArrayImpl._get((w[0] if 0 < len(w) else None), 1))
            diag = [0, 0, 0]
            if (not apparentridges_Util.ldltdc(w,diag)):
                continue
            apparentridges_Util.ldltsl(w,diag,m,m)
            vj = f[0]
            ccc = apparentridges_Mesh.projCurv(t,b,(m[0] if 0 < len(m) else None),(m[1] if 1 < len(m) else None),(m[2] if 2 < len(m) else None),(self.pdir1[vj] if vj >= 0 and vj < len(self.pdir1) else None),(self.pdir2[vj] if vj >= 0 and vj < len(self.pdir2) else None))
            c1 = ccc[0]
            c12 = ccc[1]
            c2 = ccc[2]
            wt = ((self.cornerAreas[i] if i >= 0 and i < len(self.cornerAreas) else None)[0] / (self.pointAreas[vj] if vj >= 0 and vj < len(self.pointAreas) else None))
            _hx_local_18 = self.curv1
            _hx_local_19 = vj
            _hx_local_20 = (_hx_local_18[_hx_local_19] if _hx_local_19 >= 0 and _hx_local_19 < len(_hx_local_18) else None)
            python_internal_ArrayImpl._set(_hx_local_18, _hx_local_19, (_hx_local_20 + ((wt * c1))))
            (_hx_local_18[_hx_local_19] if _hx_local_19 >= 0 and _hx_local_19 < len(_hx_local_18) else None)
            python_internal_ArrayImpl._set(curv12, vj, ((curv12[vj] if vj >= 0 and vj < len(curv12) else None) + ((wt * c12))))
            _hx_local_22 = self.curv2
            _hx_local_23 = vj
            _hx_local_24 = (_hx_local_22[_hx_local_23] if _hx_local_23 >= 0 and _hx_local_23 < len(_hx_local_22) else None)
            python_internal_ArrayImpl._set(_hx_local_22, _hx_local_23, (_hx_local_24 + ((wt * c2))))
            (_hx_local_22[_hx_local_23] if _hx_local_23 >= 0 and _hx_local_23 < len(_hx_local_22) else None)
            vj1 = f[1]
            ccc1 = apparentridges_Mesh.projCurv(t,b,(m[0] if 0 < len(m) else None),(m[1] if 1 < len(m) else None),(m[2] if 2 < len(m) else None),(self.pdir1[vj1] if vj1 >= 0 and vj1 < len(self.pdir1) else None),(self.pdir2[vj1] if vj1 >= 0 and vj1 < len(self.pdir2) else None))
            c11 = ccc1[0]
            c121 = ccc1[1]
            c21 = ccc1[2]
            wt1 = ((self.cornerAreas[i] if i >= 0 and i < len(self.cornerAreas) else None)[1] / (self.pointAreas[vj1] if vj1 >= 0 and vj1 < len(self.pointAreas) else None))
            _hx_local_25 = self.curv1
            _hx_local_26 = vj1
            _hx_local_27 = (_hx_local_25[_hx_local_26] if _hx_local_26 >= 0 and _hx_local_26 < len(_hx_local_25) else None)
            python_internal_ArrayImpl._set(_hx_local_25, _hx_local_26, (_hx_local_27 + ((wt1 * c11))))
            (_hx_local_25[_hx_local_26] if _hx_local_26 >= 0 and _hx_local_26 < len(_hx_local_25) else None)
            python_internal_ArrayImpl._set(curv12, vj1, ((curv12[vj1] if vj1 >= 0 and vj1 < len(curv12) else None) + ((wt1 * c121))))
            _hx_local_29 = self.curv2
            _hx_local_30 = vj1
            _hx_local_31 = (_hx_local_29[_hx_local_30] if _hx_local_30 >= 0 and _hx_local_30 < len(_hx_local_29) else None)
            python_internal_ArrayImpl._set(_hx_local_29, _hx_local_30, (_hx_local_31 + ((wt1 * c21))))
            (_hx_local_29[_hx_local_30] if _hx_local_30 >= 0 and _hx_local_30 < len(_hx_local_29) else None)
            vj2 = f[2]
            ccc2 = apparentridges_Mesh.projCurv(t,b,(m[0] if 0 < len(m) else None),(m[1] if 1 < len(m) else None),(m[2] if 2 < len(m) else None),(self.pdir1[vj2] if vj2 >= 0 and vj2 < len(self.pdir1) else None),(self.pdir2[vj2] if vj2 >= 0 and vj2 < len(self.pdir2) else None))
            c13 = ccc2[0]
            c122 = ccc2[1]
            c22 = ccc2[2]
            wt2 = ((self.cornerAreas[i] if i >= 0 and i < len(self.cornerAreas) else None)[2] / (self.pointAreas[vj2] if vj2 >= 0 and vj2 < len(self.pointAreas) else None))
            _hx_local_32 = self.curv1
            _hx_local_33 = vj2
            _hx_local_34 = (_hx_local_32[_hx_local_33] if _hx_local_33 >= 0 and _hx_local_33 < len(_hx_local_32) else None)
            python_internal_ArrayImpl._set(_hx_local_32, _hx_local_33, (_hx_local_34 + ((wt2 * c13))))
            (_hx_local_32[_hx_local_33] if _hx_local_33 >= 0 and _hx_local_33 < len(_hx_local_32) else None)
            python_internal_ArrayImpl._set(curv12, vj2, ((curv12[vj2] if vj2 >= 0 and vj2 < len(curv12) else None) + ((wt2 * c122))))
            _hx_local_36 = self.curv2
            _hx_local_37 = vj2
            _hx_local_38 = (_hx_local_36[_hx_local_37] if _hx_local_37 >= 0 and _hx_local_37 < len(_hx_local_36) else None)
            python_internal_ArrayImpl._set(_hx_local_36, _hx_local_37, (_hx_local_38 + ((wt2 * c22))))
            (_hx_local_36[_hx_local_37] if _hx_local_37 >= 0 and _hx_local_37 < len(_hx_local_36) else None)
        _g = 0
        _g1 = nv
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            this1 = [None]*3
            this2 = this1
            this2[0] = 0
            this2[1] = 0
            this2[2] = 0
            c1c2 = this2
            apparentridges_Mesh.diagonalizeCurv((self.pdir1[i] if i >= 0 and i < len(self.pdir1) else None),(self.pdir2[i] if i >= 0 and i < len(self.pdir2) else None),(self.curv1[i] if i >= 0 and i < len(self.curv1) else None),(curv12[i] if i >= 0 and i < len(curv12) else None),(self.curv2[i] if i >= 0 and i < len(self.curv2) else None),(self.normals[i] if i >= 0 and i < len(self.normals) else None),(self.pdir1[i] if i >= 0 and i < len(self.pdir1) else None),(self.pdir2[i] if i >= 0 and i < len(self.pdir2) else None),c1c2)
            python_internal_ArrayImpl._set(self.curv1, i, c1c2[0])
            python_internal_ArrayImpl._set(self.curv2, i, c1c2[1])

    def computeVertViewDepCurv(self,i,ndotv,u2,uv,v2):
        sectheta_minus1 = ((1.0 / Reflect.field(Math,"fabs")(ndotv)) - 1.0)
        Q11 = ((self.curv1[i] if i >= 0 and i < len(self.curv1) else None) * ((1.0 + ((sectheta_minus1 * u2)))))
        Q12 = ((self.curv1[i] if i >= 0 and i < len(self.curv1) else None) * ((sectheta_minus1 * uv)))
        Q21 = ((self.curv2[i] if i >= 0 and i < len(self.curv2) else None) * ((sectheta_minus1 * uv)))
        Q22 = ((self.curv2[i] if i >= 0 and i < len(self.curv2) else None) * ((1.0 + ((sectheta_minus1 * v2)))))
        QTQ1 = ((Q11 * Q11) + ((Q21 * Q21)))
        QTQ12 = ((Q11 * Q12) + ((Q21 * Q22)))
        QTQ2 = ((Q12 * Q12) + ((Q22 * Q22)))
        return apparentridges_Util.largestEig2x2(QTQ1,QTQ12,QTQ2)

    def computeVertDt1q1(self,i,ndotv,t1q1):
        v0 = (self.vertices[i] if i >= 0 and i < len(self.vertices) else None)
        this_viewdep_curv = (t1q1[i] if i >= 0 and i < len(t1q1) else None)[2]
        this1 = (self.pdir1[i] if i >= 0 and i < len(self.pdir1) else None)
        rhs = (t1q1[i] if i >= 0 and i < len(t1q1) else None)[0]
        _x = (this1[0] * rhs)
        _y = (this1[1] * rhs)
        _z = (this1[2] * rhs)
        this1 = [None]*3
        this2 = this1
        this2[0] = _x
        this2[1] = _y
        this2[2] = _z
        this1 = this2
        this2 = (self.pdir2[i] if i >= 0 and i < len(self.pdir2) else None)
        rhs = (t1q1[i] if i >= 0 and i < len(t1q1) else None)[1]
        _x = (this2[0] * rhs)
        _y = (this2[1] * rhs)
        _z = (this2[2] * rhs)
        this2 = [None]*3
        this3 = this2
        this3[0] = _x
        this3[1] = _y
        this3[2] = _z
        rhs = this3
        _x = (this1[0] + rhs[0])
        _y = (this1[1] + rhs[1])
        _z = (this1[2] + rhs[2])
        this1 = [None]*3
        this2 = this1
        this2[0] = _x
        this2[1] = _y
        this2[2] = _z
        world_t1 = this2
        v1 = (self.normals[i] if i >= 0 and i < len(self.normals) else None)
        _x = ((v1[1] * world_t1[2]) - ((v1[2] * world_t1[1])))
        _y = ((v1[2] * world_t1[0]) - ((v1[0] * world_t1[2])))
        _z = ((v1[0] * world_t1[1]) - ((v1[1] * world_t1[0])))
        this1 = [None]*3
        this2 = this1
        this2[0] = _x
        this2[1] = _y
        this2[2] = _z
        world_t2 = this2
        v0_dot_t2 = (((v0[0] * world_t2[0]) + ((v0[1] * world_t2[1]))) + ((v0[2] * world_t2[2])))
        Dt1q1 = 0.0
        n = 0
        naf = len((self.adjacentFaces[i] if i >= 0 and i < len(self.adjacentFaces) else None))
        _g = 0
        _g1 = naf
        while (_g < _g1):
            j = _g
            _g = (_g + 1)
            f = python_internal_ArrayImpl._get((self.adjacentFaces[i] if i >= 0 and i < len(self.adjacentFaces) else None), j)
            this1 = (self.faces[f] if f >= 0 and f < len(self.faces) else None)
            ind = (0 if ((this1[0] == i)) else (1 if ((this1[1] == i)) else (2 if ((this1[2] == i)) else -1)))
            i1 = (self.faces[f] if f >= 0 and f < len(self.faces) else None)[((ind + 1) if ((ind < 2)) else (ind - 2))]
            i2 = (self.faces[f] if f >= 0 and f < len(self.faces) else None)[((ind - 1) if ((ind > 0)) else (ind + 2))]
            v1 = (self.vertices[i1] if i1 >= 0 and i1 < len(self.vertices) else None)
            v2 = (self.vertices[i2] if i2 >= 0 and i2 < len(self.vertices) else None)
            v1_dot_t2 = (((v1[0] * world_t2[0]) + ((v1[1] * world_t2[1]))) + ((v1[2] * world_t2[2])))
            v2_dot_t2 = (((v2[0] * world_t2[0]) + ((v2[1] * world_t2[1]))) + ((v2[2] * world_t2[2])))
            w1 = (((v2_dot_t2 - v0_dot_t2)) / ((v2_dot_t2 - v1_dot_t2)))
            if ((w1 < 0.0) or ((w1 >= 1.0))):
                continue
            w2 = (1.0 - w1)
            _x = (v1[0] * w1)
            _y = (v1[1] * w1)
            _z = (v1[2] * w1)
            this2 = [None]*3
            this3 = this2
            this3[0] = _x
            this3[1] = _y
            this3[2] = _z
            this4 = this3
            _x1 = (v2[0] * w2)
            _y1 = (v2[1] * w2)
            _z1 = (v2[2] * w2)
            this5 = [None]*3
            this6 = this5
            this6[0] = _x1
            this6[1] = _y1
            this6[2] = _z1
            rhs = this6
            _x2 = (this4[0] + rhs[0])
            _y2 = (this4[1] + rhs[1])
            _z2 = (this4[2] + rhs[2])
            this7 = [None]*3
            this8 = this7
            this8[0] = _x2
            this8[1] = _y2
            this8[2] = _z2
            p = this8
            interp_viewdep_curv = ((w1 * (t1q1[i1] if i1 >= 0 and i1 < len(t1q1) else None)[2]) + ((w2 * (t1q1[i2] if i2 >= 0 and i2 < len(t1q1) else None)[2])))
            _x3 = (p[0] - v0[0])
            _y3 = (p[1] - v0[1])
            _z3 = (p[2] - v0[2])
            this9 = [None]*3
            this10 = this9
            this10[0] = _x3
            this10[1] = _y3
            this10[2] = _z3
            v11 = this10
            proj_dist = (((v11[0] * world_t1[0]) + ((v11[1] * world_t1[1]))) + ((v11[2] * world_t1[2])))
            proj_dist = (proj_dist * Reflect.field(Math,"fabs")(ndotv))
            Dt1q1 = (Dt1q1 + ((((interp_viewdep_curv - this_viewdep_curv)) / proj_dist)))
            n = (n + 1)
            if (n == 2):
                Dt1q1 = (Dt1q1 * 0.5)
                return Dt1q1
        return Dt1q1

    def segmentApparentRidge(self,v0,v1,v2,emax0,emax1,emax2,kmax0,kmax1,kmax2,tmax0,tmax1,tmax2,thresh,to_center,do_test):
        w10 = (Reflect.field(Math,"fabs")(emax0) / ((Reflect.field(Math,"fabs")(emax0) + Reflect.field(Math,"fabs")(emax1))))
        w01 = (1.0 - w10)
        this1 = (self.vertices[v0] if v0 >= 0 and v0 < len(self.vertices) else None)
        _x = (this1[0] * w01)
        _y = (this1[1] * w01)
        _z = (this1[2] * w01)
        this1 = [None]*3
        this2 = this1
        this2[0] = _x
        this2[1] = _y
        this2[2] = _z
        this1 = this2
        this2 = (self.vertices[v1] if v1 >= 0 and v1 < len(self.vertices) else None)
        _x = (this2[0] * w10)
        _y = (this2[1] * w10)
        _z = (this2[2] * w10)
        this2 = [None]*3
        this3 = this2
        this3[0] = _x
        this3[1] = _y
        this3[2] = _z
        rhs = this3
        _x = (this1[0] + rhs[0])
        _y = (this1[1] + rhs[1])
        _z = (this1[2] + rhs[2])
        this1 = [None]*3
        this2 = this1
        this2[0] = _x
        this2[1] = _y
        this2[2] = _z
        p01 = this2
        k01 = Reflect.field(Math,"fabs")(((w01 * kmax0) + ((w10 * kmax1))))
        p12 = None
        k12 = None
        if to_center:
            this1 = (self.vertices[v0] if v0 >= 0 and v0 < len(self.vertices) else None)
            rhs = (self.vertices[v1] if v1 >= 0 and v1 < len(self.vertices) else None)
            _x = (this1[0] + rhs[0])
            _y = (this1[1] + rhs[1])
            _z = (this1[2] + rhs[2])
            this1 = [None]*3
            this2 = this1
            this2[0] = _x
            this2[1] = _y
            this2[2] = _z
            this1 = this2
            rhs = (self.vertices[v2] if v2 >= 0 and v2 < len(self.vertices) else None)
            _x = (this1[0] + rhs[0])
            _y = (this1[1] + rhs[1])
            _z = (this1[2] + rhs[2])
            this1 = [None]*3
            this2 = this1
            this2[0] = _x
            this2[1] = _y
            this2[2] = _z
            this1 = this2
            _x = (this1[0] * 0.333333333333333315)
            _y = (this1[1] * 0.333333333333333315)
            _z = (this1[2] * 0.333333333333333315)
            this1 = [None]*3
            this2 = this1
            this2[0] = _x
            this2[1] = _y
            this2[2] = _z
            p12 = this2
            k12 = (Reflect.field(Math,"fabs")(((kmax0 + kmax1) + kmax2)) / 3.0)
        else:
            w21 = (Reflect.field(Math,"fabs")(emax1) / ((Reflect.field(Math,"fabs")(emax1) + Reflect.field(Math,"fabs")(emax2))))
            w12 = (1.0 - w21)
            this1 = (self.vertices[v1] if v1 >= 0 and v1 < len(self.vertices) else None)
            _x = (this1[0] * w12)
            _y = (this1[1] * w12)
            _z = (this1[2] * w12)
            this1 = [None]*3
            this2 = this1
            this2[0] = _x
            this2[1] = _y
            this2[2] = _z
            this1 = this2
            this2 = (self.vertices[v2] if v2 >= 0 and v2 < len(self.vertices) else None)
            _x = (this2[0] * w21)
            _y = (this2[1] * w21)
            _z = (this2[2] * w21)
            this2 = [None]*3
            this3 = this2
            this3[0] = _x
            this3[1] = _y
            this3[2] = _z
            rhs = this3
            _x = (this1[0] + rhs[0])
            _y = (this1[1] + rhs[1])
            _z = (this1[2] + rhs[2])
            this1 = [None]*3
            this2 = this1
            this2[0] = _x
            this2[1] = _y
            this2[2] = _z
            p12 = this2
            k12 = Reflect.field(Math,"fabs")(((w12 * kmax1) + ((w21 * kmax2))))
        k01 = (k01 - thresh)
        if (k01 < 0.0):
            k01 = 0.0
        k12 = (k12 - thresh)
        if (k12 < 0.0):
            k12 = 0.0
        if ((k01 == 0.0) and ((k12 == 0.0))):
            return None
        if do_test:
            v01 = (self.vertices[v0] if v0 >= 0 and v0 < len(self.vertices) else None)
            v11 = (self.vertices[v1] if v1 >= 0 and v1 < len(self.vertices) else None)
            v21 = (self.vertices[v2] if v2 >= 0 and v2 < len(self.vertices) else None)
            _x = (v11[0] - v01[0])
            _y = (v11[1] - v01[1])
            _z = (v11[2] - v01[2])
            this1 = [None]*3
            this2 = this1
            this2[0] = _x
            this2[1] = _y
            this2[2] = _z
            v1 = this2
            _x = (v21[0] - v01[0])
            _y = (v21[1] - v01[1])
            _z = (v21[2] - v01[2])
            this1 = [None]*3
            this2 = this1
            this2[0] = _x
            this2[1] = _y
            this2[2] = _z
            v2 = this2
            _x = ((v1[1] * v2[2]) - ((v1[2] * v2[1])))
            _y = ((v1[2] * v2[0]) - ((v1[0] * v2[2])))
            _z = ((v1[0] * v2[1]) - ((v1[1] * v2[0])))
            this1 = [None]*3
            this2 = this1
            this2[0] = _x
            this2[1] = _y
            this2[2] = _z
            this1 = this2
            _x = (this1[0] * 0.5)
            _y = (this1[1] * 0.5)
            _z = (this1[2] * 0.5)
            this1 = [None]*3
            this2 = this1
            this2[0] = _x
            this2[1] = _y
            this2[2] = _z
            v1 = this2
            _x = (p01[0] - p12[0])
            _y = (p01[1] - p12[1])
            _z = (p01[2] - p12[2])
            this1 = [None]*3
            this2 = this1
            this2[0] = _x
            this2[1] = _y
            this2[2] = _z
            v2 = this2
            _x = ((v1[1] * v2[2]) - ((v1[2] * v2[1])))
            _y = ((v1[2] * v2[0]) - ((v1[0] * v2[2])))
            _z = ((v1[0] * v2[1]) - ((v1[1] * v2[0])))
            this1 = [None]*3
            this2 = this1
            this2[0] = _x
            this2[1] = _y
            this2[2] = _z
            perp = this2
            if ((((((tmax0[0] * perp[0]) + ((tmax0[1] * perp[1]))) + ((tmax0[2] * perp[2]))) <= 0.0) or (((((tmax1[0] * perp[0]) + ((tmax1[1] * perp[1]))) + ((tmax1[2] * perp[2]))) >= 0.0))) or (((((tmax2[0] * perp[0]) + ((tmax2[1] * perp[1]))) + ((tmax2[2] * perp[2]))) <= 0.0))):
                return None
        k01 = (k01 / ((k01 + thresh)))
        k12 = (k12 / ((k12 + thresh)))
        return apparentridges_Ridge(p01,k01,p12,k12)

    def facesApparentRidges(self,ndotv,t1q1,Dt1q1,do_bfcull,do_test,thresh):
        ridges = []
        _g = 0
        _g1 = self.faces
        while (_g < len(_g1)):
            f = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            v0 = f[0]
            v1 = f[1]
            v2 = f[2]
            if (((do_bfcull and (((ndotv[v0] if v0 >= 0 and v0 < len(ndotv) else None) <= 0))) and (((ndotv[v1] if v1 >= 0 and v1 < len(ndotv) else None) <= 0))) and (((ndotv[v2] if v2 >= 0 and v2 < len(ndotv) else None) <= 0))):
                continue
            kmax0 = (t1q1[v0] if v0 >= 0 and v0 < len(t1q1) else None)[2]
            kmax1 = (t1q1[v1] if v1 >= 0 and v1 < len(t1q1) else None)[2]
            kmax2 = (t1q1[v2] if v2 >= 0 and v2 < len(t1q1) else None)[2]
            if (((kmax0 <= thresh) and ((kmax1 <= thresh))) and ((kmax2 <= thresh))):
                continue
            emax0 = (Dt1q1[v0] if v0 >= 0 and v0 < len(Dt1q1) else None)
            emax1 = (Dt1q1[v1] if v1 >= 0 and v1 < len(Dt1q1) else None)
            emax2 = (Dt1q1[v2] if v2 >= 0 and v2 < len(Dt1q1) else None)
            this1 = (self.pdir1[v0] if v0 >= 0 and v0 < len(self.pdir1) else None)
            rhs = (t1q1[v0] if v0 >= 0 and v0 < len(t1q1) else None)[0]
            _x = (this1[0] * rhs)
            _y = (this1[1] * rhs)
            _z = (this1[2] * rhs)
            this2 = [None]*3
            this3 = this2
            this3[0] = _x
            this3[1] = _y
            this3[2] = _z
            this4 = this3
            this5 = (self.pdir2[v0] if v0 >= 0 and v0 < len(self.pdir2) else None)
            rhs1 = (t1q1[v0] if v0 >= 0 and v0 < len(t1q1) else None)[1]
            _x1 = (this5[0] * rhs1)
            _y1 = (this5[1] * rhs1)
            _z1 = (this5[2] * rhs1)
            this6 = [None]*3
            this7 = this6
            this7[0] = _x1
            this7[1] = _y1
            this7[2] = _z1
            rhs2 = this7
            _x2 = (this4[0] + rhs2[0])
            _y2 = (this4[1] + rhs2[1])
            _z2 = (this4[2] + rhs2[2])
            this8 = [None]*3
            this9 = this8
            this9[0] = _x2
            this9[1] = _y2
            this9[2] = _z2
            world_t1_0 = this9
            this10 = (self.pdir1[v1] if v1 >= 0 and v1 < len(self.pdir1) else None)
            rhs3 = (t1q1[v1] if v1 >= 0 and v1 < len(t1q1) else None)[0]
            _x3 = (this10[0] * rhs3)
            _y3 = (this10[1] * rhs3)
            _z3 = (this10[2] * rhs3)
            this11 = [None]*3
            this12 = this11
            this12[0] = _x3
            this12[1] = _y3
            this12[2] = _z3
            this13 = this12
            this14 = (self.pdir2[v1] if v1 >= 0 and v1 < len(self.pdir2) else None)
            rhs4 = (t1q1[v1] if v1 >= 0 and v1 < len(t1q1) else None)[1]
            _x4 = (this14[0] * rhs4)
            _y4 = (this14[1] * rhs4)
            _z4 = (this14[2] * rhs4)
            this15 = [None]*3
            this16 = this15
            this16[0] = _x4
            this16[1] = _y4
            this16[2] = _z4
            rhs5 = this16
            _x5 = (this13[0] + rhs5[0])
            _y5 = (this13[1] + rhs5[1])
            _z5 = (this13[2] + rhs5[2])
            this17 = [None]*3
            this18 = this17
            this18[0] = _x5
            this18[1] = _y5
            this18[2] = _z5
            world_t1_1 = this18
            this19 = (self.pdir1[v2] if v2 >= 0 and v2 < len(self.pdir1) else None)
            rhs6 = (t1q1[v2] if v2 >= 0 and v2 < len(t1q1) else None)[0]
            _x6 = (this19[0] * rhs6)
            _y6 = (this19[1] * rhs6)
            _z6 = (this19[2] * rhs6)
            this20 = [None]*3
            this21 = this20
            this21[0] = _x6
            this21[1] = _y6
            this21[2] = _z6
            this22 = this21
            this23 = (self.pdir2[v2] if v2 >= 0 and v2 < len(self.pdir2) else None)
            rhs7 = (t1q1[v2] if v2 >= 0 and v2 < len(t1q1) else None)[1]
            _x7 = (this23[0] * rhs7)
            _y7 = (this23[1] * rhs7)
            _z7 = (this23[2] * rhs7)
            this24 = [None]*3
            this25 = this24
            this25[0] = _x7
            this25[1] = _y7
            this25[2] = _z7
            rhs8 = this25
            _x8 = (this22[0] + rhs8[0])
            _y8 = (this22[1] + rhs8[1])
            _z8 = (this22[2] + rhs8[2])
            this26 = [None]*3
            this27 = this26
            this27[0] = _x8
            this27[1] = _y8
            this27[2] = _z8
            world_t1_2 = this27
            rhs9 = (Dt1q1[v0] if v0 >= 0 and v0 < len(Dt1q1) else None)
            _x9 = (world_t1_0[0] * rhs9)
            _y9 = (world_t1_0[1] * rhs9)
            _z9 = (world_t1_0[2] * rhs9)
            this28 = [None]*3
            this29 = this28
            this29[0] = _x9
            this29[1] = _y9
            this29[2] = _z9
            tmax0 = this29
            rhs10 = (Dt1q1[v1] if v1 >= 0 and v1 < len(Dt1q1) else None)
            _x10 = (world_t1_1[0] * rhs10)
            _y10 = (world_t1_1[1] * rhs10)
            _z10 = (world_t1_1[2] * rhs10)
            this30 = [None]*3
            this31 = this30
            this31[0] = _x10
            this31[1] = _y10
            this31[2] = _z10
            tmax1 = this31
            rhs11 = (Dt1q1[v2] if v2 >= 0 and v2 < len(Dt1q1) else None)
            _x11 = (world_t1_2[0] * rhs11)
            _y11 = (world_t1_2[1] * rhs11)
            _z11 = (world_t1_2[2] * rhs11)
            this32 = [None]*3
            this33 = this32
            this33[0] = _x11
            this33[1] = _y11
            this33[2] = _z11
            tmax2 = this33
            z01 = ((((tmax0[0] * tmax1[0]) + ((tmax0[1] * tmax1[1]))) + ((tmax0[2] * tmax1[2]))) <= 0.0)
            z12 = ((((tmax1[0] * tmax2[0]) + ((tmax1[1] * tmax2[1]))) + ((tmax1[2] * tmax2[2]))) <= 0.0)
            z20 = ((((tmax2[0] * tmax0[0]) + ((tmax2[1] * tmax0[1]))) + ((tmax2[2] * tmax0[2]))) <= 0.0)
            if (((((1 if z01 else 0)) + ((1 if z12 else 0))) + ((1 if z20 else 0))) < 2):
                continue
            if (not z01):
                r = self.segmentApparentRidge(v1,v2,v0,emax1,emax2,emax0,kmax1,kmax2,kmax0,tmax1,tmax2,tmax0,thresh,False,do_test)
                if (r is not None):
                    ridges.append(r)
            elif (not z12):
                r1 = self.segmentApparentRidge(v2,v0,v1,emax2,emax0,emax1,kmax2,kmax0,kmax1,tmax2,tmax0,tmax1,thresh,False,do_test)
                if (r1 is not None):
                    ridges.append(r1)
            elif (not z20):
                r2 = self.segmentApparentRidge(v0,v1,v2,emax0,emax1,emax2,kmax0,kmax1,kmax2,tmax0,tmax1,tmax2,thresh,False,do_test)
                if (r2 is not None):
                    ridges.append(r2)
            else:
                r0 = self.segmentApparentRidge(v1,v2,v0,emax1,emax2,emax0,kmax1,kmax2,kmax0,tmax1,tmax2,tmax0,thresh,True,do_test)
                r11 = self.segmentApparentRidge(v2,v0,v1,emax2,emax0,emax1,kmax2,kmax0,kmax1,tmax2,tmax0,tmax1,thresh,True,do_test)
                r21 = self.segmentApparentRidge(v0,v1,v2,emax0,emax1,emax2,kmax0,kmax1,kmax2,tmax0,tmax1,tmax2,thresh,True,do_test)
                if (r0 is not None):
                    ridges.append(r0)
                if (r11 is not None):
                    ridges.append(r11)
                if (r21 is not None):
                    ridges.append(r21)
        return ridges

    def apparentRidges(self,eye,thresh):
        nv = len(self.vertices)
        _g = 0
        _g1 = nv
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            rhs = (self.vertices[i] if i >= 0 and i < len(self.vertices) else None)
            _x = (eye[0] - rhs[0])
            _y = (eye[1] - rhs[1])
            _z = (eye[2] - rhs[2])
            this1 = [None]*3
            this2 = this1
            this2[0] = _x
            this2[1] = _y
            this2[2] = _z
            viewdir = this2
            v = (((viewdir[0] * viewdir[0]) + ((viewdir[1] * viewdir[1]))) + ((viewdir[2] * viewdir[2])))
            rlv = (1.0 / ((Math.NaN if ((v < 0)) else python_lib_Math.sqrt(v))))
            _x1 = (viewdir[0] * rlv)
            _y1 = (viewdir[1] * rlv)
            _z1 = (viewdir[2] * rlv)
            this3 = [None]*3
            this4 = this3
            this4[0] = _x1
            this4[1] = _y1
            this4[2] = _z1
            viewdir = this4
            v2 = (self.normals[i] if i >= 0 and i < len(self.normals) else None)
            python_internal_ArrayImpl._set(self.ndotv, i, (((viewdir[0] * v2[0]) + ((viewdir[1] * v2[1]))) + ((viewdir[2] * v2[2]))))
            v21 = (self.pdir1[i] if i >= 0 and i < len(self.pdir1) else None)
            u = (((viewdir[0] * v21[0]) + ((viewdir[1] * v21[1]))) + ((viewdir[2] * v21[2])))
            u2 = (u * u)
            v22 = (self.pdir2[i] if i >= 0 and i < len(self.pdir2) else None)
            v1 = (((viewdir[0] * v22[0]) + ((viewdir[1] * v22[1]))) + ((viewdir[2] * v22[2])))
            v23 = (v1 * v1)
            csc2theta = (1.0 / ((u2 + v23)))
            python_internal_ArrayImpl._set(self.t1q1, i, self.computeVertViewDepCurv(i,(self.ndotv[i] if i >= 0 and i < len(self.ndotv) else None),(u2 * csc2theta),((u * v1) * csc2theta),(v23 * csc2theta)))
        _g = 0
        _g1 = nv
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            python_internal_ArrayImpl._set(self.Dt1q1, i, self.computeVertDt1q1(i,(self.ndotv[i] if i >= 0 and i < len(self.ndotv) else None),self.t1q1))
        x = self.featureSize
        return self.facesApparentRidges(self.ndotv,self.t1q1,self.Dt1q1,False,True,(thresh / ((x * x))))

    def computeBVHTrivial(self):
        self.bvh = apparentridges_BVHTree(self,len(self.faces))
        self.bvh.build()

    def computeBVH(self):
        self.bvh = apparentridges_BVHTree(self)
        self.bvh.build()

    def visible(self,eye,p,tolerance = None):
        if (tolerance is None):
            tolerance = 2
        v = len(self.faces)
        epsilon = ((self.bsphere.r / ((Math.NaN if ((v < 0)) else python_lib_Math.sqrt(v)))) * tolerance)
        r_tmin = None
        r_tmax = None
        r_o = None
        r_d = None
        _x = (p[0] - eye[0])
        _y = (p[1] - eye[1])
        _z = (p[2] - eye[2])
        this1 = [None]*3
        this2 = this1
        this2[0] = _x
        this2[1] = _y
        this2[2] = _z
        x = this2
        _x = x[0]
        _y = x[1]
        _z = x[2]
        this1 = [None]*3
        this2 = this1
        this2[0] = _x
        this2[1] = _y
        this2[2] = _z
        r_d = this2
        this1 = r_d
        v = (((this1[0] * this1[0]) + ((this1[1] * this1[1]))) + ((this1[2] * this1[2])))
        l = (Math.NaN if ((v < 0)) else python_lib_Math.sqrt(v))
        if (l > 0):
            l = (1 / l)
            _g = this1
            v = (_g[0] * l)
            _g[0] = v
            _g = this1
            v = (_g[1] * l)
            _g[1] = v
            _g = this1
            v = (_g[2] * l)
            _g[2] = v
        else:
            this1[0] = 0
            this1[1] = 0
            this1[2] = 1
        r_o = eye
        r_tmin = 0
        v = (((x[0] * x[0]) + ((x[1] * x[1]))) + ((x[2] * x[2])))
        r_tmax = (((Math.NaN if ((v < 0)) else python_lib_Math.sqrt(v))) - epsilon)
        bvh = self.bvh
        hitNode = None
        def _hx_local_0(node):
            if ((node.left is None) and ((node.right is None))):
                tmin = Math.POSITIVE_INFINITY
                closest = None
                _g = node.begin
                _g1 = node.end
                while (_g < _g1):
                    i = _g
                    _g = (_g + 1)
                    p0 = python_internal_ArrayImpl._get(bvh.mesh.vertices, (bvh.faces[i] if i >= 0 and i < len(bvh.faces) else None)[0])
                    p1 = python_internal_ArrayImpl._get(bvh.mesh.vertices, (bvh.faces[i] if i >= 0 and i < len(bvh.faces) else None)[1])
                    p2 = python_internal_ArrayImpl._get(bvh.mesh.vertices, (bvh.faces[i] if i >= 0 and i < len(bvh.faces) else None)[2])
                    _x = (p1[0] - p0[0])
                    _y = (p1[1] - p0[1])
                    _z = (p1[2] - p0[2])
                    this1 = [None]*3
                    this2 = this1
                    this2[0] = _x
                    this2[1] = _y
                    this2[2] = _z
                    e1 = this2
                    _x1 = (p2[0] - p0[0])
                    _y1 = (p2[1] - p0[1])
                    _z1 = (p2[2] - p0[2])
                    this3 = [None]*3
                    this4 = this3
                    this4[0] = _x1
                    this4[1] = _y1
                    this4[2] = _z1
                    e2 = this4
                    this5 = r_o
                    _x2 = (this5[0] - p0[0])
                    _y2 = (this5[1] - p0[1])
                    _z2 = (this5[2] - p0[2])
                    this6 = [None]*3
                    this7 = this6
                    this7[0] = _x2
                    this7[1] = _y2
                    this7[2] = _z2
                    s = this7
                    this8 = r_d
                    _x3 = (this8[0] * -1.0)
                    _y3 = (this8[1] * -1.0)
                    _z3 = (this8[2] * -1.0)
                    this9 = [None]*3
                    this10 = this9
                    this10[0] = _x3
                    this10[1] = _y3
                    this10[2] = _z3
                    _d = this10
                    _x4 = ((e1[1] * e2[2]) - ((e1[2] * e2[1])))
                    _y4 = ((e1[2] * e2[0]) - ((e1[0] * e2[2])))
                    _z4 = ((e1[0] * e2[1]) - ((e1[1] * e2[0])))
                    this11 = [None]*3
                    this12 = this11
                    this12[0] = _x4
                    this12[1] = _y4
                    this12[2] = _z4
                    v1 = this12
                    denom = (((v1[0] * _d[0]) + ((v1[1] * _d[1]))) + ((v1[2] * _d[2])))
                    h = None
                    if (denom == 0):
                        h = None
                    else:
                        _x5 = ((s[1] * e2[2]) - ((s[2] * e2[1])))
                        _y5 = ((s[2] * e2[0]) - ((s[0] * e2[2])))
                        _z5 = ((s[0] * e2[1]) - ((s[1] * e2[0])))
                        this13 = [None]*3
                        this14 = this13
                        this14[0] = _x5
                        this14[1] = _y5
                        this14[2] = _z5
                        v11 = this14
                        _x6 = (((v11[0] * _d[0]) + ((v11[1] * _d[1]))) + ((v11[2] * _d[2])))
                        _x7 = ((e1[1] * s[2]) - ((e1[2] * s[1])))
                        _y6 = ((e1[2] * s[0]) - ((e1[0] * s[2])))
                        _z6 = ((e1[0] * s[1]) - ((e1[1] * s[0])))
                        this15 = [None]*3
                        this16 = this15
                        this16[0] = _x7
                        this16[1] = _y6
                        this16[2] = _z6
                        v12 = this16
                        _y7 = (((v12[0] * _d[0]) + ((v12[1] * _d[1]))) + ((v12[2] * _d[2])))
                        _x8 = ((e1[1] * e2[2]) - ((e1[2] * e2[1])))
                        _y8 = ((e1[2] * e2[0]) - ((e1[0] * e2[2])))
                        _z7 = ((e1[0] * e2[1]) - ((e1[1] * e2[0])))
                        this17 = [None]*3
                        this18 = this17
                        this18[0] = _x8
                        this18[1] = _y8
                        this18[2] = _z7
                        v13 = this18
                        _z8 = (((v13[0] * s[0]) + ((v13[1] * s[1]))) + ((v13[2] * s[2])))
                        this19 = [None]*3
                        this20 = this19
                        this20[0] = _x6
                        this20[1] = _y7
                        this20[2] = _z8
                        this21 = this20
                        rhs = (1 / denom)
                        _x9 = (this21[0] * rhs)
                        _y9 = (this21[1] * rhs)
                        _z9 = (this21[2] * rhs)
                        this22 = [None]*3
                        this23 = this22
                        this23[0] = _x9
                        this23[1] = _y9
                        this23[2] = _z9
                        uvt = this23
                        u = uvt[0]
                        v = uvt[1]
                        t = uvt[2]
                        if (((((u < 0) or ((v < 0))) or ((((1 - u) - v) < 0))) or ((t < r_tmin))) or ((t > r_tmax))):
                            h = None
                        else:
                            h1 = apparentridges_RayHit(t)
                            h1.u = u
                            h1.v = v
                            h = h1
                    if (h is not None):
                        h.face = (bvh.faces[i] if i >= 0 and i < len(bvh.faces) else None)
                        if (tmin > h.t):
                            tmin = h.t
                            closest = h
                return closest
            bb = node.left.bbox
            tx1 = (((bb.min[0] - r_o[0])) / r_d[0])
            tx2 = (((bb.max[0] - r_o[0])) / r_d[0])
            ty1 = (((bb.min[1] - r_o[1])) / r_d[1])
            ty2 = (((bb.max[1] - r_o[1])) / r_d[1])
            tz1 = (((bb.min[2] - r_o[2])) / r_d[2])
            tz2 = (((bb.max[2] - r_o[2])) / r_d[2])
            a = (tx1 if (python_lib_Math.isnan(tx1)) else (tx2 if (python_lib_Math.isnan(tx2)) else min(tx1,tx2)))
            b = (ty1 if (python_lib_Math.isnan(ty1)) else (ty2 if (python_lib_Math.isnan(ty2)) else min(ty1,ty2)))
            a1 = (a if (python_lib_Math.isnan(a)) else (b if (python_lib_Math.isnan(b)) else max(a,b)))
            b = (tz1 if (python_lib_Math.isnan(tz1)) else (tz2 if (python_lib_Math.isnan(tz2)) else min(tz1,tz2)))
            t1 = (a1 if (python_lib_Math.isnan(a1)) else (b if (python_lib_Math.isnan(b)) else max(a1,b)))
            a = (tx1 if (python_lib_Math.isnan(tx1)) else (tx2 if (python_lib_Math.isnan(tx2)) else max(tx1,tx2)))
            b = (ty1 if (python_lib_Math.isnan(ty1)) else (ty2 if (python_lib_Math.isnan(ty2)) else max(ty1,ty2)))
            a1 = (a if (python_lib_Math.isnan(a)) else (b if (python_lib_Math.isnan(b)) else min(a,b)))
            b = (tz1 if (python_lib_Math.isnan(tz1)) else (tz2 if (python_lib_Math.isnan(tz2)) else max(tz1,tz2)))
            t2 = (a1 if (python_lib_Math.isnan(a1)) else (b if (python_lib_Math.isnan(b)) else min(a1,b)))
            hitL = None
            if ((t2 - t1) < 0):
                hitL = None
            elif ((t1 > r_tmax) or ((t2 < r_tmin))):
                hitL = None
            else:
                h = apparentridges_RayHit(t1)
                h.t2 = t2
                hitL = h
            bb = node.right.bbox
            tx1 = (((bb.min[0] - r_o[0])) / r_d[0])
            tx2 = (((bb.max[0] - r_o[0])) / r_d[0])
            ty1 = (((bb.min[1] - r_o[1])) / r_d[1])
            ty2 = (((bb.max[1] - r_o[1])) / r_d[1])
            tz1 = (((bb.min[2] - r_o[2])) / r_d[2])
            tz2 = (((bb.max[2] - r_o[2])) / r_d[2])
            a = (tx1 if (python_lib_Math.isnan(tx1)) else (tx2 if (python_lib_Math.isnan(tx2)) else min(tx1,tx2)))
            b = (ty1 if (python_lib_Math.isnan(ty1)) else (ty2 if (python_lib_Math.isnan(ty2)) else min(ty1,ty2)))
            a1 = (a if (python_lib_Math.isnan(a)) else (b if (python_lib_Math.isnan(b)) else max(a,b)))
            b = (tz1 if (python_lib_Math.isnan(tz1)) else (tz2 if (python_lib_Math.isnan(tz2)) else min(tz1,tz2)))
            t1 = (a1 if (python_lib_Math.isnan(a1)) else (b if (python_lib_Math.isnan(b)) else max(a1,b)))
            a = (tx1 if (python_lib_Math.isnan(tx1)) else (tx2 if (python_lib_Math.isnan(tx2)) else max(tx1,tx2)))
            b = (ty1 if (python_lib_Math.isnan(ty1)) else (ty2 if (python_lib_Math.isnan(ty2)) else max(ty1,ty2)))
            a1 = (a if (python_lib_Math.isnan(a)) else (b if (python_lib_Math.isnan(b)) else min(a,b)))
            b = (tz1 if (python_lib_Math.isnan(tz1)) else (tz2 if (python_lib_Math.isnan(tz2)) else max(tz1,tz2)))
            t2 = (a1 if (python_lib_Math.isnan(a1)) else (b if (python_lib_Math.isnan(b)) else min(a1,b)))
            hitR = None
            if ((t2 - t1) < 0):
                hitR = None
            elif ((t1 > r_tmax) or ((t2 < r_tmin))):
                hitR = None
            else:
                h = apparentridges_RayHit(t1)
                h.t2 = t2
                hitR = h
            if ((hitL is not None) and ((hitR is None))):
                return hitNode(node.left)
            elif ((hitL is None) and ((hitR is not None))):
                return hitNode(node.right)
            elif ((hitL is None) and ((hitR is None))):
                return None
            first = None
            second = None
            if (hitL.t < hitR.t):
                first = node.left
                second = node.right
            else:
                first = node.right
                second = node.left
            h = hitNode(first)
            hitNode1 = None
            if (h is not None):
                a = hitL.t
                b = hitR.t
                hitNode1 = (h.t >= ((a if (python_lib_Math.isnan(a)) else (b if (python_lib_Math.isnan(b)) else max(a,b)))))
            else:
                hitNode1 = True
            if hitNode1:
                h2 = hitNode(second)
                if (h2 is not None):
                    if ((h is None) or ((h2.t < h.t))):
                        return h2
            return h
        hitNode = _hx_local_0
        h = hitNode(bvh.root)
        return (h is None)

    @staticmethod
    def rotCoordSys(old_u,old_v,new_norm,new_u,new_v):
        v = old_u[0]
        new_u[0] = v
        v = old_u[1]
        new_u[1] = v
        v = old_u[2]
        new_u[2] = v
        v = old_v[0]
        new_v[0] = v
        v = old_v[1]
        new_v[1] = v
        v = old_v[2]
        new_v[2] = v
        _x = ((old_u[1] * old_v[2]) - ((old_u[2] * old_v[1])))
        _y = ((old_u[2] * old_v[0]) - ((old_u[0] * old_v[2])))
        _z = ((old_u[0] * old_v[1]) - ((old_u[1] * old_v[0])))
        this1 = [None]*3
        this2 = this1
        this2[0] = _x
        this2[1] = _y
        this2[2] = _z
        old_norm = this2
        ndot = (((old_norm[0] * new_norm[0]) + ((old_norm[1] * new_norm[1]))) + ((old_norm[2] * new_norm[2])))
        if (ndot <= -1):
            _g = new_u
            v = (_g[0] * -1)
            _g[0] = v
            _g = new_u
            v = (_g[1] * -1)
            _g[1] = v
            _g = new_u
            v = (_g[2] * -1)
            _g[2] = v
            _g = new_v
            v = (_g[0] * -1)
            _g[0] = v
            _g = new_v
            v = (_g[1] * -1)
            _g[1] = v
            _g = new_v
            v = (_g[2] * -1)
            _g[2] = v
            return
        _x = (old_norm[0] * ndot)
        _y = (old_norm[1] * ndot)
        _z = (old_norm[2] * ndot)
        this1 = [None]*3
        this2 = this1
        this2[0] = _x
        this2[1] = _y
        this2[2] = _z
        rhs = this2
        _x = (new_norm[0] - rhs[0])
        _y = (new_norm[1] - rhs[1])
        _z = (new_norm[2] - rhs[2])
        this1 = [None]*3
        this2 = this1
        this2[0] = _x
        this2[1] = _y
        this2[2] = _z
        perp_old = this2
        _x = (old_norm[0] + new_norm[0])
        _y = (old_norm[1] + new_norm[1])
        _z = (old_norm[2] + new_norm[2])
        this1 = [None]*3
        this2 = this1
        this2[0] = _x
        this2[1] = _y
        this2[2] = _z
        this1 = this2
        rhs = (1 / ((1 + ndot)))
        _x = (this1[0] * rhs)
        _y = (this1[1] * rhs)
        _z = (this1[2] * rhs)
        this1 = [None]*3
        this2 = this1
        this2[0] = _x
        this2[1] = _y
        this2[2] = _z
        dperp = this2
        rhs = (((new_u[0] * perp_old[0]) + ((new_u[1] * perp_old[1]))) + ((new_u[2] * perp_old[2])))
        _x = (dperp[0] * rhs)
        _y = (dperp[1] * rhs)
        _z = (dperp[2] * rhs)
        this1 = [None]*3
        this2 = this1
        this2[0] = _x
        this2[1] = _y
        this2[2] = _z
        rhs = this2
        _x = (new_u[0] - rhs[0])
        _y = (new_u[1] - rhs[1])
        _z = (new_u[2] - rhs[2])
        this1 = [None]*3
        this2 = this1
        this2[0] = _x
        this2[1] = _y
        this2[2] = _z
        new_u = this2
        rhs = (((new_v[0] * perp_old[0]) + ((new_v[1] * perp_old[1]))) + ((new_v[2] * perp_old[2])))
        _x = (dperp[0] * rhs)
        _y = (dperp[1] * rhs)
        _z = (dperp[2] * rhs)
        this1 = [None]*3
        this2 = this1
        this2[0] = _x
        this2[1] = _y
        this2[2] = _z
        rhs = this2
        _x = (new_v[0] - rhs[0])
        _y = (new_v[1] - rhs[1])
        _z = (new_v[2] - rhs[2])
        this1 = [None]*3
        this2 = this1
        this2[0] = _x
        this2[1] = _y
        this2[2] = _z
        new_v = this2

    @staticmethod
    def projCurv(old_u,old_v,old_ku,old_kuv,old_kv,new_u,new_v):
        this1 = [None]*3
        this2 = this1
        this2[0] = 0
        this2[1] = 0
        this2[2] = 0
        r_new_u = this2
        this1 = [None]*3
        this2 = this1
        this2[0] = 0
        this2[1] = 0
        this2[2] = 0
        r_new_v = this2
        _x = ((old_u[1] * old_v[2]) - ((old_u[2] * old_v[1])))
        _y = ((old_u[2] * old_v[0]) - ((old_u[0] * old_v[2])))
        _z = ((old_u[0] * old_v[1]) - ((old_u[1] * old_v[0])))
        this1 = [None]*3
        this2 = this1
        this2[0] = _x
        this2[1] = _y
        this2[2] = _z
        apparentridges_Mesh.rotCoordSys(new_u,new_v,this2,r_new_u,r_new_v)
        u1 = (((r_new_u[0] * old_u[0]) + ((r_new_u[1] * old_u[1]))) + ((r_new_u[2] * old_u[2])))
        v1 = (((r_new_u[0] * old_v[0]) + ((r_new_u[1] * old_v[1]))) + ((r_new_u[2] * old_v[2])))
        u2 = (((r_new_v[0] * old_u[0]) + ((r_new_v[1] * old_u[1]))) + ((r_new_v[2] * old_u[2])))
        v2 = (((r_new_v[0] * old_v[0]) + ((r_new_v[1] * old_v[1]))) + ((r_new_v[2] * old_v[2])))
        new_ku = ((((old_ku * u1) * u1) + ((old_kuv * (((2 * u1) * v1))))) + (((old_kv * v1) * v1)))
        new_kuv = ((((old_ku * u1) * u2) + ((old_kuv * (((u1 * v2) + ((u2 * v1))))))) + (((old_kv * v1) * v2)))
        new_kv = ((((old_ku * u2) * u2) + ((old_kuv * (((2 * u2) * v2))))) + (((old_kv * v2) * v2)))
        this1 = [None]*3
        this2 = this1
        this2[0] = new_ku
        this2[1] = new_kuv
        this2[2] = new_kv
        return this2

    @staticmethod
    def diagonalizeCurv(old_u,old_v,ku,kuv,kv,new_norm,pd1,pd2,k1k2):
        this1 = [None]*3
        this2 = this1
        this2[0] = 0
        this2[1] = 0
        this2[2] = 0
        r_old_u = this2
        this1 = [None]*3
        this2 = this1
        this2[0] = 0
        this2[1] = 0
        this2[2] = 0
        r_old_v = this2
        apparentridges_Mesh.rotCoordSys(old_u,old_v,new_norm,r_old_u,r_old_v)
        c = 1
        s = 0
        tt = 0
        if (kuv != 0.0):
            h = ((0.5 * ((kv - ku))) / kuv)
            if (h < 0.0):
                v = (1.0 + ((h * h)))
                tt = (1.0 / ((h - ((Math.NaN if ((v < 0)) else python_lib_Math.sqrt(v))))))
            else:
                v = (1.0 + ((h * h)))
                tt = (1.0 / ((h + ((Math.NaN if ((v < 0)) else python_lib_Math.sqrt(v))))))
            v = (1.0 + ((tt * tt)))
            c = (1.0 / ((Math.NaN if ((v < 0)) else python_lib_Math.sqrt(v))))
            s = (tt * c)
        k1 = (ku - ((tt * kuv)))
        k2 = (kv + ((tt * kuv)))
        if (Reflect.field(Math,"fabs")(k1) >= Reflect.field(Math,"fabs")(k2)):
            k1k2[0] = k1
            k1k2[1] = k2
            _x = (r_old_u[0] * c)
            _y = (r_old_u[1] * c)
            _z = (r_old_u[2] * c)
            this1 = [None]*3
            this2 = this1
            this2[0] = _x
            this2[1] = _y
            this2[2] = _z
            this1 = this2
            _x = (r_old_v[0] * s)
            _y = (r_old_v[1] * s)
            _z = (r_old_v[2] * s)
            this2 = [None]*3
            this3 = this2
            this3[0] = _x
            this3[1] = _y
            this3[2] = _z
            rhs = this3
            _x = (this1[0] - rhs[0])
            _y = (this1[1] - rhs[1])
            _z = (this1[2] - rhs[2])
            this1 = [None]*3
            this2 = this1
            this2[0] = _x
            this2[1] = _y
            this2[2] = _z
            v = this2
            v1 = v[0]
            pd1[0] = v1
            v1 = v[1]
            pd1[1] = v1
            v1 = v[2]
            pd1[2] = v1
        else:
            k1k2[0] = k2
            k1k2[1] = k1
            _x = (r_old_u[0] * s)
            _y = (r_old_u[1] * s)
            _z = (r_old_u[2] * s)
            this1 = [None]*3
            this2 = this1
            this2[0] = _x
            this2[1] = _y
            this2[2] = _z
            this1 = this2
            _x = (r_old_v[0] * c)
            _y = (r_old_v[1] * c)
            _z = (r_old_v[2] * c)
            this2 = [None]*3
            this3 = this2
            this3[0] = _x
            this3[1] = _y
            this3[2] = _z
            rhs = this3
            _x = (this1[0] + rhs[0])
            _y = (this1[1] + rhs[1])
            _z = (this1[2] + rhs[2])
            this1 = [None]*3
            this2 = this1
            this2[0] = _x
            this2[1] = _y
            this2[2] = _z
            v = this2
            v1 = v[0]
            pd1[0] = v1
            v1 = v[1]
            pd1[1] = v1
            v1 = v[2]
            pd1[2] = v1
        _x = ((new_norm[1] * pd1[2]) - ((new_norm[2] * pd1[1])))
        _y = ((new_norm[2] * pd1[0]) - ((new_norm[0] * pd1[2])))
        _z = ((new_norm[0] * pd1[1]) - ((new_norm[1] * pd1[0])))
        this1 = [None]*3
        this2 = this1
        this2[0] = _x
        this2[1] = _y
        this2[2] = _z
        v = this2
        v1 = v[0]
        pd2[0] = v1
        v1 = v[1]
        pd2[1] = v1
        v1 = v[2]
        pd2[2] = v1



class apparentridges_Ray:
    _hx_class_name = "apparentridges.Ray"
    __slots__ = ("o", "d", "tmin", "tmax")
    _hx_fields = ["o", "d", "tmin", "tmax"]
    _hx_methods = ["hitBBox", "hitTriangle", "hitBVH"]

    def __init__(self):
        self.tmax = None
        self.tmin = None
        self.d = None
        self.o = None

    def hitBBox(self,bb):
        tx1 = (((bb.min[0] - self.o[0])) / self.d[0])
        tx2 = (((bb.max[0] - self.o[0])) / self.d[0])
        ty1 = (((bb.min[1] - self.o[1])) / self.d[1])
        ty2 = (((bb.max[1] - self.o[1])) / self.d[1])
        tz1 = (((bb.min[2] - self.o[2])) / self.d[2])
        tz2 = (((bb.max[2] - self.o[2])) / self.d[2])
        a = (tx1 if (python_lib_Math.isnan(tx1)) else (tx2 if (python_lib_Math.isnan(tx2)) else min(tx1,tx2)))
        b = (ty1 if (python_lib_Math.isnan(ty1)) else (ty2 if (python_lib_Math.isnan(ty2)) else min(ty1,ty2)))
        a1 = (a if (python_lib_Math.isnan(a)) else (b if (python_lib_Math.isnan(b)) else max(a,b)))
        b = (tz1 if (python_lib_Math.isnan(tz1)) else (tz2 if (python_lib_Math.isnan(tz2)) else min(tz1,tz2)))
        t1 = (a1 if (python_lib_Math.isnan(a1)) else (b if (python_lib_Math.isnan(b)) else max(a1,b)))
        a = (tx1 if (python_lib_Math.isnan(tx1)) else (tx2 if (python_lib_Math.isnan(tx2)) else max(tx1,tx2)))
        b = (ty1 if (python_lib_Math.isnan(ty1)) else (ty2 if (python_lib_Math.isnan(ty2)) else max(ty1,ty2)))
        a1 = (a if (python_lib_Math.isnan(a)) else (b if (python_lib_Math.isnan(b)) else min(a,b)))
        b = (tz1 if (python_lib_Math.isnan(tz1)) else (tz2 if (python_lib_Math.isnan(tz2)) else max(tz1,tz2)))
        t2 = (a1 if (python_lib_Math.isnan(a1)) else (b if (python_lib_Math.isnan(b)) else min(a1,b)))
        if ((t2 - t1) < 0):
            return None
        if ((t1 > self.tmax) or ((t2 < self.tmin))):
            return None
        h = apparentridges_RayHit(t1)
        h.t2 = t2
        return h

    def hitTriangle(self,p0,p1,p2):
        _x = (p1[0] - p0[0])
        _y = (p1[1] - p0[1])
        _z = (p1[2] - p0[2])
        this1 = [None]*3
        this2 = this1
        this2[0] = _x
        this2[1] = _y
        this2[2] = _z
        e1 = this2
        _x = (p2[0] - p0[0])
        _y = (p2[1] - p0[1])
        _z = (p2[2] - p0[2])
        this1 = [None]*3
        this2 = this1
        this2[0] = _x
        this2[1] = _y
        this2[2] = _z
        e2 = this2
        this1 = self.o
        _x = (this1[0] - p0[0])
        _y = (this1[1] - p0[1])
        _z = (this1[2] - p0[2])
        this1 = [None]*3
        this2 = this1
        this2[0] = _x
        this2[1] = _y
        this2[2] = _z
        s = this2
        this1 = self.d
        _x = (this1[0] * -1.0)
        _y = (this1[1] * -1.0)
        _z = (this1[2] * -1.0)
        this1 = [None]*3
        this2 = this1
        this2[0] = _x
        this2[1] = _y
        this2[2] = _z
        _d = this2
        _x = ((e1[1] * e2[2]) - ((e1[2] * e2[1])))
        _y = ((e1[2] * e2[0]) - ((e1[0] * e2[2])))
        _z = ((e1[0] * e2[1]) - ((e1[1] * e2[0])))
        this1 = [None]*3
        this2 = this1
        this2[0] = _x
        this2[1] = _y
        this2[2] = _z
        v1 = this2
        denom = (((v1[0] * _d[0]) + ((v1[1] * _d[1]))) + ((v1[2] * _d[2])))
        if (denom == 0):
            return None
        _x = ((s[1] * e2[2]) - ((s[2] * e2[1])))
        _y = ((s[2] * e2[0]) - ((s[0] * e2[2])))
        _z = ((s[0] * e2[1]) - ((s[1] * e2[0])))
        this1 = [None]*3
        this2 = this1
        this2[0] = _x
        this2[1] = _y
        this2[2] = _z
        v1 = this2
        _x = (((v1[0] * _d[0]) + ((v1[1] * _d[1]))) + ((v1[2] * _d[2])))
        _x1 = ((e1[1] * s[2]) - ((e1[2] * s[1])))
        _y = ((e1[2] * s[0]) - ((e1[0] * s[2])))
        _z = ((e1[0] * s[1]) - ((e1[1] * s[0])))
        this1 = [None]*3
        this2 = this1
        this2[0] = _x1
        this2[1] = _y
        this2[2] = _z
        v1 = this2
        _y = (((v1[0] * _d[0]) + ((v1[1] * _d[1]))) + ((v1[2] * _d[2])))
        _x1 = ((e1[1] * e2[2]) - ((e1[2] * e2[1])))
        _y1 = ((e1[2] * e2[0]) - ((e1[0] * e2[2])))
        _z = ((e1[0] * e2[1]) - ((e1[1] * e2[0])))
        this1 = [None]*3
        this2 = this1
        this2[0] = _x1
        this2[1] = _y1
        this2[2] = _z
        v1 = this2
        _z = (((v1[0] * s[0]) + ((v1[1] * s[1]))) + ((v1[2] * s[2])))
        this1 = [None]*3
        this2 = this1
        this2[0] = _x
        this2[1] = _y
        this2[2] = _z
        this1 = this2
        rhs = (1 / denom)
        _x = (this1[0] * rhs)
        _y = (this1[1] * rhs)
        _z = (this1[2] * rhs)
        this1 = [None]*3
        this2 = this1
        this2[0] = _x
        this2[1] = _y
        this2[2] = _z
        uvt = this2
        u = uvt[0]
        v = uvt[1]
        t = uvt[2]
        if (((((u < 0) or ((v < 0))) or ((((1 - u) - v) < 0))) or ((t < self.tmin))) or ((t > self.tmax))):
            return None
        h = apparentridges_RayHit(t)
        h.u = u
        h.v = v
        return h

    def hitBVH(self,bvh):
        _gthis = self
        hitNode = None
        def _hx_local_0(node):
            if ((node.left is None) and ((node.right is None))):
                tmin = Math.POSITIVE_INFINITY
                closest = None
                _g = node.begin
                _g1 = node.end
                while (_g < _g1):
                    i = _g
                    _g = (_g + 1)
                    p0 = python_internal_ArrayImpl._get(bvh.mesh.vertices, (bvh.faces[i] if i >= 0 and i < len(bvh.faces) else None)[0])
                    p1 = python_internal_ArrayImpl._get(bvh.mesh.vertices, (bvh.faces[i] if i >= 0 and i < len(bvh.faces) else None)[1])
                    p2 = python_internal_ArrayImpl._get(bvh.mesh.vertices, (bvh.faces[i] if i >= 0 and i < len(bvh.faces) else None)[2])
                    _x = (p1[0] - p0[0])
                    _y = (p1[1] - p0[1])
                    _z = (p1[2] - p0[2])
                    this1 = [None]*3
                    this2 = this1
                    this2[0] = _x
                    this2[1] = _y
                    this2[2] = _z
                    e1 = this2
                    _x1 = (p2[0] - p0[0])
                    _y1 = (p2[1] - p0[1])
                    _z1 = (p2[2] - p0[2])
                    this3 = [None]*3
                    this4 = this3
                    this4[0] = _x1
                    this4[1] = _y1
                    this4[2] = _z1
                    e2 = this4
                    this5 = _gthis.o
                    _x2 = (this5[0] - p0[0])
                    _y2 = (this5[1] - p0[1])
                    _z2 = (this5[2] - p0[2])
                    this6 = [None]*3
                    this7 = this6
                    this7[0] = _x2
                    this7[1] = _y2
                    this7[2] = _z2
                    s = this7
                    this8 = _gthis.d
                    _x3 = (this8[0] * -1.0)
                    _y3 = (this8[1] * -1.0)
                    _z3 = (this8[2] * -1.0)
                    this9 = [None]*3
                    this10 = this9
                    this10[0] = _x3
                    this10[1] = _y3
                    this10[2] = _z3
                    _d = this10
                    _x4 = ((e1[1] * e2[2]) - ((e1[2] * e2[1])))
                    _y4 = ((e1[2] * e2[0]) - ((e1[0] * e2[2])))
                    _z4 = ((e1[0] * e2[1]) - ((e1[1] * e2[0])))
                    this11 = [None]*3
                    this12 = this11
                    this12[0] = _x4
                    this12[1] = _y4
                    this12[2] = _z4
                    v1 = this12
                    denom = (((v1[0] * _d[0]) + ((v1[1] * _d[1]))) + ((v1[2] * _d[2])))
                    h = None
                    if (denom == 0):
                        h = None
                    else:
                        _x5 = ((s[1] * e2[2]) - ((s[2] * e2[1])))
                        _y5 = ((s[2] * e2[0]) - ((s[0] * e2[2])))
                        _z5 = ((s[0] * e2[1]) - ((s[1] * e2[0])))
                        this13 = [None]*3
                        this14 = this13
                        this14[0] = _x5
                        this14[1] = _y5
                        this14[2] = _z5
                        v11 = this14
                        _x6 = (((v11[0] * _d[0]) + ((v11[1] * _d[1]))) + ((v11[2] * _d[2])))
                        _x7 = ((e1[1] * s[2]) - ((e1[2] * s[1])))
                        _y6 = ((e1[2] * s[0]) - ((e1[0] * s[2])))
                        _z6 = ((e1[0] * s[1]) - ((e1[1] * s[0])))
                        this15 = [None]*3
                        this16 = this15
                        this16[0] = _x7
                        this16[1] = _y6
                        this16[2] = _z6
                        v12 = this16
                        _y7 = (((v12[0] * _d[0]) + ((v12[1] * _d[1]))) + ((v12[2] * _d[2])))
                        _x8 = ((e1[1] * e2[2]) - ((e1[2] * e2[1])))
                        _y8 = ((e1[2] * e2[0]) - ((e1[0] * e2[2])))
                        _z7 = ((e1[0] * e2[1]) - ((e1[1] * e2[0])))
                        this17 = [None]*3
                        this18 = this17
                        this18[0] = _x8
                        this18[1] = _y8
                        this18[2] = _z7
                        v13 = this18
                        _z8 = (((v13[0] * s[0]) + ((v13[1] * s[1]))) + ((v13[2] * s[2])))
                        this19 = [None]*3
                        this20 = this19
                        this20[0] = _x6
                        this20[1] = _y7
                        this20[2] = _z8
                        this21 = this20
                        rhs = (1 / denom)
                        _x9 = (this21[0] * rhs)
                        _y9 = (this21[1] * rhs)
                        _z9 = (this21[2] * rhs)
                        this22 = [None]*3
                        this23 = this22
                        this23[0] = _x9
                        this23[1] = _y9
                        this23[2] = _z9
                        uvt = this23
                        u = uvt[0]
                        v = uvt[1]
                        t = uvt[2]
                        if (((((u < 0) or ((v < 0))) or ((((1 - u) - v) < 0))) or ((t < _gthis.tmin))) or ((t > _gthis.tmax))):
                            h = None
                        else:
                            h1 = apparentridges_RayHit(t)
                            h1.u = u
                            h1.v = v
                            h = h1
                    if (h is not None):
                        h.face = (bvh.faces[i] if i >= 0 and i < len(bvh.faces) else None)
                        if (tmin > h.t):
                            tmin = h.t
                            closest = h
                return closest
            bb = node.left.bbox
            tx1 = (((bb.min[0] - _gthis.o[0])) / _gthis.d[0])
            tx2 = (((bb.max[0] - _gthis.o[0])) / _gthis.d[0])
            ty1 = (((bb.min[1] - _gthis.o[1])) / _gthis.d[1])
            ty2 = (((bb.max[1] - _gthis.o[1])) / _gthis.d[1])
            tz1 = (((bb.min[2] - _gthis.o[2])) / _gthis.d[2])
            tz2 = (((bb.max[2] - _gthis.o[2])) / _gthis.d[2])
            a = (tx1 if (python_lib_Math.isnan(tx1)) else (tx2 if (python_lib_Math.isnan(tx2)) else min(tx1,tx2)))
            b = (ty1 if (python_lib_Math.isnan(ty1)) else (ty2 if (python_lib_Math.isnan(ty2)) else min(ty1,ty2)))
            a1 = (a if (python_lib_Math.isnan(a)) else (b if (python_lib_Math.isnan(b)) else max(a,b)))
            b = (tz1 if (python_lib_Math.isnan(tz1)) else (tz2 if (python_lib_Math.isnan(tz2)) else min(tz1,tz2)))
            t1 = (a1 if (python_lib_Math.isnan(a1)) else (b if (python_lib_Math.isnan(b)) else max(a1,b)))
            a = (tx1 if (python_lib_Math.isnan(tx1)) else (tx2 if (python_lib_Math.isnan(tx2)) else max(tx1,tx2)))
            b = (ty1 if (python_lib_Math.isnan(ty1)) else (ty2 if (python_lib_Math.isnan(ty2)) else max(ty1,ty2)))
            a1 = (a if (python_lib_Math.isnan(a)) else (b if (python_lib_Math.isnan(b)) else min(a,b)))
            b = (tz1 if (python_lib_Math.isnan(tz1)) else (tz2 if (python_lib_Math.isnan(tz2)) else max(tz1,tz2)))
            t2 = (a1 if (python_lib_Math.isnan(a1)) else (b if (python_lib_Math.isnan(b)) else min(a1,b)))
            hitL = None
            if ((t2 - t1) < 0):
                hitL = None
            elif ((t1 > _gthis.tmax) or ((t2 < _gthis.tmin))):
                hitL = None
            else:
                h = apparentridges_RayHit(t1)
                h.t2 = t2
                hitL = h
            bb = node.right.bbox
            tx1 = (((bb.min[0] - _gthis.o[0])) / _gthis.d[0])
            tx2 = (((bb.max[0] - _gthis.o[0])) / _gthis.d[0])
            ty1 = (((bb.min[1] - _gthis.o[1])) / _gthis.d[1])
            ty2 = (((bb.max[1] - _gthis.o[1])) / _gthis.d[1])
            tz1 = (((bb.min[2] - _gthis.o[2])) / _gthis.d[2])
            tz2 = (((bb.max[2] - _gthis.o[2])) / _gthis.d[2])
            a = (tx1 if (python_lib_Math.isnan(tx1)) else (tx2 if (python_lib_Math.isnan(tx2)) else min(tx1,tx2)))
            b = (ty1 if (python_lib_Math.isnan(ty1)) else (ty2 if (python_lib_Math.isnan(ty2)) else min(ty1,ty2)))
            a1 = (a if (python_lib_Math.isnan(a)) else (b if (python_lib_Math.isnan(b)) else max(a,b)))
            b = (tz1 if (python_lib_Math.isnan(tz1)) else (tz2 if (python_lib_Math.isnan(tz2)) else min(tz1,tz2)))
            t1 = (a1 if (python_lib_Math.isnan(a1)) else (b if (python_lib_Math.isnan(b)) else max(a1,b)))
            a = (tx1 if (python_lib_Math.isnan(tx1)) else (tx2 if (python_lib_Math.isnan(tx2)) else max(tx1,tx2)))
            b = (ty1 if (python_lib_Math.isnan(ty1)) else (ty2 if (python_lib_Math.isnan(ty2)) else max(ty1,ty2)))
            a1 = (a if (python_lib_Math.isnan(a)) else (b if (python_lib_Math.isnan(b)) else min(a,b)))
            b = (tz1 if (python_lib_Math.isnan(tz1)) else (tz2 if (python_lib_Math.isnan(tz2)) else max(tz1,tz2)))
            t2 = (a1 if (python_lib_Math.isnan(a1)) else (b if (python_lib_Math.isnan(b)) else min(a1,b)))
            hitR = None
            if ((t2 - t1) < 0):
                hitR = None
            elif ((t1 > _gthis.tmax) or ((t2 < _gthis.tmin))):
                hitR = None
            else:
                h = apparentridges_RayHit(t1)
                h.t2 = t2
                hitR = h
            if ((hitL is not None) and ((hitR is None))):
                return hitNode(node.left)
            elif ((hitL is None) and ((hitR is not None))):
                return hitNode(node.right)
            elif ((hitL is None) and ((hitR is None))):
                return None
            first = None
            second = None
            if (hitL.t < hitR.t):
                first = node.left
                second = node.right
            else:
                first = node.right
                second = node.left
            h = hitNode(first)
            hitNode1 = None
            if (h is not None):
                a = hitL.t
                b = hitR.t
                hitNode1 = (h.t >= ((a if (python_lib_Math.isnan(a)) else (b if (python_lib_Math.isnan(b)) else max(a,b)))))
            else:
                hitNode1 = True
            if hitNode1:
                h2 = hitNode(second)
                if (h2 is not None):
                    if ((h is None) or ((h2.t < h.t))):
                        return h2
            return h
        hitNode = _hx_local_0
        return hitNode(bvh.root)



class apparentridges_RayHit:
    _hx_class_name = "apparentridges.RayHit"
    __slots__ = ("t", "t2", "u", "v", "face")
    _hx_fields = ["t", "t2", "u", "v", "face"]

    def __init__(self,_t):
        self.face = None
        self.v = None
        self.u = None
        self.t2 = None
        self.t = _t



class apparentridges_BBox:
    _hx_class_name = "apparentridges.BBox"
    __slots__ = ("min", "max")
    _hx_fields = ["min", "max"]
    _hx_methods = ["centroid", "add", "merge", "surfaceArea"]

    def __init__(self):
        _x = Math.POSITIVE_INFINITY
        _y = Math.POSITIVE_INFINITY
        _z = Math.POSITIVE_INFINITY
        this1 = [None]*3
        this2 = this1
        this2[0] = _x
        this2[1] = _y
        this2[2] = _z
        self.min = this2
        _x = Math.NEGATIVE_INFINITY
        _y = Math.NEGATIVE_INFINITY
        _z = Math.NEGATIVE_INFINITY
        this1 = [None]*3
        this2 = this1
        this2[0] = _x
        this2[1] = _y
        this2[2] = _z
        self.max = this2

    def centroid(self):
        this1 = self.min
        rhs = self.max
        _x = (this1[0] + rhs[0])
        _y = (this1[1] + rhs[1])
        _z = (this1[2] + rhs[2])
        this1 = [None]*3
        this2 = this1
        this2[0] = _x
        this2[1] = _y
        this2[2] = _z
        this1 = this2
        _x = (this1[0] * 0.5)
        _y = (this1[1] * 0.5)
        _z = (this1[2] * 0.5)
        this1 = [None]*3
        this2 = this1
        this2[0] = _x
        this2[1] = _y
        this2[2] = _z
        return this2

    def add(self,p):
        this1 = self.min
        a = self.min[0]
        b = p[0]
        v = (a if (python_lib_Math.isnan(a)) else (b if (python_lib_Math.isnan(b)) else min(a,b)))
        this1[0] = v
        this1 = self.min
        a = self.min[1]
        b = p[1]
        v = (a if (python_lib_Math.isnan(a)) else (b if (python_lib_Math.isnan(b)) else min(a,b)))
        this1[1] = v
        this1 = self.min
        a = self.min[2]
        b = p[2]
        v = (a if (python_lib_Math.isnan(a)) else (b if (python_lib_Math.isnan(b)) else min(a,b)))
        this1[2] = v
        this1 = self.max
        a = self.max[0]
        b = p[0]
        v = (a if (python_lib_Math.isnan(a)) else (b if (python_lib_Math.isnan(b)) else max(a,b)))
        this1[0] = v
        this1 = self.max
        a = self.max[1]
        b = p[1]
        v = (a if (python_lib_Math.isnan(a)) else (b if (python_lib_Math.isnan(b)) else max(a,b)))
        this1[1] = v
        this1 = self.max
        a = self.max[2]
        b = p[2]
        v = (a if (python_lib_Math.isnan(a)) else (b if (python_lib_Math.isnan(b)) else max(a,b)))
        this1[2] = v

    def merge(self,bb):
        this1 = self.min
        a = self.min[0]
        b = bb.min[0]
        v = (a if (python_lib_Math.isnan(a)) else (b if (python_lib_Math.isnan(b)) else min(a,b)))
        this1[0] = v
        this1 = self.min
        a = self.min[1]
        b = bb.min[1]
        v = (a if (python_lib_Math.isnan(a)) else (b if (python_lib_Math.isnan(b)) else min(a,b)))
        this1[1] = v
        this1 = self.min
        a = self.min[2]
        b = bb.min[2]
        v = (a if (python_lib_Math.isnan(a)) else (b if (python_lib_Math.isnan(b)) else min(a,b)))
        this1[2] = v
        this1 = self.max
        a = self.max[0]
        b = bb.max[0]
        v = (a if (python_lib_Math.isnan(a)) else (b if (python_lib_Math.isnan(b)) else max(a,b)))
        this1[0] = v
        this1 = self.max
        a = self.max[1]
        b = bb.max[1]
        v = (a if (python_lib_Math.isnan(a)) else (b if (python_lib_Math.isnan(b)) else max(a,b)))
        this1[1] = v
        this1 = self.max
        a = self.max[2]
        b = bb.max[2]
        v = (a if (python_lib_Math.isnan(a)) else (b if (python_lib_Math.isnan(b)) else max(a,b)))
        this1[2] = v

    def surfaceArea(self):
        this1 = self.max
        rhs = self.min
        _x = (this1[0] - rhs[0])
        _y = (this1[1] - rhs[1])
        _z = (this1[2] - rhs[2])
        this1 = [None]*3
        this2 = this1
        this2[0] = _x
        this2[1] = _y
        this2[2] = _z
        extent = this2
        a = extent[0]
        x = (a if (python_lib_Math.isnan(a)) else (0 if (python_lib_Math.isnan(0)) else max(a,0)))
        a = extent[1]
        y = (a if (python_lib_Math.isnan(a)) else (0 if (python_lib_Math.isnan(0)) else max(a,0)))
        a = extent[2]
        z = (a if (python_lib_Math.isnan(a)) else (0 if (python_lib_Math.isnan(0)) else max(a,0)))
        return (2 * ((((x * z) + ((x * y))) + ((y * z)))))



class apparentridges_BVHNode:
    _hx_class_name = "apparentridges.BVHNode"
    __slots__ = ("left", "right", "begin", "end", "bbox")
    _hx_fields = ["left", "right", "begin", "end", "bbox"]
    _hx_methods = ["isLeaf"]

    def __init__(self,box,i0,i1):
        self.bbox = box
        self.begin = i0
        self.end = i1
        self.left = None
        self.right = None

    def isLeaf(self):
        if (self.left is None):
            return (self.right is None)
        else:
            return False



class apparentridges_BVHTree:
    _hx_class_name = "apparentridges.BVHTree"
    __slots__ = ("root", "mesh", "faces", "maxLeafSize", "bucketCount")
    _hx_fields = ["root", "mesh", "faces", "maxLeafSize", "bucketCount"]
    _hx_methods = ["build"]

    def __init__(self,_mesh,_maxLeafSize = None,_bucketCount = None):
        if (_maxLeafSize is None):
            _maxLeafSize = 4
        if (_bucketCount is None):
            _bucketCount = 8
        self.root = None
        self.maxLeafSize = _maxLeafSize
        self.bucketCount = _bucketCount
        self.faces = _mesh.faces[0:None]
        self.mesh = _mesh

    def build(self):
        _gthis = self
        def _hx_local_0(bbox,f):
            p = python_internal_ArrayImpl._get(_gthis.mesh.vertices, f[0])
            this1 = bbox.min
            a = bbox.min[0]
            b = p[0]
            v = (a if (python_lib_Math.isnan(a)) else (b if (python_lib_Math.isnan(b)) else min(a,b)))
            this1[0] = v
            this1 = bbox.min
            a = bbox.min[1]
            b = p[1]
            v = (a if (python_lib_Math.isnan(a)) else (b if (python_lib_Math.isnan(b)) else min(a,b)))
            this1[1] = v
            this1 = bbox.min
            a = bbox.min[2]
            b = p[2]
            v = (a if (python_lib_Math.isnan(a)) else (b if (python_lib_Math.isnan(b)) else min(a,b)))
            this1[2] = v
            this1 = bbox.max
            a = bbox.max[0]
            b = p[0]
            v = (a if (python_lib_Math.isnan(a)) else (b if (python_lib_Math.isnan(b)) else max(a,b)))
            this1[0] = v
            this1 = bbox.max
            a = bbox.max[1]
            b = p[1]
            v = (a if (python_lib_Math.isnan(a)) else (b if (python_lib_Math.isnan(b)) else max(a,b)))
            this1[1] = v
            this1 = bbox.max
            a = bbox.max[2]
            b = p[2]
            v = (a if (python_lib_Math.isnan(a)) else (b if (python_lib_Math.isnan(b)) else max(a,b)))
            this1[2] = v
            p = python_internal_ArrayImpl._get(_gthis.mesh.vertices, f[1])
            this1 = bbox.min
            a = bbox.min[0]
            b = p[0]
            v = (a if (python_lib_Math.isnan(a)) else (b if (python_lib_Math.isnan(b)) else min(a,b)))
            this1[0] = v
            this1 = bbox.min
            a = bbox.min[1]
            b = p[1]
            v = (a if (python_lib_Math.isnan(a)) else (b if (python_lib_Math.isnan(b)) else min(a,b)))
            this1[1] = v
            this1 = bbox.min
            a = bbox.min[2]
            b = p[2]
            v = (a if (python_lib_Math.isnan(a)) else (b if (python_lib_Math.isnan(b)) else min(a,b)))
            this1[2] = v
            this1 = bbox.max
            a = bbox.max[0]
            b = p[0]
            v = (a if (python_lib_Math.isnan(a)) else (b if (python_lib_Math.isnan(b)) else max(a,b)))
            this1[0] = v
            this1 = bbox.max
            a = bbox.max[1]
            b = p[1]
            v = (a if (python_lib_Math.isnan(a)) else (b if (python_lib_Math.isnan(b)) else max(a,b)))
            this1[1] = v
            this1 = bbox.max
            a = bbox.max[2]
            b = p[2]
            v = (a if (python_lib_Math.isnan(a)) else (b if (python_lib_Math.isnan(b)) else max(a,b)))
            this1[2] = v
            p = python_internal_ArrayImpl._get(_gthis.mesh.vertices, f[2])
            this1 = bbox.min
            a = bbox.min[0]
            b = p[0]
            v = (a if (python_lib_Math.isnan(a)) else (b if (python_lib_Math.isnan(b)) else min(a,b)))
            this1[0] = v
            this1 = bbox.min
            a = bbox.min[1]
            b = p[1]
            v = (a if (python_lib_Math.isnan(a)) else (b if (python_lib_Math.isnan(b)) else min(a,b)))
            this1[1] = v
            this1 = bbox.min
            a = bbox.min[2]
            b = p[2]
            v = (a if (python_lib_Math.isnan(a)) else (b if (python_lib_Math.isnan(b)) else min(a,b)))
            this1[2] = v
            this1 = bbox.max
            a = bbox.max[0]
            b = p[0]
            v = (a if (python_lib_Math.isnan(a)) else (b if (python_lib_Math.isnan(b)) else max(a,b)))
            this1[0] = v
            this1 = bbox.max
            a = bbox.max[1]
            b = p[1]
            v = (a if (python_lib_Math.isnan(a)) else (b if (python_lib_Math.isnan(b)) else max(a,b)))
            this1[1] = v
            this1 = bbox.max
            a = bbox.max[2]
            b = p[2]
            v = (a if (python_lib_Math.isnan(a)) else (b if (python_lib_Math.isnan(b)) else max(a,b)))
            this1[2] = v
        bboxAddFace = _hx_local_0
        buildRange = None
        def _hx_local_9(i0,i1):
            bbox = apparentridges_BBox()
            _g = i0
            _g1 = i1
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                bboxAddFace(bbox,(_gthis.faces[i] if i >= 0 and i < len(_gthis.faces) else None))
            node = apparentridges_BVHNode(bbox,i0,i1)
            if ((i1 - i0) <= _gthis.maxLeafSize):
                return node
            parts = []
            _g = 0
            while (_g < 3):
                ax = _g
                _g = (_g + 1)
                buckets = []
                lo = bbox.min[ax]
                hi = bbox.max[ax]
                _g1 = 0
                _g2 = _gthis.bucketCount
                while (_g1 < _g2):
                    i = _g1
                    _g1 = (_g1 + 1)
                    b = apparentridges_BVHBucket()
                    b.min = (lo + (((i / _gthis.bucketCount) * ((hi - lo)))))
                    b.max = (b.min + ((((hi - lo)) / _gthis.bucketCount)))
                    buckets.append(b)
                _g3 = i0
                _g4 = i1
                while (_g3 < _g4):
                    i2 = _g3
                    _g3 = (_g3 + 1)
                    bb = apparentridges_BBox()
                    bboxAddFace(bb,(_gthis.faces[i2] if i2 >= 0 and i2 < len(_gthis.faces) else None))
                    this1 = bb.min
                    rhs = bb.max
                    _x = (this1[0] + rhs[0])
                    _y = (this1[1] + rhs[1])
                    _z = (this1[2] + rhs[2])
                    this2 = [None]*3
                    this3 = this2
                    this3[0] = _x
                    this3[1] = _y
                    this3[2] = _z
                    this4 = this3
                    _x1 = (this4[0] * 0.5)
                    _y1 = (this4[1] * 0.5)
                    _z1 = (this4[2] * 0.5)
                    this5 = [None]*3
                    this6 = this5
                    this6[0] = _x1
                    this6[1] = _y1
                    this6[2] = _z1
                    c = this6
                    _g5 = 0
                    _g6 = _gthis.bucketCount
                    while (_g5 < _g6):
                        j = _g5
                        _g5 = (_g5 + 1)
                        if (((buckets[j] if j >= 0 and j < len(buckets) else None).min <= c[ax]) and ((c[ax] <= (buckets[j] if j >= 0 and j < len(buckets) else None).max))):
                            _hx_local_1 = (buckets[j] if j >= 0 and j < len(buckets) else None)
                            _hx_local_2 = _hx_local_1.count
                            _hx_local_1.count = (_hx_local_2 + 1)
                            _hx_local_2
                            _this = (buckets[j] if j >= 0 and j < len(buckets) else None).bbox
                            this7 = _this.min
                            a = _this.min[0]
                            b1 = bb.min[0]
                            v = (a if (python_lib_Math.isnan(a)) else (b1 if (python_lib_Math.isnan(b1)) else min(a,b1)))
                            this7[0] = v
                            this8 = _this.min
                            a1 = _this.min[1]
                            b2 = bb.min[1]
                            v1 = (a1 if (python_lib_Math.isnan(a1)) else (b2 if (python_lib_Math.isnan(b2)) else min(a1,b2)))
                            this8[1] = v1
                            this9 = _this.min
                            a2 = _this.min[2]
                            b3 = bb.min[2]
                            v2 = (a2 if (python_lib_Math.isnan(a2)) else (b3 if (python_lib_Math.isnan(b3)) else min(a2,b3)))
                            this9[2] = v2
                            this10 = _this.max
                            a3 = _this.max[0]
                            b4 = bb.max[0]
                            v3 = (a3 if (python_lib_Math.isnan(a3)) else (b4 if (python_lib_Math.isnan(b4)) else max(a3,b4)))
                            this10[0] = v3
                            this11 = _this.max
                            a4 = _this.max[1]
                            b5 = bb.max[1]
                            v4 = (a4 if (python_lib_Math.isnan(a4)) else (b5 if (python_lib_Math.isnan(b5)) else max(a4,b5)))
                            this11[1] = v4
                            this12 = _this.max
                            a5 = _this.max[2]
                            b6 = bb.max[2]
                            v5 = (a5 if (python_lib_Math.isnan(a5)) else (b6 if (python_lib_Math.isnan(b6)) else max(a5,b6)))
                            this12[2] = v5
                            buckets1 = (buckets[j] if j >= 0 and j < len(buckets) else None).area
                            this13 = bb.max
                            rhs1 = bb.min
                            _x2 = (this13[0] - rhs1[0])
                            _y2 = (this13[1] - rhs1[1])
                            _z2 = (this13[2] - rhs1[2])
                            this14 = [None]*3
                            this15 = this14
                            this15[0] = _x2
                            this15[1] = _y2
                            this15[2] = _z2
                            extent = this15
                            a6 = extent[0]
                            x = (a6 if (python_lib_Math.isnan(a6)) else (0 if (python_lib_Math.isnan(0)) else max(a6,0)))
                            a7 = extent[1]
                            y = (a7 if (python_lib_Math.isnan(a7)) else (0 if (python_lib_Math.isnan(0)) else max(a7,0)))
                            a8 = extent[2]
                            z = (a8 if (python_lib_Math.isnan(a8)) else (0 if (python_lib_Math.isnan(0)) else max(a8,0)))
                            (buckets[j] if j >= 0 and j < len(buckets) else None).area = (buckets1 + ((2 * ((((x * z) + ((x * y))) + ((y * z)))))))
                            break
                _g7 = 0
                _g8 = _gthis.bucketCount
                while (_g7 < _g8):
                    i3 = _g7
                    _g7 = (_g7 + 1)
                    part = apparentridges_BVHPartition()
                    part.planeIndex = i3
                    part.axis = ax
                    _g9 = 0
                    _g10 = i3
                    while (_g9 < _g10):
                        j1 = _g9
                        _g9 = (_g9 + 1)
                        part.leftCount = (part.leftCount + (buckets[j1] if j1 >= 0 and j1 < len(buckets) else None).count)
                        part.leftArea = (part.leftArea + (buckets[j1] if j1 >= 0 and j1 < len(buckets) else None).area)
                        _this1 = part.leftBBox
                        bb1 = (buckets[j1] if j1 >= 0 and j1 < len(buckets) else None).bbox
                        this16 = _this1.min
                        a9 = _this1.min[0]
                        b7 = bb1.min[0]
                        v6 = (a9 if (python_lib_Math.isnan(a9)) else (b7 if (python_lib_Math.isnan(b7)) else min(a9,b7)))
                        this16[0] = v6
                        this17 = _this1.min
                        a10 = _this1.min[1]
                        b8 = bb1.min[1]
                        v7 = (a10 if (python_lib_Math.isnan(a10)) else (b8 if (python_lib_Math.isnan(b8)) else min(a10,b8)))
                        this17[1] = v7
                        this18 = _this1.min
                        a11 = _this1.min[2]
                        b9 = bb1.min[2]
                        v8 = (a11 if (python_lib_Math.isnan(a11)) else (b9 if (python_lib_Math.isnan(b9)) else min(a11,b9)))
                        this18[2] = v8
                        this19 = _this1.max
                        a12 = _this1.max[0]
                        b10 = bb1.max[0]
                        v9 = (a12 if (python_lib_Math.isnan(a12)) else (b10 if (python_lib_Math.isnan(b10)) else max(a12,b10)))
                        this19[0] = v9
                        this20 = _this1.max
                        a13 = _this1.max[1]
                        b11 = bb1.max[1]
                        v10 = (a13 if (python_lib_Math.isnan(a13)) else (b11 if (python_lib_Math.isnan(b11)) else max(a13,b11)))
                        this20[1] = v10
                        this21 = _this1.max
                        a14 = _this1.max[2]
                        b12 = bb1.max[2]
                        v11 = (a14 if (python_lib_Math.isnan(a14)) else (b12 if (python_lib_Math.isnan(b12)) else max(a14,b12)))
                        this21[2] = v11
                    _g11 = i3
                    _g12 = _gthis.bucketCount
                    while (_g11 < _g12):
                        j2 = _g11
                        _g11 = (_g11 + 1)
                        part.rightCount = (part.rightCount + (buckets[j2] if j2 >= 0 and j2 < len(buckets) else None).count)
                        part.rightArea = (part.rightArea + (buckets[j2] if j2 >= 0 and j2 < len(buckets) else None).area)
                        _this2 = part.rightBBox
                        bb2 = (buckets[j2] if j2 >= 0 and j2 < len(buckets) else None).bbox
                        this22 = _this2.min
                        a15 = _this2.min[0]
                        b13 = bb2.min[0]
                        v12 = (a15 if (python_lib_Math.isnan(a15)) else (b13 if (python_lib_Math.isnan(b13)) else min(a15,b13)))
                        this22[0] = v12
                        this23 = _this2.min
                        a16 = _this2.min[1]
                        b14 = bb2.min[1]
                        v13 = (a16 if (python_lib_Math.isnan(a16)) else (b14 if (python_lib_Math.isnan(b14)) else min(a16,b14)))
                        this23[1] = v13
                        this24 = _this2.min
                        a17 = _this2.min[2]
                        b15 = bb2.min[2]
                        v14 = (a17 if (python_lib_Math.isnan(a17)) else (b15 if (python_lib_Math.isnan(b15)) else min(a17,b15)))
                        this24[2] = v14
                        this25 = _this2.max
                        a18 = _this2.max[0]
                        b16 = bb2.max[0]
                        v15 = (a18 if (python_lib_Math.isnan(a18)) else (b16 if (python_lib_Math.isnan(b16)) else max(a18,b16)))
                        this25[0] = v15
                        this26 = _this2.max
                        a19 = _this2.max[1]
                        b17 = bb2.max[1]
                        v16 = (a19 if (python_lib_Math.isnan(a19)) else (b17 if (python_lib_Math.isnan(b17)) else max(a19,b17)))
                        this26[1] = v16
                        this27 = _this2.max
                        a20 = _this2.max[2]
                        b18 = bb2.max[2]
                        v17 = (a20 if (python_lib_Math.isnan(a20)) else (b18 if (python_lib_Math.isnan(b18)) else max(a20,b18)))
                        this27[2] = v17
                    if ((part.leftCount > 0) and ((part.rightCount > 0))):
                        _this3 = part.leftBBox
                        this28 = _this3.max
                        rhs2 = _this3.min
                        _x3 = (this28[0] - rhs2[0])
                        _y3 = (this28[1] - rhs2[1])
                        _z3 = (this28[2] - rhs2[2])
                        this29 = [None]*3
                        this30 = this29
                        this30[0] = _x3
                        this30[1] = _y3
                        this30[2] = _z3
                        extent1 = this30
                        a21 = extent1[0]
                        x1 = (a21 if (python_lib_Math.isnan(a21)) else (0 if (python_lib_Math.isnan(0)) else max(a21,0)))
                        a22 = extent1[1]
                        y1 = (a22 if (python_lib_Math.isnan(a22)) else (0 if (python_lib_Math.isnan(0)) else max(a22,0)))
                        a23 = extent1[2]
                        z1 = (a23 if (python_lib_Math.isnan(a23)) else (0 if (python_lib_Math.isnan(0)) else max(a23,0)))
                        buildRange1 = ((2 * ((((x1 * z1) + ((x1 * y1))) + ((y1 * z1))))) / part.leftCount)
                        _this4 = part.rightBBox
                        this31 = _this4.max
                        rhs3 = _this4.min
                        _x4 = (this31[0] - rhs3[0])
                        _y4 = (this31[1] - rhs3[1])
                        _z4 = (this31[2] - rhs3[2])
                        this32 = [None]*3
                        this33 = this32
                        this33[0] = _x4
                        this33[1] = _y4
                        this33[2] = _z4
                        extent2 = this33
                        a24 = extent2[0]
                        x2 = (a24 if (python_lib_Math.isnan(a24)) else (0 if (python_lib_Math.isnan(0)) else max(a24,0)))
                        a25 = extent2[1]
                        y2 = (a25 if (python_lib_Math.isnan(a25)) else (0 if (python_lib_Math.isnan(0)) else max(a25,0)))
                        a26 = extent2[2]
                        z2 = (a26 if (python_lib_Math.isnan(a26)) else (0 if (python_lib_Math.isnan(0)) else max(a26,0)))
                        part.SAH = (buildRange1 + (((2 * ((((x2 * z2) + ((x2 * y2))) + ((y2 * z2))))) / part.rightCount)))
                        parts.append(part)
            if (len(parts) == 0):
                return node
            minSAH = Math.POSITIVE_INFINITY
            minPart = None
            _g = 0
            while (_g < len(parts)):
                p = (parts[_g] if _g >= 0 and _g < len(parts) else None)
                _g = (_g + 1)
                if (p.SAH < minSAH):
                    minSAH = p.SAH
                    minPart = p
            def _hx_local_8(f0,f1):
                bb0 = apparentridges_BBox()
                bb1 = apparentridges_BBox()
                bboxAddFace(bb0,f0)
                bboxAddFace(bb1,f1)
                this1 = bb0.min
                rhs = bb0.max
                _x = (this1[0] + rhs[0])
                _y = (this1[1] + rhs[1])
                _z = (this1[2] + rhs[2])
                this1 = [None]*3
                this2 = this1
                this2[0] = _x
                this2[1] = _y
                this2[2] = _z
                this1 = this2
                _x = (this1[0] * 0.5)
                _y = (this1[1] * 0.5)
                _z = (this1[2] * 0.5)
                this1 = [None]*3
                this2 = this1
                this2[0] = _x
                this2[1] = _y
                this2[2] = _z
                v = this2[minPart.axis]
                this1 = bb1.min
                rhs = bb1.max
                _x = (this1[0] + rhs[0])
                _y = (this1[1] + rhs[1])
                _z = (this1[2] + rhs[2])
                this1 = [None]*3
                this2 = this1
                this2[0] = _x
                this2[1] = _y
                this2[2] = _z
                this1 = this2
                _x = (this1[0] * 0.5)
                _y = (this1[1] * 0.5)
                _z = (this1[2] * 0.5)
                this1 = [None]*3
                this2 = this1
                this2[0] = _x
                this2[1] = _y
                this2[2] = _z
                v1 = (v - this2[minPart.axis])
                if (v1 < 0):
                    return -1
                if (v1 > 0):
                    return 1
                return 0
            comp = _hx_local_8
            sorted = _gthis.faces[i0:i1]
            sorted.sort(key= python_lib_Functools.cmp_to_key(comp))
            _g = i0
            _g1 = i1
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                python_internal_ArrayImpl._set(_gthis.faces, i, python_internal_ArrayImpl._get(sorted, (i - i0)))
            m = (i0 + minPart.leftCount)
            node.left = buildRange(i0,m)
            node.right = buildRange(m,i1)
            return node
        buildRange = _hx_local_9
        self.root = buildRange(0,len(self.faces))



class apparentridges_BVHBucket:
    _hx_class_name = "apparentridges.BVHBucket"
    __slots__ = ("min", "max", "count", "area", "bbox")
    _hx_fields = ["min", "max", "count", "area", "bbox"]

    def __init__(self):
        self.max = None
        self.min = None
        self.bbox = apparentridges_BBox()
        self.area = 0
        self.count = 0



class apparentridges_BVHPartition:
    _hx_class_name = "apparentridges.BVHPartition"
    __slots__ = ("planeIndex", "axis", "leftCount", "rightCount", "leftArea", "rightArea", "leftBBox", "rightBBox", "SAH")
    _hx_fields = ["planeIndex", "axis", "leftCount", "rightCount", "leftArea", "rightArea", "leftBBox", "rightBBox", "SAH"]

    def __init__(self):
        self.axis = None
        self.planeIndex = None
        self.SAH = 0
        self.rightArea = 0
        self.leftArea = 0
        self.rightCount = 0
        self.leftCount = 0
        self.leftBBox = apparentridges_BBox()
        self.rightBBox = apparentridges_BBox()



class apparentridges_OBJParser:
    _hx_class_name = "apparentridges.OBJParser"
    __slots__ = ()
    _hx_statics = ["fromFile", "fromString"]

    @staticmethod
    def fromFile(path):
        return apparentridges_OBJParser.fromString(sys_io_File.getContent(path))

    @staticmethod
    def fromString(_hx_str):
        mesh = apparentridges_Mesh()
        mesh.vertices = []
        mesh.faces = []
        lines = _hx_str.split("\n")
        _g = 0
        _g1 = len(lines)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            python_internal_ArrayImpl._set(lines, i, StringTools.trim((lines[i] if i >= 0 and i < len(lines) else None)))
            _this = (lines[i] if i >= 0 and i < len(lines) else None)
            if ((("" if ((0 >= len(_this))) else _this[0])) == "#"):
                continue
            if (len((lines[i] if i >= 0 and i < len(lines) else None)) <= 2):
                continue
            _this1 = (lines[i] if i >= 0 and i < len(lines) else None)
            tok = _this1.split(" ")
            cmd = (tok[0] if 0 < len(tok) else None)
            if (cmd == "v"):
                _x = Std.parseFloat((tok[1] if 1 < len(tok) else None))
                _y = Std.parseFloat((tok[2] if 2 < len(tok) else None))
                _z = Std.parseFloat((tok[3] if 3 < len(tok) else None))
                this1 = [None]*3
                this2 = this1
                this2[0] = _x
                this2[1] = _y
                this2[2] = _z
                v = this2
                _this2 = mesh.vertices
                _this2.append(v)
            elif (cmd == "f"):
                _this3 = (tok[1] if 1 < len(tok) else None)
                a = Std.parseInt(python_internal_ArrayImpl._get(_this3.split("/"), 0))
                _this4 = (tok[2] if 2 < len(tok) else None)
                b = Std.parseInt(python_internal_ArrayImpl._get(_this4.split("/"), 0))
                _this5 = (tok[3] if 3 < len(tok) else None)
                c = Std.parseInt(python_internal_ArrayImpl._get(_this5.split("/"), 0))
                nv = len(mesh.vertices)
                _this6 = mesh.faces
                a1 = ((nv + a) if ((a < 0)) else (a - 1))
                b1 = ((nv + b) if ((b < 0)) else (b - 1))
                c1 = ((nv + c) if ((c < 0)) else (c - 1))
                this3 = [None]*3
                this4 = this3
                this4[0] = a1
                this4[1] = b1
                this4[2] = c1
                _this6.append(this4)
        return mesh


class apparentridges_Line:
    _hx_class_name = "apparentridges.Line"
    __slots__ = ("x1", "y1", "x2", "y2", "opacity1", "opacity2")
    _hx_fields = ["x1", "y1", "x2", "y2", "opacity1", "opacity2"]
    _hx_methods = ["setOpacity", "flip"]

    def __init__(self,_x1,_y1,_x2,_y2):
        self.opacity2 = 1
        self.opacity1 = 1
        self.x1 = _x1
        self.y1 = _y1
        self.x2 = _x2
        self.y2 = _y2

    def setOpacity(self,o1,o2):
        self.opacity1 = o1
        self.opacity2 = o2

    def flip(self):
        tmp = self.x1
        self.x1 = self.x2
        self.x2 = tmp
        tmp = self.y1
        self.y1 = self.y2
        self.y2 = tmp
        tmp = self.opacity1
        self.opacity1 = self.opacity2
        self.opacity2 = tmp



class apparentridges__ApparentRidges_Polyline_Impl_:
    _hx_class_name = "apparentridges._ApparentRidges.Polyline_Impl_"
    __slots__ = ()
    _hx_statics = ["_new", "get_length", "set_length", "startY", "endY", "startX", "endX", "get", "set", "push", "unshift"]
    length = None

    @staticmethod
    def _new():
        this1 = []
        return this1

    @staticmethod
    def get_length(this1):
        return len(this1)

    @staticmethod
    def set_length(this1,v):
        return len(this1)

    @staticmethod
    def startY(this1):
        x = Math.floor(((this1[0] if 0 < len(this1) else None)[1] + 0.5))
        try:
            return int(x)
        except BaseException as _g:
            None
            return None

    @staticmethod
    def endY(this1):
        x = Math.floor((python_internal_ArrayImpl._get(this1, (len(this1) - 1))[1] + 0.5))
        try:
            return int(x)
        except BaseException as _g:
            None
            return None

    @staticmethod
    def startX(this1):
        return (this1[0] if 0 < len(this1) else None)[0]

    @staticmethod
    def endX(this1):
        return python_internal_ArrayImpl._get(this1, (len(this1) - 1))[0]

    @staticmethod
    def get(this1,i):
        return (this1[i] if i >= 0 and i < len(this1) else None)

    @staticmethod
    def set(this1,i,v):
        python_internal_ArrayImpl._set(this1, i, v)
        return v

    @staticmethod
    def push(this1,v):
        this1.append(v)
        return len(this1)

    @staticmethod
    def unshift(this1,v):
        this1.insert(0, v)


class apparentridges_Render:
    _hx_class_name = "apparentridges.Render"
    __slots__ = ("mesh", "lines", "polylines", "focal", "width", "height", "verbose", "didPrecompute")
    _hx_fields = ["mesh", "lines", "polylines", "focal", "width", "height", "verbose", "didPrecompute"]
    _hx_methods = ["clear", "setFocal", "setVerbose", "transform", "scaleRotateTranslate", "autoPlace", "vertices", "edges", "apparentRidges", "buildPolylines"]

    def __init__(self,_mesh,w,h):
        self.polylines = None
        self.didPrecompute = False
        self.verbose = True
        self.focal = 1000
        self.mesh = _mesh
        self.lines = []
        self.width = w
        self.height = h

    def clear(self):
        if (self.lines is not None):
            _this = self.lines
            _hx_len = len(self.lines)
            pos = 0
            if (pos < 0):
                pos = (len(_this) + pos)
            if (pos < 0):
                pos = 0
            res = _this[pos:(pos + _hx_len)]
            del _this[pos:(pos + _hx_len)]
        if (self.polylines is not None):
            _this = self.polylines
            _hx_len = len(self.polylines)
            pos = 0
            if (pos < 0):
                pos = (len(_this) + pos)
            if (pos < 0):
                pos = 0
            res = _this[pos:(pos + _hx_len)]
            del _this[pos:(pos + _hx_len)]

    def setFocal(self,f):
        self.focal = f

    def setVerbose(self,v):
        self.verbose = (v > 0)

    def transform(self,mat4x4):
        _g = 0
        _g1 = len(self.mesh.vertices)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            tmp = self.mesh.vertices
            v = python_internal_ArrayImpl._get(self.mesh.vertices, i)
            _x = (((((((mat4x4[0] if 0 < len(mat4x4) else None) * v[0]) + (((mat4x4[1] if 1 < len(mat4x4) else None) * v[1]))) + (((mat4x4[2] if 2 < len(mat4x4) else None) * v[2]))) + (mat4x4[3] if 3 < len(mat4x4) else None))) / ((((((mat4x4[12] if 12 < len(mat4x4) else None) * v[0]) + (((mat4x4[13] if 13 < len(mat4x4) else None) * v[1]))) + (((mat4x4[14] if 14 < len(mat4x4) else None) * v[2]))) + (mat4x4[15] if 15 < len(mat4x4) else None))))
            _y = (((((((mat4x4[4] if 4 < len(mat4x4) else None) * v[0]) + (((mat4x4[5] if 5 < len(mat4x4) else None) * v[1]))) + (((mat4x4[6] if 6 < len(mat4x4) else None) * v[2]))) + (mat4x4[7] if 7 < len(mat4x4) else None))) / ((((((mat4x4[12] if 12 < len(mat4x4) else None) * v[0]) + (((mat4x4[13] if 13 < len(mat4x4) else None) * v[1]))) + (((mat4x4[14] if 14 < len(mat4x4) else None) * v[2]))) + (mat4x4[15] if 15 < len(mat4x4) else None))))
            _z = (((((((mat4x4[8] if 8 < len(mat4x4) else None) * v[0]) + (((mat4x4[9] if 9 < len(mat4x4) else None) * v[1]))) + (((mat4x4[10] if 10 < len(mat4x4) else None) * v[2]))) + (mat4x4[11] if 11 < len(mat4x4) else None))) / ((((((mat4x4[12] if 12 < len(mat4x4) else None) * v[0]) + (((mat4x4[13] if 13 < len(mat4x4) else None) * v[1]))) + (((mat4x4[14] if 14 < len(mat4x4) else None) * v[2]))) + (mat4x4[15] if 15 < len(mat4x4) else None))))
            this1 = [None]*3
            this2 = this1
            this2[0] = _x
            this2[1] = _y
            this2[2] = _z
            python_internal_ArrayImpl._set(tmp, i, this2)

    def scaleRotateTranslate(self,sx,sy,sz,rx,ry,rz,dx,dy,dz):
        scl = [sx, 0, 0, 0, 0, sy, 0, 0, 0, 0, sz, 0, 0, 0, 0, 1]
        rotx_0 = 1
        rotx_1 = 0
        rotx_2 = 0
        rotx_3 = 0
        rotx_4 = 0
        rotx_5 = (Math.NaN if (((rx == Math.POSITIVE_INFINITY) or ((rx == Math.NEGATIVE_INFINITY)))) else python_lib_Math.cos(rx))
        rotx_6 = -((Math.NaN if (((rx == Math.POSITIVE_INFINITY) or ((rx == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(rx)))
        rotx_7 = 0
        rotx_8 = 0
        rotx_9 = (Math.NaN if (((rx == Math.POSITIVE_INFINITY) or ((rx == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(rx))
        rotx_10 = (Math.NaN if (((rx == Math.POSITIVE_INFINITY) or ((rx == Math.NEGATIVE_INFINITY)))) else python_lib_Math.cos(rx))
        rotx_11 = 0
        rotx_12 = 0
        rotx_13 = 0
        rotx_14 = 0
        rotx_15 = 1
        roty_0 = (Math.NaN if (((ry == Math.POSITIVE_INFINITY) or ((ry == Math.NEGATIVE_INFINITY)))) else python_lib_Math.cos(ry))
        roty_1 = 0
        roty_2 = (Math.NaN if (((ry == Math.POSITIVE_INFINITY) or ((ry == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(ry))
        roty_3 = 0
        roty_4 = 0
        roty_5 = 1
        roty_6 = 0
        roty_7 = 0
        roty_8 = -((Math.NaN if (((ry == Math.POSITIVE_INFINITY) or ((ry == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(ry)))
        roty_9 = 0
        roty_10 = (Math.NaN if (((ry == Math.POSITIVE_INFINITY) or ((ry == Math.NEGATIVE_INFINITY)))) else python_lib_Math.cos(ry))
        roty_11 = 0
        roty_12 = 0
        roty_13 = 0
        roty_14 = 0
        roty_15 = 1
        rotz_0 = (Math.NaN if (((rz == Math.POSITIVE_INFINITY) or ((rz == Math.NEGATIVE_INFINITY)))) else python_lib_Math.cos(rz))
        rotz_1 = -((Math.NaN if (((rz == Math.POSITIVE_INFINITY) or ((rz == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(rz)))
        rotz_2 = 0
        rotz_3 = 0
        rotz_4 = (Math.NaN if (((rz == Math.POSITIVE_INFINITY) or ((rz == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(rz))
        rotz_5 = (Math.NaN if (((rz == Math.POSITIVE_INFINITY) or ((rz == Math.NEGATIVE_INFINITY)))) else python_lib_Math.cos(rz))
        rotz_6 = 0
        rotz_7 = 0
        rotz_8 = 0
        rotz_9 = 0
        rotz_10 = 1
        rotz_11 = 0
        rotz_12 = 0
        rotz_13 = 0
        rotz_14 = 0
        rotz_15 = 1
        trsl_0 = 1
        trsl_1 = 0
        trsl_2 = 0
        trsl_3 = dx
        trsl_4 = 0
        trsl_5 = 1
        trsl_6 = 0
        trsl_7 = dy
        trsl_8 = 0
        trsl_9 = 0
        trsl_10 = 1
        trsl_11 = dz
        trsl_12 = 0
        trsl_13 = 0
        trsl_14 = 0
        trsl_15 = 1
        self.transform(scl)
        B_0 = ((((roty_0 * rotx_0) + ((roty_1 * rotx_4))) + ((roty_2 * rotx_8))) + ((roty_3 * rotx_12)))
        B_1 = ((((roty_0 * rotx_1) + ((roty_1 * rotx_5))) + ((roty_2 * rotx_9))) + ((roty_3 * rotx_13)))
        B_2 = ((((roty_0 * rotx_2) + ((roty_1 * rotx_6))) + ((roty_2 * rotx_10))) + ((roty_3 * rotx_14)))
        B_3 = ((((roty_0 * rotx_3) + ((roty_1 * rotx_7))) + ((roty_2 * rotx_11))) + ((roty_3 * rotx_15)))
        B_4 = ((((roty_4 * rotx_0) + ((roty_5 * rotx_4))) + ((roty_6 * rotx_8))) + ((roty_7 * rotx_12)))
        B_5 = ((((roty_4 * rotx_1) + ((roty_5 * rotx_5))) + ((roty_6 * rotx_9))) + ((roty_7 * rotx_13)))
        B_6 = ((((roty_4 * rotx_2) + ((roty_5 * rotx_6))) + ((roty_6 * rotx_10))) + ((roty_7 * rotx_14)))
        B_7 = ((((roty_4 * rotx_3) + ((roty_5 * rotx_7))) + ((roty_6 * rotx_11))) + ((roty_7 * rotx_15)))
        B_8 = ((((roty_8 * rotx_0) + ((roty_9 * rotx_4))) + ((roty_10 * rotx_8))) + ((roty_11 * rotx_12)))
        B_9 = ((((roty_8 * rotx_1) + ((roty_9 * rotx_5))) + ((roty_10 * rotx_9))) + ((roty_11 * rotx_13)))
        B_10 = ((((roty_8 * rotx_2) + ((roty_9 * rotx_6))) + ((roty_10 * rotx_10))) + ((roty_11 * rotx_14)))
        B_11 = ((((roty_8 * rotx_3) + ((roty_9 * rotx_7))) + ((roty_10 * rotx_11))) + ((roty_11 * rotx_15)))
        B_12 = ((((roty_12 * rotx_0) + ((roty_13 * rotx_4))) + ((roty_14 * rotx_8))) + ((roty_15 * rotx_12)))
        B_13 = ((((roty_12 * rotx_1) + ((roty_13 * rotx_5))) + ((roty_14 * rotx_9))) + ((roty_15 * rotx_13)))
        B_14 = ((((roty_12 * rotx_2) + ((roty_13 * rotx_6))) + ((roty_14 * rotx_10))) + ((roty_15 * rotx_14)))
        B_15 = ((((roty_12 * rotx_3) + ((roty_13 * rotx_7))) + ((roty_14 * rotx_11))) + ((roty_15 * rotx_15)))
        B_01 = ((((rotz_0 * B_0) + ((rotz_1 * B_4))) + ((rotz_2 * B_8))) + ((rotz_3 * B_12)))
        B_16 = ((((rotz_0 * B_1) + ((rotz_1 * B_5))) + ((rotz_2 * B_9))) + ((rotz_3 * B_13)))
        B_21 = ((((rotz_0 * B_2) + ((rotz_1 * B_6))) + ((rotz_2 * B_10))) + ((rotz_3 * B_14)))
        B_31 = ((((rotz_0 * B_3) + ((rotz_1 * B_7))) + ((rotz_2 * B_11))) + ((rotz_3 * B_15)))
        B_41 = ((((rotz_4 * B_0) + ((rotz_5 * B_4))) + ((rotz_6 * B_8))) + ((rotz_7 * B_12)))
        B_51 = ((((rotz_4 * B_1) + ((rotz_5 * B_5))) + ((rotz_6 * B_9))) + ((rotz_7 * B_13)))
        B_61 = ((((rotz_4 * B_2) + ((rotz_5 * B_6))) + ((rotz_6 * B_10))) + ((rotz_7 * B_14)))
        B_71 = ((((rotz_4 * B_3) + ((rotz_5 * B_7))) + ((rotz_6 * B_11))) + ((rotz_7 * B_15)))
        B_81 = ((((rotz_8 * B_0) + ((rotz_9 * B_4))) + ((rotz_10 * B_8))) + ((rotz_11 * B_12)))
        B_91 = ((((rotz_8 * B_1) + ((rotz_9 * B_5))) + ((rotz_10 * B_9))) + ((rotz_11 * B_13)))
        B_101 = ((((rotz_8 * B_2) + ((rotz_9 * B_6))) + ((rotz_10 * B_10))) + ((rotz_11 * B_14)))
        B_111 = ((((rotz_8 * B_3) + ((rotz_9 * B_7))) + ((rotz_10 * B_11))) + ((rotz_11 * B_15)))
        B_121 = ((((rotz_12 * B_0) + ((rotz_13 * B_4))) + ((rotz_14 * B_8))) + ((rotz_15 * B_12)))
        B_131 = ((((rotz_12 * B_1) + ((rotz_13 * B_5))) + ((rotz_14 * B_9))) + ((rotz_15 * B_13)))
        B_141 = ((((rotz_12 * B_2) + ((rotz_13 * B_6))) + ((rotz_14 * B_10))) + ((rotz_15 * B_14)))
        B_151 = ((((rotz_12 * B_3) + ((rotz_13 * B_7))) + ((rotz_14 * B_11))) + ((rotz_15 * B_15)))
        self.transform([((((trsl_0 * B_01) + ((trsl_1 * B_41))) + ((trsl_2 * B_81))) + ((trsl_3 * B_121))), ((((trsl_0 * B_16) + ((trsl_1 * B_51))) + ((trsl_2 * B_91))) + ((trsl_3 * B_131))), ((((trsl_0 * B_21) + ((trsl_1 * B_61))) + ((trsl_2 * B_101))) + ((trsl_3 * B_141))), ((((trsl_0 * B_31) + ((trsl_1 * B_71))) + ((trsl_2 * B_111))) + ((trsl_3 * B_151))), ((((trsl_4 * B_01) + ((trsl_5 * B_41))) + ((trsl_6 * B_81))) + ((trsl_7 * B_121))), ((((trsl_4 * B_16) + ((trsl_5 * B_51))) + ((trsl_6 * B_91))) + ((trsl_7 * B_131))), ((((trsl_4 * B_21) + ((trsl_5 * B_61))) + ((trsl_6 * B_101))) + ((trsl_7 * B_141))), ((((trsl_4 * B_31) + ((trsl_5 * B_71))) + ((trsl_6 * B_111))) + ((trsl_7 * B_151))), ((((trsl_8 * B_01) + ((trsl_9 * B_41))) + ((trsl_10 * B_81))) + ((trsl_11 * B_121))), ((((trsl_8 * B_16) + ((trsl_9 * B_51))) + ((trsl_10 * B_91))) + ((trsl_11 * B_131))), ((((trsl_8 * B_21) + ((trsl_9 * B_61))) + ((trsl_10 * B_101))) + ((trsl_11 * B_141))), ((((trsl_8 * B_31) + ((trsl_9 * B_71))) + ((trsl_10 * B_111))) + ((trsl_11 * B_151))), ((((trsl_12 * B_01) + ((trsl_13 * B_41))) + ((trsl_14 * B_81))) + ((trsl_15 * B_121))), ((((trsl_12 * B_16) + ((trsl_13 * B_51))) + ((trsl_14 * B_91))) + ((trsl_15 * B_131))), ((((trsl_12 * B_21) + ((trsl_13 * B_61))) + ((trsl_14 * B_101))) + ((trsl_15 * B_141))), ((((trsl_12 * B_31) + ((trsl_13 * B_71))) + ((trsl_14 * B_111))) + ((trsl_15 * B_151)))])

    def autoPlace(self,zFactor = None,fFactor = None):
        if (zFactor is None):
            zFactor = 1.5
        if (fFactor is None):
            fFactor = 1.25
        self.mesh.computeBSphere()
        self.transform([1, 0, 0, -self.mesh.bsphere.o[0], 0, 1, 0, -self.mesh.bsphere.o[1], 0, 0, 1, -self.mesh.bsphere.o[2], 0, 0, 0, 1])
        a = self.width
        b = self.height
        r = (((b if ((a > b)) else a)) / 2)
        self.transform([(r / self.mesh.bsphere.r), 0, 0, 0, 0, (r / self.mesh.bsphere.r), 0, 0, 0, 0, (r / self.mesh.bsphere.r), 0, 0, 0, 0, 1])
        self.transform([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, (r * zFactor), 0, 0, 0, 1])
        self.setFocal((r * fFactor))

    def vertices(self):
        _x = (self.width / 2)
        _y = (self.height / 2)
        this1 = [None]*3
        this2 = this1
        this2[0] = _x
        this2[1] = _y
        this2[2] = 0
        offs = this2
        this1 = [None]*3
        this2 = this1
        this2[0] = -1
        this2[1] = -1
        this2[2] = 1
        yflip = this2
        _g = 0
        _g1 = len(self.mesh.vertices)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            v = python_internal_ArrayImpl._get(self.mesh.vertices, i)
            f = self.focal
            _x = ((f * v[0]) / v[2])
            _y = ((f * v[1]) / v[2])
            this1 = [None]*3
            this2 = this1
            this2[0] = _x
            this2[1] = _y
            this2[2] = 0
            this3 = this2
            _x1 = (this3[0] * yflip[0])
            _y1 = (this3[1] * yflip[1])
            _z = (this3[2] * yflip[2])
            this4 = [None]*3
            this5 = this4
            this5[0] = _x1
            this5[1] = _y1
            this5[2] = _z
            this6 = this5
            _x2 = (this6[0] + offs[0])
            _y2 = (this6[1] + offs[1])
            _z1 = (this6[2] + offs[2])
            this7 = [None]*3
            this8 = this7
            this8[0] = _x2
            this8[1] = _y2
            this8[2] = _z1
            p = this8
            _this = self.lines
            x = apparentridges_Line((p[0] - 1),(p[1] - 1),(p[0] + 1),(p[1] + 1))
            _this.append(x)
            _this1 = self.lines
            x1 = apparentridges_Line((p[0] + 1),(p[1] - 1),(p[0] - 1),(p[1] + 1))
            _this1.append(x1)

    def edges(self):
        _x = (self.width / 2)
        _y = (self.height / 2)
        this1 = [None]*3
        this2 = this1
        this2[0] = _x
        this2[1] = _y
        this2[2] = 0
        offs = this2
        this1 = [None]*3
        this2 = this1
        this2[0] = -1
        this2[1] = -1
        this2[2] = 1
        yflip = this2
        _g = 0
        _g1 = len(self.mesh.faces)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            f = python_internal_ArrayImpl._get(self.mesh.faces, i)
            f1 = self.focal
            v = python_internal_ArrayImpl._get(self.mesh.vertices, f[0])
            _x = ((f1 * v[0]) / v[2])
            _y = ((f1 * v[1]) / v[2])
            this1 = [None]*3
            this2 = this1
            this2[0] = _x
            this2[1] = _y
            this2[2] = 0
            this3 = this2
            _x1 = (this3[0] * yflip[0])
            _y1 = (this3[1] * yflip[1])
            _z = (this3[2] * yflip[2])
            this4 = [None]*3
            this5 = this4
            this5[0] = _x1
            this5[1] = _y1
            this5[2] = _z
            this6 = this5
            _x2 = (this6[0] + offs[0])
            _y2 = (this6[1] + offs[1])
            _z1 = (this6[2] + offs[2])
            this7 = [None]*3
            this8 = this7
            this8[0] = _x2
            this8[1] = _y2
            this8[2] = _z1
            p0 = this8
            f2 = self.focal
            v1 = python_internal_ArrayImpl._get(self.mesh.vertices, f[1])
            _x3 = ((f2 * v1[0]) / v1[2])
            _y3 = ((f2 * v1[1]) / v1[2])
            this9 = [None]*3
            this10 = this9
            this10[0] = _x3
            this10[1] = _y3
            this10[2] = 0
            this11 = this10
            _x4 = (this11[0] * yflip[0])
            _y4 = (this11[1] * yflip[1])
            _z2 = (this11[2] * yflip[2])
            this12 = [None]*3
            this13 = this12
            this13[0] = _x4
            this13[1] = _y4
            this13[2] = _z2
            this14 = this13
            _x5 = (this14[0] + offs[0])
            _y5 = (this14[1] + offs[1])
            _z3 = (this14[2] + offs[2])
            this15 = [None]*3
            this16 = this15
            this16[0] = _x5
            this16[1] = _y5
            this16[2] = _z3
            p1 = this16
            f3 = self.focal
            v2 = python_internal_ArrayImpl._get(self.mesh.vertices, f[2])
            _x6 = ((f3 * v2[0]) / v2[2])
            _y6 = ((f3 * v2[1]) / v2[2])
            this17 = [None]*3
            this18 = this17
            this18[0] = _x6
            this18[1] = _y6
            this18[2] = 0
            this19 = this18
            _x7 = (this19[0] * yflip[0])
            _y7 = (this19[1] * yflip[1])
            _z4 = (this19[2] * yflip[2])
            this20 = [None]*3
            this21 = this20
            this21[0] = _x7
            this21[1] = _y7
            this21[2] = _z4
            this22 = this21
            _x8 = (this22[0] + offs[0])
            _y8 = (this22[1] + offs[1])
            _z5 = (this22[2] + offs[2])
            this23 = [None]*3
            this24 = this23
            this24[0] = _x8
            this24[1] = _y8
            this24[2] = _z5
            p2 = this24
            _this = self.lines
            x = apparentridges_Line(p0[0],p0[1],p1[0],p1[1])
            _this.append(x)
            _this1 = self.lines
            x1 = apparentridges_Line(p1[0],p1[1],p2[0],p2[1])
            _this1.append(x1)
            _this2 = self.lines
            x2 = apparentridges_Line(p2[0],p2[1],p0[0],p0[1])
            _this2.append(x2)

    def apparentRidges(self,thresh,cull = None):
        if (cull is None):
            cull = 2
        if (not self.didPrecompute):
            if self.verbose:
                print("precomputing mesh properties...")
            self.mesh.precompute((cull >= 0),self.verbose)
            self.didPrecompute = True
        _x = (self.width / 2)
        _y = (self.height / 2)
        this1 = [None]*3
        this2 = this1
        this2[0] = _x
        this2[1] = _y
        this2[2] = 0
        offs = this2
        this1 = [None]*3
        this2 = this1
        this2[0] = -1
        this2[1] = -1
        this2[2] = 1
        yflip = this2
        this1 = [None]*3
        this2 = this1
        this2[0] = 0
        this2[1] = 0
        this2[2] = 0
        eye = this2
        if self.verbose:
            print("generating apparent ridges...")
        ridges = self.mesh.apparentRidges(eye,thresh)
        if self.verbose:
            print("projecting apparent ridges onto 2D plane...")
        _g = 0
        _g1 = len(ridges)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            if (cull >= 0):
                if ((not self.mesh.visible(eye,(ridges[i] if i >= 0 and i < len(ridges) else None).A,cull)) and (not self.mesh.visible(eye,(ridges[i] if i >= 0 and i < len(ridges) else None).B,cull))):
                    continue
            f = self.focal
            v = (ridges[i] if i >= 0 and i < len(ridges) else None).A
            _x = ((f * v[0]) / v[2])
            _y = ((f * v[1]) / v[2])
            this1 = [None]*3
            this2 = this1
            this2[0] = _x
            this2[1] = _y
            this2[2] = 0
            this3 = this2
            _x1 = (this3[0] * yflip[0])
            _y1 = (this3[1] * yflip[1])
            _z = (this3[2] * yflip[2])
            this4 = [None]*3
            this5 = this4
            this5[0] = _x1
            this5[1] = _y1
            this5[2] = _z
            this6 = this5
            _x2 = (this6[0] + offs[0])
            _y2 = (this6[1] + offs[1])
            _z1 = (this6[2] + offs[2])
            this7 = [None]*3
            this8 = this7
            this8[0] = _x2
            this8[1] = _y2
            this8[2] = _z1
            p0 = this8
            f1 = self.focal
            v1 = (ridges[i] if i >= 0 and i < len(ridges) else None).B
            _x3 = ((f1 * v1[0]) / v1[2])
            _y3 = ((f1 * v1[1]) / v1[2])
            this9 = [None]*3
            this10 = this9
            this10[0] = _x3
            this10[1] = _y3
            this10[2] = 0
            this11 = this10
            _x4 = (this11[0] * yflip[0])
            _y4 = (this11[1] * yflip[1])
            _z2 = (this11[2] * yflip[2])
            this12 = [None]*3
            this13 = this12
            this13[0] = _x4
            this13[1] = _y4
            this13[2] = _z2
            this14 = this13
            _x5 = (this14[0] + offs[0])
            _y5 = (this14[1] + offs[1])
            _z3 = (this14[2] + offs[2])
            this15 = [None]*3
            this16 = this15
            this16[0] = _x5
            this16[1] = _y5
            this16[2] = _z3
            p1 = this16
            l = apparentridges_Line(p0[0],p0[1],p1[0],p1[1])
            l.opacity1 = (ridges[i] if i >= 0 and i < len(ridges) else None).strengthA
            l.opacity2 = (ridges[i] if i >= 0 and i < len(ridges) else None).strengthB
            _this = self.lines
            _this.append(l)
        if self.verbose:
            print("apparent ridges computation finished.")

    def buildPolylines(self,epsilon = None):
        if (epsilon is None):
            epsilon = 1
        _gthis = self
        if self.verbose:
            print("building polylines from ridge segments...")
        self.polylines = []
        def _hx_local_0(a):
            return (not (((((a.y1 < 0) or ((a.y1 > ((_gthis.height - 1))))) or ((a.y2 < 0))) or ((a.y2 > ((_gthis.height - 1)))))))
        self.lines = list(filter(_hx_local_0,self.lines))
        _g = 0
        _g1 = len(self.lines)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            y1 = (self.lines[i] if i >= 0 and i < len(self.lines) else None).y1
            y2 = (self.lines[i] if i >= 0 and i < len(self.lines) else None).y2
            if (y1 > y2):
                (self.lines[i] if i >= 0 and i < len(self.lines) else None).flip()
            elif (y1 == y2):
                if ((self.lines[i] if i >= 0 and i < len(self.lines) else None).x1 > (self.lines[i] if i >= 0 and i < len(self.lines) else None).x2):
                    (self.lines[i] if i >= 0 and i < len(self.lines) else None).flip()
        _g = []
        _g1 = 0
        _g2 = self.height
        while (_g1 < _g2):
            i = _g1
            _g1 = (_g1 + 1)
            _g.append([])
        rows = _g
        _g = []
        _g1 = 0
        _g2 = self.height
        while (_g1 < _g2):
            i = _g1
            _g1 = (_g1 + 1)
            _g.append([])
        ends = _g
        def _hx_local_1(a):
            this1 = []
            p = this1
            _x = a.x1
            _y = a.y1
            _z = a.opacity1
            this1 = [None]*3
            this2 = this1
            this2[0] = _x
            this2[1] = _y
            this2[2] = _z
            p.append(this2)
            _x = a.x2
            _y = a.y2
            _z = a.opacity2
            this1 = [None]*3
            this2 = this1
            this2[0] = _x
            this2[1] = _y
            this2[2] = _z
            p.append(this2)
            return p
        singleton = _hx_local_1
        _g = 0
        _g1 = len(self.lines)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            p = singleton((self.lines[i] if i >= 0 and i < len(self.lines) else None))
            x = Math.floor(((self.lines[i] if i >= 0 and i < len(self.lines) else None).y1 + 0.5))
            _this = None
            try:
                _this = int(x)
            except BaseException as _g2:
                None
                _this = None
            _this1 = (rows[_this] if _this >= 0 and _this < len(rows) else None)
            _this1.append(p)
            x1 = Math.floor(((self.lines[i] if i >= 0 and i < len(self.lines) else None).y2 + 0.5))
            _this2 = None
            try:
                _this2 = int(x1)
            except BaseException as _g3:
                None
                _this2 = None
            _this3 = (ends[_this2] if _this2 >= 0 and _this2 < len(ends) else None)
            _this3.append(p)
        _g = 0
        _g1 = len(rows)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            nj = len((rows[i] if i >= 0 and i < len(rows) else None))
            _g2 = 0
            _g3 = nj
            while (_g2 < _g3):
                _j = _g2
                _g2 = (_g2 + 1)
                j = ((nj - _j) - 1)
                if (python_internal_ArrayImpl._get((rows[i] if i >= 0 and i < len(rows) else None), j) is None):
                    continue
                nk = len((ends[i] if i >= 0 and i < len(ends) else None))
                _g4 = 0
                _g5 = nk
                while (_g4 < _g5):
                    _k = _g4
                    _g4 = (_g4 + 1)
                    k = ((nk - _k) - 1)
                    if (python_internal_ArrayImpl._get((ends[i] if i >= 0 and i < len(ends) else None), k) is None):
                        continue
                    if (python_internal_ArrayImpl._get((rows[i] if i >= 0 and i < len(rows) else None), j) is python_internal_ArrayImpl._get((ends[i] if i >= 0 and i < len(ends) else None), k)):
                        continue
                    this1 = python_internal_ArrayImpl._get((rows[i] if i >= 0 and i < len(rows) else None), j)
                    x = Math.floor((python_internal_ArrayImpl._get(this1, (len(this1) - 1))[1] + 0.5))
                    r = None
                    try:
                        r = int(x)
                    except BaseException as _g6:
                        None
                        r = None
                    v = python_internal_ArrayImpl._get(python_internal_ArrayImpl._get((rows[i] if i >= 0 and i < len(rows) else None), j), 0)[0]
                    this2 = python_internal_ArrayImpl._get((ends[i] if i >= 0 and i < len(ends) else None), k)
                    v1 = (v - python_internal_ArrayImpl._get(this2, (len(this2) - 1))[0])
                    d = Reflect.field(Math,"fabs")(v1)
                    if (d <= epsilon):
                        if (d < 1):
                            this3 = python_internal_ArrayImpl._get(python_internal_ArrayImpl._get((ends[i] if i >= 0 and i < len(ends) else None), k), (len(python_internal_ArrayImpl._get((ends[i] if i >= 0 and i < len(ends) else None), k)) - 1))
                            v2 = (((python_internal_ArrayImpl._get(python_internal_ArrayImpl._get((ends[i] if i >= 0 and i < len(ends) else None), k), (len(python_internal_ArrayImpl._get((ends[i] if i >= 0 and i < len(ends) else None), k)) - 1))[2] + python_internal_ArrayImpl._get(python_internal_ArrayImpl._get((rows[i] if i >= 0 and i < len(rows) else None), j), 0)[2])) / 2)
                            this3[2] = v2
                        _g7 = (1 if ((d < 1)) else 0)
                        _g8 = len(python_internal_ArrayImpl._get((rows[i] if i >= 0 and i < len(rows) else None), j))
                        while (_g7 < _g8):
                            t = _g7
                            _g7 = (_g7 + 1)
                            this4 = python_internal_ArrayImpl._get((ends[i] if i >= 0 and i < len(ends) else None), k)
                            this4.append(python_internal_ArrayImpl._get(python_internal_ArrayImpl._get((rows[i] if i >= 0 and i < len(rows) else None), j), t))
                        python_internal_ArrayImpl.remove((ends[r] if r >= 0 and r < len(ends) else None),python_internal_ArrayImpl._get((rows[i] if i >= 0 and i < len(rows) else None), j))
                        _this = (ends[r] if r >= 0 and r < len(ends) else None)
                        _this.append(python_internal_ArrayImpl._get((ends[i] if i >= 0 and i < len(ends) else None), k))
                        python_internal_ArrayImpl._set((ends[i] if i >= 0 and i < len(ends) else None), k, None)
                        break
        _g = 0
        _g1 = len(ends)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            _g2 = 0
            _g3 = len((ends[i] if i >= 0 and i < len(ends) else None))
            while (_g2 < _g3):
                j = _g2
                _g2 = (_g2 + 1)
                if (python_internal_ArrayImpl._get((ends[i] if i >= 0 and i < len(ends) else None), j) is not None):
                    _this = self.polylines
                    _this.append(python_internal_ArrayImpl._get((ends[i] if i >= 0 and i < len(ends) else None), j))
        def _hx_local_2(p):
            if (len(p) > 2):
                return True
            if (len(p) < 2):
                return False
            v1 = python_internal_ArrayImpl._get(p, 0)
            v2 = python_internal_ArrayImpl._get(p, 1)
            x = (v1[0] - v2[0])
            x1 = (v1[1] - v2[1])
            x2 = (v1[2] - v2[2])
            v = (((x * x) + ((x1 * x1))) + ((x2 * x2)))
            if (((Math.NaN if ((v < 0)) else python_lib_Math.sqrt(v))) < epsilon):
                return False
            return True
        self.polylines = list(filter(_hx_local_2,self.polylines))
        if self.verbose:
            print("polylines built.")



class apparentridges_PixelMap:
    _hx_class_name = "apparentridges.PixelMap"
    __slots__ = ()
    _hx_statics = ["raycast", "depth", "normal", "curvature", "lambertian", "ambientOcclusion", "toPPMString"]

    @staticmethod
    def raycast(render,fun):
        _hx_min = Math.POSITIVE_INFINITY
        _hx_max = Math.NEGATIVE_INFINITY
        width = render.width
        height = render.height
        hw = None
        try:
            hw = int((width / 2))
        except BaseException as _g:
            None
            hw = None
        hw1 = hw
        hh = None
        try:
            hh = int((height / 2))
        except BaseException as _g:
            None
            hh = None
        hh1 = hh
        _g = -hh1
        _g1 = (height - hh1)
        while (_g < _g1):
            y = _g
            _g = (_g + 1)
            _g2 = -hw1
            _g3 = (width - hw1)
            while (_g2 < _g3):
                x = _g2
                _g2 = (_g2 + 1)
                r_tmin = []
                r_tmax = []
                r_o = []
                r_d = []
                r_o1 = r_o
                this1 = [None]*3
                this2 = this1
                this2[0] = 0
                this2[1] = 0
                this2[2] = 0
                python_internal_ArrayImpl._set(r_o1, 0, this2)
                r_d1 = r_d
                _x = -x
                _y = -y
                _z = render.focal
                this3 = [None]*3
                this4 = this3
                this4[0] = _x
                this4[1] = _y
                this4[2] = _z
                python_internal_ArrayImpl._set(r_d1, 0, this4)
                python_internal_ArrayImpl._set(r_tmax, 0, Math.POSITIVE_INFINITY)
                python_internal_ArrayImpl._set(r_tmin, 0, 0)
                this5 = (r_d[0] if 0 < len(r_d) else None)
                v = (((this5[0] * this5[0]) + ((this5[1] * this5[1]))) + ((this5[2] * this5[2])))
                l = (Math.NaN if ((v < 0)) else python_lib_Math.sqrt(v))
                if (l > 0):
                    l = (1 / l)
                    _g4 = this5
                    v1 = (_g4[0] * l)
                    _g4[0] = v1
                    _g5 = this5
                    v2 = (_g5[1] * l)
                    _g5[1] = v2
                    _g6 = this5
                    v3 = (_g6[2] * l)
                    _g6[2] = v3
                else:
                    this5[0] = 0
                    this5[1] = 0
                    this5[2] = 1
                bvh = [render.mesh.bvh]
                hitNode = [None]
                def _hx_local_1(r_tmax,r_tmin,r_d,r_o,hitNode,bvh):
                    def _hx_local_0(node):
                        if ((node.left is None) and ((node.right is None))):
                            tmin = Math.POSITIVE_INFINITY
                            closest = None
                            _g = node.begin
                            _g1 = node.end
                            while (_g < _g1):
                                i = _g
                                _g = (_g + 1)
                                p0 = python_internal_ArrayImpl._get((bvh[0] if 0 < len(bvh) else None).mesh.vertices, python_internal_ArrayImpl._get((bvh[0] if 0 < len(bvh) else None).faces, i)[0])
                                p1 = python_internal_ArrayImpl._get((bvh[0] if 0 < len(bvh) else None).mesh.vertices, python_internal_ArrayImpl._get((bvh[0] if 0 < len(bvh) else None).faces, i)[1])
                                p2 = python_internal_ArrayImpl._get((bvh[0] if 0 < len(bvh) else None).mesh.vertices, python_internal_ArrayImpl._get((bvh[0] if 0 < len(bvh) else None).faces, i)[2])
                                _x = (p1[0] - p0[0])
                                _y = (p1[1] - p0[1])
                                _z = (p1[2] - p0[2])
                                this1 = [None]*3
                                this2 = this1
                                this2[0] = _x
                                this2[1] = _y
                                this2[2] = _z
                                e1 = this2
                                _x1 = (p2[0] - p0[0])
                                _y1 = (p2[1] - p0[1])
                                _z1 = (p2[2] - p0[2])
                                this3 = [None]*3
                                this4 = this3
                                this4[0] = _x1
                                this4[1] = _y1
                                this4[2] = _z1
                                e2 = this4
                                this5 = (r_o[0] if 0 < len(r_o) else None)
                                _x2 = (this5[0] - p0[0])
                                _y2 = (this5[1] - p0[1])
                                _z2 = (this5[2] - p0[2])
                                this6 = [None]*3
                                this7 = this6
                                this7[0] = _x2
                                this7[1] = _y2
                                this7[2] = _z2
                                s = this7
                                this8 = (r_d[0] if 0 < len(r_d) else None)
                                _x3 = (this8[0] * -1.0)
                                _y3 = (this8[1] * -1.0)
                                _z3 = (this8[2] * -1.0)
                                this9 = [None]*3
                                this10 = this9
                                this10[0] = _x3
                                this10[1] = _y3
                                this10[2] = _z3
                                _d = this10
                                _x4 = ((e1[1] * e2[2]) - ((e1[2] * e2[1])))
                                _y4 = ((e1[2] * e2[0]) - ((e1[0] * e2[2])))
                                _z4 = ((e1[0] * e2[1]) - ((e1[1] * e2[0])))
                                this11 = [None]*3
                                this12 = this11
                                this12[0] = _x4
                                this12[1] = _y4
                                this12[2] = _z4
                                v1 = this12
                                denom = (((v1[0] * _d[0]) + ((v1[1] * _d[1]))) + ((v1[2] * _d[2])))
                                h = None
                                if (denom == 0):
                                    h = None
                                else:
                                    _x5 = ((s[1] * e2[2]) - ((s[2] * e2[1])))
                                    _y5 = ((s[2] * e2[0]) - ((s[0] * e2[2])))
                                    _z5 = ((s[0] * e2[1]) - ((s[1] * e2[0])))
                                    this13 = [None]*3
                                    this14 = this13
                                    this14[0] = _x5
                                    this14[1] = _y5
                                    this14[2] = _z5
                                    v11 = this14
                                    _x6 = (((v11[0] * _d[0]) + ((v11[1] * _d[1]))) + ((v11[2] * _d[2])))
                                    _x7 = ((e1[1] * s[2]) - ((e1[2] * s[1])))
                                    _y6 = ((e1[2] * s[0]) - ((e1[0] * s[2])))
                                    _z6 = ((e1[0] * s[1]) - ((e1[1] * s[0])))
                                    this15 = [None]*3
                                    this16 = this15
                                    this16[0] = _x7
                                    this16[1] = _y6
                                    this16[2] = _z6
                                    v12 = this16
                                    _y7 = (((v12[0] * _d[0]) + ((v12[1] * _d[1]))) + ((v12[2] * _d[2])))
                                    _x8 = ((e1[1] * e2[2]) - ((e1[2] * e2[1])))
                                    _y8 = ((e1[2] * e2[0]) - ((e1[0] * e2[2])))
                                    _z7 = ((e1[0] * e2[1]) - ((e1[1] * e2[0])))
                                    this17 = [None]*3
                                    this18 = this17
                                    this18[0] = _x8
                                    this18[1] = _y8
                                    this18[2] = _z7
                                    v13 = this18
                                    _z8 = (((v13[0] * s[0]) + ((v13[1] * s[1]))) + ((v13[2] * s[2])))
                                    this19 = [None]*3
                                    this20 = this19
                                    this20[0] = _x6
                                    this20[1] = _y7
                                    this20[2] = _z8
                                    this21 = this20
                                    rhs = (1 / denom)
                                    _x9 = (this21[0] * rhs)
                                    _y9 = (this21[1] * rhs)
                                    _z9 = (this21[2] * rhs)
                                    this22 = [None]*3
                                    this23 = this22
                                    this23[0] = _x9
                                    this23[1] = _y9
                                    this23[2] = _z9
                                    uvt = this23
                                    u = uvt[0]
                                    v = uvt[1]
                                    t = uvt[2]
                                    if (((((u < 0) or ((v < 0))) or ((((1 - u) - v) < 0))) or ((t < (r_tmin[0] if 0 < len(r_tmin) else None)))) or ((t > (r_tmax[0] if 0 < len(r_tmax) else None)))):
                                        h = None
                                    else:
                                        h1 = apparentridges_RayHit(t)
                                        h1.u = u
                                        h1.v = v
                                        h = h1
                                if (h is not None):
                                    h.face = python_internal_ArrayImpl._get((bvh[0] if 0 < len(bvh) else None).faces, i)
                                    if (tmin > h.t):
                                        tmin = h.t
                                        closest = h
                            return closest
                        bb = node.left.bbox
                        tx1 = (((bb.min[0] - (r_o[0] if 0 < len(r_o) else None)[0])) / (r_d[0] if 0 < len(r_d) else None)[0])
                        tx2 = (((bb.max[0] - (r_o[0] if 0 < len(r_o) else None)[0])) / (r_d[0] if 0 < len(r_d) else None)[0])
                        ty1 = (((bb.min[1] - (r_o[0] if 0 < len(r_o) else None)[1])) / (r_d[0] if 0 < len(r_d) else None)[1])
                        ty2 = (((bb.max[1] - (r_o[0] if 0 < len(r_o) else None)[1])) / (r_d[0] if 0 < len(r_d) else None)[1])
                        tz1 = (((bb.min[2] - (r_o[0] if 0 < len(r_o) else None)[2])) / (r_d[0] if 0 < len(r_d) else None)[2])
                        tz2 = (((bb.max[2] - (r_o[0] if 0 < len(r_o) else None)[2])) / (r_d[0] if 0 < len(r_d) else None)[2])
                        a = (tx1 if (python_lib_Math.isnan(tx1)) else (tx2 if (python_lib_Math.isnan(tx2)) else min(tx1,tx2)))
                        b = (ty1 if (python_lib_Math.isnan(ty1)) else (ty2 if (python_lib_Math.isnan(ty2)) else min(ty1,ty2)))
                        a1 = (a if (python_lib_Math.isnan(a)) else (b if (python_lib_Math.isnan(b)) else max(a,b)))
                        b = (tz1 if (python_lib_Math.isnan(tz1)) else (tz2 if (python_lib_Math.isnan(tz2)) else min(tz1,tz2)))
                        t1 = (a1 if (python_lib_Math.isnan(a1)) else (b if (python_lib_Math.isnan(b)) else max(a1,b)))
                        a = (tx1 if (python_lib_Math.isnan(tx1)) else (tx2 if (python_lib_Math.isnan(tx2)) else max(tx1,tx2)))
                        b = (ty1 if (python_lib_Math.isnan(ty1)) else (ty2 if (python_lib_Math.isnan(ty2)) else max(ty1,ty2)))
                        a1 = (a if (python_lib_Math.isnan(a)) else (b if (python_lib_Math.isnan(b)) else min(a,b)))
                        b = (tz1 if (python_lib_Math.isnan(tz1)) else (tz2 if (python_lib_Math.isnan(tz2)) else max(tz1,tz2)))
                        t2 = (a1 if (python_lib_Math.isnan(a1)) else (b if (python_lib_Math.isnan(b)) else min(a1,b)))
                        hitL = None
                        if ((t2 - t1) < 0):
                            hitL = None
                        elif ((t1 > (r_tmax[0] if 0 < len(r_tmax) else None)) or ((t2 < (r_tmin[0] if 0 < len(r_tmin) else None)))):
                            hitL = None
                        else:
                            h = apparentridges_RayHit(t1)
                            h.t2 = t2
                            hitL = h
                        bb = node.right.bbox
                        tx1 = (((bb.min[0] - (r_o[0] if 0 < len(r_o) else None)[0])) / (r_d[0] if 0 < len(r_d) else None)[0])
                        tx2 = (((bb.max[0] - (r_o[0] if 0 < len(r_o) else None)[0])) / (r_d[0] if 0 < len(r_d) else None)[0])
                        ty1 = (((bb.min[1] - (r_o[0] if 0 < len(r_o) else None)[1])) / (r_d[0] if 0 < len(r_d) else None)[1])
                        ty2 = (((bb.max[1] - (r_o[0] if 0 < len(r_o) else None)[1])) / (r_d[0] if 0 < len(r_d) else None)[1])
                        tz1 = (((bb.min[2] - (r_o[0] if 0 < len(r_o) else None)[2])) / (r_d[0] if 0 < len(r_d) else None)[2])
                        tz2 = (((bb.max[2] - (r_o[0] if 0 < len(r_o) else None)[2])) / (r_d[0] if 0 < len(r_d) else None)[2])
                        a = (tx1 if (python_lib_Math.isnan(tx1)) else (tx2 if (python_lib_Math.isnan(tx2)) else min(tx1,tx2)))
                        b = (ty1 if (python_lib_Math.isnan(ty1)) else (ty2 if (python_lib_Math.isnan(ty2)) else min(ty1,ty2)))
                        a1 = (a if (python_lib_Math.isnan(a)) else (b if (python_lib_Math.isnan(b)) else max(a,b)))
                        b = (tz1 if (python_lib_Math.isnan(tz1)) else (tz2 if (python_lib_Math.isnan(tz2)) else min(tz1,tz2)))
                        t1 = (a1 if (python_lib_Math.isnan(a1)) else (b if (python_lib_Math.isnan(b)) else max(a1,b)))
                        a = (tx1 if (python_lib_Math.isnan(tx1)) else (tx2 if (python_lib_Math.isnan(tx2)) else max(tx1,tx2)))
                        b = (ty1 if (python_lib_Math.isnan(ty1)) else (ty2 if (python_lib_Math.isnan(ty2)) else max(ty1,ty2)))
                        a1 = (a if (python_lib_Math.isnan(a)) else (b if (python_lib_Math.isnan(b)) else min(a,b)))
                        b = (tz1 if (python_lib_Math.isnan(tz1)) else (tz2 if (python_lib_Math.isnan(tz2)) else max(tz1,tz2)))
                        t2 = (a1 if (python_lib_Math.isnan(a1)) else (b if (python_lib_Math.isnan(b)) else min(a1,b)))
                        hitR = None
                        if ((t2 - t1) < 0):
                            hitR = None
                        elif ((t1 > (r_tmax[0] if 0 < len(r_tmax) else None)) or ((t2 < (r_tmin[0] if 0 < len(r_tmin) else None)))):
                            hitR = None
                        else:
                            h = apparentridges_RayHit(t1)
                            h.t2 = t2
                            hitR = h
                        if ((hitL is not None) and ((hitR is None))):
                            return (hitNode[0] if 0 < len(hitNode) else None)(node.left)
                        elif ((hitL is None) and ((hitR is not None))):
                            return (hitNode[0] if 0 < len(hitNode) else None)(node.right)
                        elif ((hitL is None) and ((hitR is None))):
                            return None
                        first = None
                        second = None
                        if (hitL.t < hitR.t):
                            first = node.left
                            second = node.right
                        else:
                            first = node.right
                            second = node.left
                        h = (hitNode[0] if 0 < len(hitNode) else None)(first)
                        tmp = None
                        if (h is not None):
                            a = hitL.t
                            b = hitR.t
                            tmp = (h.t >= ((a if (python_lib_Math.isnan(a)) else (b if (python_lib_Math.isnan(b)) else max(a,b)))))
                        else:
                            tmp = True
                        if tmp:
                            h2 = (hitNode[0] if 0 < len(hitNode) else None)(second)
                            if (h2 is not None):
                                if ((h is None) or ((h2.t < h.t))):
                                    return h2
                        return h
                    return _hx_local_0
                python_internal_ArrayImpl._set(hitNode, 0, _hx_local_1(r_tmax,r_tmin,r_d,r_o,hitNode,bvh))
                h = (hitNode[0] if 0 < len(hitNode) else None)((bvh[0] if 0 < len(bvh) else None).root)
                fun(h,(x + hh1),(y + hh1))

    @staticmethod
    def depth(render,normalize = None):
        if (normalize is None):
            normalize = False
        this1 = [None]*(render.width * render.height)
        data = this1
        _hx_min = Math.POSITIVE_INFINITY
        _hx_max = Math.NEGATIVE_INFINITY
        def _hx_local_0(h,x,y):
            nonlocal _hx_max
            nonlocal _hx_min
            if (h is None):
                val = Math.POSITIVE_INFINITY
                data[((y * render.width) + x)] = val
            else:
                b = h.t
                if (not python_lib_Math.isnan(_hx_min)):
                    _hx_min = (b if (python_lib_Math.isnan(b)) else min(_hx_min,b))
                b = h.t
                if (not python_lib_Math.isnan(_hx_max)):
                    _hx_max = (b if (python_lib_Math.isnan(b)) else max(_hx_max,b))
                val = h.t
                data[((y * render.width) + x)] = val
        apparentridges_PixelMap.raycast(render,_hx_local_0)
        if normalize:
            _g = 0
            _g1 = len(data)
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                if (data[i] != Math.POSITIVE_INFINITY):
                    val = (1 - ((((data[i] - _hx_min)) / ((_hx_max - _hx_min)))))
                    data[i] = val
                else:
                    data[i] = 0
        return data

    @staticmethod
    def normal(render):
        this1 = [None]*((render.width * render.height) * 3)
        data = this1
        def _hx_local_0(h,x,y):
            idx = ((((y * render.width) + x)) * 3)
            if (h is None):
                data[idx] = 0
                data[(idx + 1)] = 0
                data[(idx + 2)] = 0
            else:
                f = h.face
                n0 = python_internal_ArrayImpl._get(render.mesh.normals, f[0])
                n1 = python_internal_ArrayImpl._get(render.mesh.normals, f[1])
                n2 = python_internal_ArrayImpl._get(render.mesh.normals, f[2])
                rhs = ((1 - h.u) - h.v)
                _x = (n0[0] * rhs)
                _y = (n0[1] * rhs)
                _z = (n0[2] * rhs)
                this1 = [None]*3
                this2 = this1
                this2[0] = _x
                this2[1] = _y
                this2[2] = _z
                this1 = this2
                rhs = h.u
                _x = (n1[0] * rhs)
                _y = (n1[1] * rhs)
                _z = (n1[2] * rhs)
                this2 = [None]*3
                this3 = this2
                this3[0] = _x
                this3[1] = _y
                this3[2] = _z
                rhs = this3
                _x = (this1[0] + rhs[0])
                _y = (this1[1] + rhs[1])
                _z = (this1[2] + rhs[2])
                this1 = [None]*3
                this2 = this1
                this2[0] = _x
                this2[1] = _y
                this2[2] = _z
                this1 = this2
                rhs = h.v
                _x = (n2[0] * rhs)
                _y = (n2[1] * rhs)
                _z = (n2[2] * rhs)
                this2 = [None]*3
                this3 = this2
                this3[0] = _x
                this3[1] = _y
                this3[2] = _z
                rhs = this3
                _x = (this1[0] + rhs[0])
                _y = (this1[1] + rhs[1])
                _z = (this1[2] + rhs[2])
                this1 = [None]*3
                this2 = this1
                this2[0] = _x
                this2[1] = _y
                this2[2] = _z
                n = this2
                val = n[0]
                data[idx] = val
                val = n[1]
                data[(idx + 1)] = val
                val = n[2]
                data[(idx + 2)] = val
        apparentridges_PixelMap.raycast(render,_hx_local_0)
        return data

    @staticmethod
    def curvature(render):
        this1 = [None]*((render.width * render.height) * 2)
        data = this1
        def _hx_local_0(h,x,y):
            idx = ((((y * render.width) + x)) * 2)
            if (h is None):
                data[idx] = 0
                data[(idx + 1)] = 0
            else:
                f = h.face
                c1a = python_internal_ArrayImpl._get(render.mesh.curv1, f[0])
                c1b = python_internal_ArrayImpl._get(render.mesh.curv1, f[1])
                c1c = python_internal_ArrayImpl._get(render.mesh.curv1, f[2])
                c2a = python_internal_ArrayImpl._get(render.mesh.curv2, f[0])
                c2b = python_internal_ArrayImpl._get(render.mesh.curv2, f[1])
                c2c = python_internal_ArrayImpl._get(render.mesh.curv2, f[2])
                c1 = (((c1a * (((1 - h.u) - h.v))) + ((c1b * h.u))) + ((c1c * h.v)))
                c2 = (((c2a * (((1 - h.u) - h.v))) + ((c2b * h.u))) + ((c2c * h.v)))
                data[idx] = c1
                data[(idx + 1)] = c2
        apparentridges_PixelMap.raycast(render,_hx_local_0)
        return data

    @staticmethod
    def lambertian(render,light,normalize = None):
        if (normalize is None):
            normalize = True
        this1 = [None]*(render.width * render.height)
        data = this1
        _hx_min = Math.POSITIVE_INFINITY
        _hx_max = Math.NEGATIVE_INFINITY
        def _hx_local_0(h,x,y):
            nonlocal _hx_min
            nonlocal _hx_max
            idx = ((y * render.width) + x)
            if (h is None):
                val = Math.NEGATIVE_INFINITY
                data[idx] = val
            else:
                f = h.face
                n0 = python_internal_ArrayImpl._get(render.mesh.normals, f[0])
                n1 = python_internal_ArrayImpl._get(render.mesh.normals, f[1])
                n2 = python_internal_ArrayImpl._get(render.mesh.normals, f[2])
                rhs = ((1 - h.u) - h.v)
                _x = (n0[0] * rhs)
                _y = (n0[1] * rhs)
                _z = (n0[2] * rhs)
                this1 = [None]*3
                this2 = this1
                this2[0] = _x
                this2[1] = _y
                this2[2] = _z
                this1 = this2
                rhs = h.u
                _x = (n1[0] * rhs)
                _y = (n1[1] * rhs)
                _z = (n1[2] * rhs)
                this2 = [None]*3
                this3 = this2
                this3[0] = _x
                this3[1] = _y
                this3[2] = _z
                rhs = this3
                _x = (this1[0] + rhs[0])
                _y = (this1[1] + rhs[1])
                _z = (this1[2] + rhs[2])
                this1 = [None]*3
                this2 = this1
                this2[0] = _x
                this2[1] = _y
                this2[2] = _z
                this1 = this2
                rhs = h.v
                _x = (n2[0] * rhs)
                _y = (n2[1] * rhs)
                _z = (n2[2] * rhs)
                this2 = [None]*3
                this3 = this2
                this3[0] = _x
                this3[1] = _y
                this3[2] = _z
                rhs = this3
                _x = (this1[0] + rhs[0])
                _y = (this1[1] + rhs[1])
                _z = (this1[2] + rhs[2])
                this1 = [None]*3
                this2 = this1
                this2[0] = _x
                this2[1] = _y
                this2[2] = _z
                n = this2
                ndotl = (((n[0] * light[0]) + ((n[1] * light[1]))) + ((n[2] * light[2])))
                if (not python_lib_Math.isnan(_hx_min)):
                    _hx_min = (ndotl if (python_lib_Math.isnan(ndotl)) else min(_hx_min,ndotl))
                if (not python_lib_Math.isnan(_hx_max)):
                    _hx_max = (ndotl if (python_lib_Math.isnan(ndotl)) else max(_hx_max,ndotl))
                data[idx] = ndotl
        apparentridges_PixelMap.raycast(render,_hx_local_0)
        if normalize:
            _g = 0
            _g1 = len(data)
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                if (data[i] != Math.NEGATIVE_INFINITY):
                    val = (((data[i] - _hx_min)) / ((_hx_max - _hx_min)))
                    data[i] = val
                else:
                    data[i] = 0
        return data

    @staticmethod
    def ambientOcclusion(render,numSamples = None,normalize = None):
        if (numSamples is None):
            numSamples = 32
        if (normalize is None):
            normalize = True
        this1 = [None]*(render.width * render.height)
        data = this1
        _hx_min = Math.POSITIVE_INFINITY
        _hx_max = Math.NEGATIVE_INFINITY
        def _hx_local_3(h,x,y):
            nonlocal _hx_min
            nonlocal _hx_max
            idx = ((y * render.width) + x)
            if (h is None):
                val = Math.NEGATIVE_INFINITY
                data[idx] = val
            else:
                f = h.face
                p0 = python_internal_ArrayImpl._get(render.mesh.vertices, f[0])
                p1 = python_internal_ArrayImpl._get(render.mesh.vertices, f[1])
                p2 = python_internal_ArrayImpl._get(render.mesh.vertices, f[2])
                rhs = ((1 - h.u) - h.v)
                _x = (p0[0] * rhs)
                _y = (p0[1] * rhs)
                _z = (p0[2] * rhs)
                this1 = [None]*3
                this2 = this1
                this2[0] = _x
                this2[1] = _y
                this2[2] = _z
                this1 = this2
                rhs = h.u
                _x = (p1[0] * rhs)
                _y = (p1[1] * rhs)
                _z = (p1[2] * rhs)
                this2 = [None]*3
                this3 = this2
                this3[0] = _x
                this3[1] = _y
                this3[2] = _z
                rhs = this3
                _x = (this1[0] + rhs[0])
                _y = (this1[1] + rhs[1])
                _z = (this1[2] + rhs[2])
                this1 = [None]*3
                this2 = this1
                this2[0] = _x
                this2[1] = _y
                this2[2] = _z
                this1 = this2
                rhs = h.v
                _x = (p2[0] * rhs)
                _y = (p2[1] * rhs)
                _z = (p2[2] * rhs)
                this2 = [None]*3
                this3 = this2
                this3[0] = _x
                this3[1] = _y
                this3[2] = _z
                rhs = this3
                _x = (this1[0] + rhs[0])
                _y = (this1[1] + rhs[1])
                _z = (this1[2] + rhs[2])
                this1 = [None]*3
                this2 = this1
                this2[0] = _x
                this2[1] = _y
                this2[2] = _z
                o = this2
                cnt = 0
                _g = 0
                _g1 = numSamples
                while (_g < _g1):
                    i = _g
                    _g = (_g + 1)
                    Xi1 = python_lib_Random.random()
                    Xi2 = python_lib_Random.random()
                    theta = Math.acos(Xi1)
                    phi = ((2 * Math.PI) * Xi2)
                    xs = (((Math.NaN if (((theta == Math.POSITIVE_INFINITY) or ((theta == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(theta))) * ((Math.NaN if (((phi == Math.POSITIVE_INFINITY) or ((phi == Math.NEGATIVE_INFINITY)))) else python_lib_Math.cos(phi))))
                    ys = (((Math.NaN if (((theta == Math.POSITIVE_INFINITY) or ((theta == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(theta))) * ((Math.NaN if (((phi == Math.POSITIVE_INFINITY) or ((phi == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(phi))))
                    zs = (Math.NaN if (((theta == Math.POSITIVE_INFINITY) or ((theta == Math.NEGATIVE_INFINITY)))) else python_lib_Math.cos(theta))
                    this1 = [None]*3
                    this2 = this1
                    this2[0] = xs
                    this2[1] = ys
                    this2[2] = zs
                    v = this2
                    d = v
                    if (python_lib_Random.random() < 0.5):
                        v1 = -d[2]
                        d[2] = v1
                    r_tmin = []
                    r_tmax = []
                    r_o = []
                    r_d = []
                    python_internal_ArrayImpl._set(r_d, 0, d)
                    python_internal_ArrayImpl._set(r_o, 0, o)
                    python_internal_ArrayImpl._set(r_tmin, 0, 0.1)
                    python_internal_ArrayImpl._set(r_tmax, 0, Math.POSITIVE_INFINITY)
                    bvh = [render.mesh.bvh]
                    hitNode = [None]
                    def _hx_local_1(r_tmax,r_tmin,r_d,r_o,hitNode,bvh):
                        def _hx_local_0(node):
                            if ((node.left is None) and ((node.right is None))):
                                tmin = Math.POSITIVE_INFINITY
                                closest = None
                                _g = node.begin
                                _g1 = node.end
                                while (_g < _g1):
                                    i = _g
                                    _g = (_g + 1)
                                    p0 = python_internal_ArrayImpl._get((bvh[0] if 0 < len(bvh) else None).mesh.vertices, python_internal_ArrayImpl._get((bvh[0] if 0 < len(bvh) else None).faces, i)[0])
                                    p1 = python_internal_ArrayImpl._get((bvh[0] if 0 < len(bvh) else None).mesh.vertices, python_internal_ArrayImpl._get((bvh[0] if 0 < len(bvh) else None).faces, i)[1])
                                    p2 = python_internal_ArrayImpl._get((bvh[0] if 0 < len(bvh) else None).mesh.vertices, python_internal_ArrayImpl._get((bvh[0] if 0 < len(bvh) else None).faces, i)[2])
                                    _x = (p1[0] - p0[0])
                                    _y = (p1[1] - p0[1])
                                    _z = (p1[2] - p0[2])
                                    this1 = [None]*3
                                    this2 = this1
                                    this2[0] = _x
                                    this2[1] = _y
                                    this2[2] = _z
                                    e1 = this2
                                    _x1 = (p2[0] - p0[0])
                                    _y1 = (p2[1] - p0[1])
                                    _z1 = (p2[2] - p0[2])
                                    this3 = [None]*3
                                    this4 = this3
                                    this4[0] = _x1
                                    this4[1] = _y1
                                    this4[2] = _z1
                                    e2 = this4
                                    this5 = (r_o[0] if 0 < len(r_o) else None)
                                    _x2 = (this5[0] - p0[0])
                                    _y2 = (this5[1] - p0[1])
                                    _z2 = (this5[2] - p0[2])
                                    this6 = [None]*3
                                    this7 = this6
                                    this7[0] = _x2
                                    this7[1] = _y2
                                    this7[2] = _z2
                                    s = this7
                                    this8 = (r_d[0] if 0 < len(r_d) else None)
                                    _x3 = (this8[0] * -1.0)
                                    _y3 = (this8[1] * -1.0)
                                    _z3 = (this8[2] * -1.0)
                                    this9 = [None]*3
                                    this10 = this9
                                    this10[0] = _x3
                                    this10[1] = _y3
                                    this10[2] = _z3
                                    _d = this10
                                    _x4 = ((e1[1] * e2[2]) - ((e1[2] * e2[1])))
                                    _y4 = ((e1[2] * e2[0]) - ((e1[0] * e2[2])))
                                    _z4 = ((e1[0] * e2[1]) - ((e1[1] * e2[0])))
                                    this11 = [None]*3
                                    this12 = this11
                                    this12[0] = _x4
                                    this12[1] = _y4
                                    this12[2] = _z4
                                    v1 = this12
                                    denom = (((v1[0] * _d[0]) + ((v1[1] * _d[1]))) + ((v1[2] * _d[2])))
                                    h = None
                                    if (denom == 0):
                                        h = None
                                    else:
                                        _x5 = ((s[1] * e2[2]) - ((s[2] * e2[1])))
                                        _y5 = ((s[2] * e2[0]) - ((s[0] * e2[2])))
                                        _z5 = ((s[0] * e2[1]) - ((s[1] * e2[0])))
                                        this13 = [None]*3
                                        this14 = this13
                                        this14[0] = _x5
                                        this14[1] = _y5
                                        this14[2] = _z5
                                        v11 = this14
                                        _x6 = (((v11[0] * _d[0]) + ((v11[1] * _d[1]))) + ((v11[2] * _d[2])))
                                        _x7 = ((e1[1] * s[2]) - ((e1[2] * s[1])))
                                        _y6 = ((e1[2] * s[0]) - ((e1[0] * s[2])))
                                        _z6 = ((e1[0] * s[1]) - ((e1[1] * s[0])))
                                        this15 = [None]*3
                                        this16 = this15
                                        this16[0] = _x7
                                        this16[1] = _y6
                                        this16[2] = _z6
                                        v12 = this16
                                        _y7 = (((v12[0] * _d[0]) + ((v12[1] * _d[1]))) + ((v12[2] * _d[2])))
                                        _x8 = ((e1[1] * e2[2]) - ((e1[2] * e2[1])))
                                        _y8 = ((e1[2] * e2[0]) - ((e1[0] * e2[2])))
                                        _z7 = ((e1[0] * e2[1]) - ((e1[1] * e2[0])))
                                        this17 = [None]*3
                                        this18 = this17
                                        this18[0] = _x8
                                        this18[1] = _y8
                                        this18[2] = _z7
                                        v13 = this18
                                        _z8 = (((v13[0] * s[0]) + ((v13[1] * s[1]))) + ((v13[2] * s[2])))
                                        this19 = [None]*3
                                        this20 = this19
                                        this20[0] = _x6
                                        this20[1] = _y7
                                        this20[2] = _z8
                                        this21 = this20
                                        rhs = (1 / denom)
                                        _x9 = (this21[0] * rhs)
                                        _y9 = (this21[1] * rhs)
                                        _z9 = (this21[2] * rhs)
                                        this22 = [None]*3
                                        this23 = this22
                                        this23[0] = _x9
                                        this23[1] = _y9
                                        this23[2] = _z9
                                        uvt = this23
                                        u = uvt[0]
                                        v = uvt[1]
                                        t = uvt[2]
                                        if (((((u < 0) or ((v < 0))) or ((((1 - u) - v) < 0))) or ((t < (r_tmin[0] if 0 < len(r_tmin) else None)))) or ((t > (r_tmax[0] if 0 < len(r_tmax) else None)))):
                                            h = None
                                        else:
                                            h1 = apparentridges_RayHit(t)
                                            h1.u = u
                                            h1.v = v
                                            h = h1
                                    if (h is not None):
                                        h.face = python_internal_ArrayImpl._get((bvh[0] if 0 < len(bvh) else None).faces, i)
                                        if (tmin > h.t):
                                            tmin = h.t
                                            closest = h
                                return closest
                            bb = node.left.bbox
                            tx1 = (((bb.min[0] - (r_o[0] if 0 < len(r_o) else None)[0])) / (r_d[0] if 0 < len(r_d) else None)[0])
                            tx2 = (((bb.max[0] - (r_o[0] if 0 < len(r_o) else None)[0])) / (r_d[0] if 0 < len(r_d) else None)[0])
                            ty1 = (((bb.min[1] - (r_o[0] if 0 < len(r_o) else None)[1])) / (r_d[0] if 0 < len(r_d) else None)[1])
                            ty2 = (((bb.max[1] - (r_o[0] if 0 < len(r_o) else None)[1])) / (r_d[0] if 0 < len(r_d) else None)[1])
                            tz1 = (((bb.min[2] - (r_o[0] if 0 < len(r_o) else None)[2])) / (r_d[0] if 0 < len(r_d) else None)[2])
                            tz2 = (((bb.max[2] - (r_o[0] if 0 < len(r_o) else None)[2])) / (r_d[0] if 0 < len(r_d) else None)[2])
                            a = (tx1 if (python_lib_Math.isnan(tx1)) else (tx2 if (python_lib_Math.isnan(tx2)) else min(tx1,tx2)))
                            b = (ty1 if (python_lib_Math.isnan(ty1)) else (ty2 if (python_lib_Math.isnan(ty2)) else min(ty1,ty2)))
                            a1 = (a if (python_lib_Math.isnan(a)) else (b if (python_lib_Math.isnan(b)) else max(a,b)))
                            b = (tz1 if (python_lib_Math.isnan(tz1)) else (tz2 if (python_lib_Math.isnan(tz2)) else min(tz1,tz2)))
                            t1 = (a1 if (python_lib_Math.isnan(a1)) else (b if (python_lib_Math.isnan(b)) else max(a1,b)))
                            a = (tx1 if (python_lib_Math.isnan(tx1)) else (tx2 if (python_lib_Math.isnan(tx2)) else max(tx1,tx2)))
                            b = (ty1 if (python_lib_Math.isnan(ty1)) else (ty2 if (python_lib_Math.isnan(ty2)) else max(ty1,ty2)))
                            a1 = (a if (python_lib_Math.isnan(a)) else (b if (python_lib_Math.isnan(b)) else min(a,b)))
                            b = (tz1 if (python_lib_Math.isnan(tz1)) else (tz2 if (python_lib_Math.isnan(tz2)) else max(tz1,tz2)))
                            t2 = (a1 if (python_lib_Math.isnan(a1)) else (b if (python_lib_Math.isnan(b)) else min(a1,b)))
                            hitL = None
                            if ((t2 - t1) < 0):
                                hitL = None
                            elif ((t1 > (r_tmax[0] if 0 < len(r_tmax) else None)) or ((t2 < (r_tmin[0] if 0 < len(r_tmin) else None)))):
                                hitL = None
                            else:
                                h = apparentridges_RayHit(t1)
                                h.t2 = t2
                                hitL = h
                            bb = node.right.bbox
                            tx1 = (((bb.min[0] - (r_o[0] if 0 < len(r_o) else None)[0])) / (r_d[0] if 0 < len(r_d) else None)[0])
                            tx2 = (((bb.max[0] - (r_o[0] if 0 < len(r_o) else None)[0])) / (r_d[0] if 0 < len(r_d) else None)[0])
                            ty1 = (((bb.min[1] - (r_o[0] if 0 < len(r_o) else None)[1])) / (r_d[0] if 0 < len(r_d) else None)[1])
                            ty2 = (((bb.max[1] - (r_o[0] if 0 < len(r_o) else None)[1])) / (r_d[0] if 0 < len(r_d) else None)[1])
                            tz1 = (((bb.min[2] - (r_o[0] if 0 < len(r_o) else None)[2])) / (r_d[0] if 0 < len(r_d) else None)[2])
                            tz2 = (((bb.max[2] - (r_o[0] if 0 < len(r_o) else None)[2])) / (r_d[0] if 0 < len(r_d) else None)[2])
                            a = (tx1 if (python_lib_Math.isnan(tx1)) else (tx2 if (python_lib_Math.isnan(tx2)) else min(tx1,tx2)))
                            b = (ty1 if (python_lib_Math.isnan(ty1)) else (ty2 if (python_lib_Math.isnan(ty2)) else min(ty1,ty2)))
                            a1 = (a if (python_lib_Math.isnan(a)) else (b if (python_lib_Math.isnan(b)) else max(a,b)))
                            b = (tz1 if (python_lib_Math.isnan(tz1)) else (tz2 if (python_lib_Math.isnan(tz2)) else min(tz1,tz2)))
                            t1 = (a1 if (python_lib_Math.isnan(a1)) else (b if (python_lib_Math.isnan(b)) else max(a1,b)))
                            a = (tx1 if (python_lib_Math.isnan(tx1)) else (tx2 if (python_lib_Math.isnan(tx2)) else max(tx1,tx2)))
                            b = (ty1 if (python_lib_Math.isnan(ty1)) else (ty2 if (python_lib_Math.isnan(ty2)) else max(ty1,ty2)))
                            a1 = (a if (python_lib_Math.isnan(a)) else (b if (python_lib_Math.isnan(b)) else min(a,b)))
                            b = (tz1 if (python_lib_Math.isnan(tz1)) else (tz2 if (python_lib_Math.isnan(tz2)) else max(tz1,tz2)))
                            t2 = (a1 if (python_lib_Math.isnan(a1)) else (b if (python_lib_Math.isnan(b)) else min(a1,b)))
                            hitR = None
                            if ((t2 - t1) < 0):
                                hitR = None
                            elif ((t1 > (r_tmax[0] if 0 < len(r_tmax) else None)) or ((t2 < (r_tmin[0] if 0 < len(r_tmin) else None)))):
                                hitR = None
                            else:
                                h = apparentridges_RayHit(t1)
                                h.t2 = t2
                                hitR = h
                            if ((hitL is not None) and ((hitR is None))):
                                return (hitNode[0] if 0 < len(hitNode) else None)(node.left)
                            elif ((hitL is None) and ((hitR is not None))):
                                return (hitNode[0] if 0 < len(hitNode) else None)(node.right)
                            elif ((hitL is None) and ((hitR is None))):
                                return None
                            first = None
                            second = None
                            if (hitL.t < hitR.t):
                                first = node.left
                                second = node.right
                            else:
                                first = node.right
                                second = node.left
                            h = (hitNode[0] if 0 < len(hitNode) else None)(first)
                            tmp = None
                            if (h is not None):
                                a = hitL.t
                                b = hitR.t
                                tmp = (h.t >= ((a if (python_lib_Math.isnan(a)) else (b if (python_lib_Math.isnan(b)) else max(a,b)))))
                            else:
                                tmp = True
                            if tmp:
                                h2 = (hitNode[0] if 0 < len(hitNode) else None)(second)
                                if (h2 is not None):
                                    if ((h is None) or ((h2.t < h.t))):
                                        return h2
                            return h
                        return _hx_local_0
                    python_internal_ArrayImpl._set(hitNode, 0, _hx_local_1(r_tmax,r_tmin,r_d,r_o,hitNode,bvh))
                    h = (hitNode[0] if 0 < len(hitNode) else None)((bvh[0] if 0 < len(bvh) else None).root)
                    if (h is not None):
                        cnt = (cnt + 1)
                v = (1 - ((cnt / numSamples)))
                if (not python_lib_Math.isnan(_hx_min)):
                    _hx_min = (v if (python_lib_Math.isnan(v)) else min(_hx_min,v))
                if (not python_lib_Math.isnan(_hx_max)):
                    _hx_max = (v if (python_lib_Math.isnan(v)) else max(_hx_max,v))
                data[idx] = v
        apparentridges_PixelMap.raycast(render,_hx_local_3)
        if normalize:
            _g = 0
            _g1 = len(data)
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                if (data[i] != Math.NEGATIVE_INFINITY):
                    val = (((data[i] - _hx_min)) / ((_hx_max - _hx_min)))
                    data[i] = val
                else:
                    data[i] = 0
        return data

    @staticmethod
    def toPPMString(data,w,h,_hx_min,_hx_max):
        x = (len(data) / ((w * h)))
        chan = None
        try:
            chan = int(x)
        except BaseException as _g:
            None
            chan = None
        out_b = python_lib_io_StringIO()
        out_b.write(Std.string((((("P3\n" + Std.string(w)) + " ") + Std.string(h)) + "\n255\n")))
        _g = 0
        x = (len(data) / chan)
        _g1 = None
        try:
            _g1 = int(x)
        except BaseException as _g2:
            None
            _g1 = None
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            a = ((((data[(i * chan)] - _hx_min)) / ((_hx_max - _hx_min))) * 255)
            a1 = (a if (python_lib_Math.isnan(a)) else (0 if (python_lib_Math.isnan(0)) else max(a,0)))
            x = (a1 if (python_lib_Math.isnan(a1)) else (255 if (python_lib_Math.isnan(255)) else min(a1,255)))
            u = None
            try:
                u = int(x)
            except BaseException as _g2:
                None
                u = None
            v = None
            if (chan == 1):
                v = u
            else:
                a2 = ((((data[((i * chan) + 1)] - _hx_min)) / ((_hx_max - _hx_min))) * 255)
                a3 = (a2 if (python_lib_Math.isnan(a2)) else (0 if (python_lib_Math.isnan(0)) else max(a2,0)))
                x1 = (a3 if (python_lib_Math.isnan(a3)) else (255 if (python_lib_Math.isnan(255)) else min(a3,255)))
                try:
                    v = int(x1)
                except BaseException as _g3:
                    None
                    v = None
            w = None
            if (chan == 1):
                w = u
            elif (chan == 2):
                w = 128
            else:
                a4 = ((((data[((i * chan) + 2)] - _hx_min)) / ((_hx_max - _hx_min))) * 255)
                a5 = (a4 if (python_lib_Math.isnan(a4)) else (0 if (python_lib_Math.isnan(0)) else max(a4,0)))
                x2 = (a5 if (python_lib_Math.isnan(a5)) else (255 if (python_lib_Math.isnan(255)) else min(a5,255)))
                try:
                    w = int(x2)
                except BaseException as _g4:
                    None
                    w = None
            out_b.write(Std.string((((((("" + Std.string(u)) + " ") + Std.string(v)) + " ") + Std.string(w)) + " ")))
        return out_b.getvalue()


class apparentridges_SVGWriter:
    _hx_class_name = "apparentridges.SVGWriter"
    __slots__ = ()
    _hx_statics = ["rd", "lines", "polylines", "gradients"]

    @staticmethod
    def rd(x):
        return (Math.floor(((x * 100) + 0.5)) / 100)

    @staticmethod
    def lines(render,useOpacity = None):
        if (useOpacity is None):
            useOpacity = True
        w = render.width
        h = render.height
        out_b = python_lib_io_StringIO()
        out_b.write(Std.string((((("<svg version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" width=\"" + Std.string(w)) + "\" height=\"") + Std.string(h)) + "\">\n")))
        _g = 0
        _g1 = len(render.lines)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            x1 = (Math.floor((((render.lines[i] if i >= 0 and i < len(render.lines) else None).x1 * 100) + 0.5)) / 100)
            y1 = (Math.floor((((render.lines[i] if i >= 0 and i < len(render.lines) else None).y1 * 100) + 0.5)) / 100)
            x2 = (Math.floor((((render.lines[i] if i >= 0 and i < len(render.lines) else None).x2 * 100) + 0.5)) / 100)
            y2 = (Math.floor((((render.lines[i] if i >= 0 and i < len(render.lines) else None).y2 * 100) + 0.5)) / 100)
            o = (((((render.lines[i] if i >= 0 and i < len(render.lines) else None).opacity1 + (render.lines[i] if i >= 0 and i < len(render.lines) else None).opacity2)) / 2) if useOpacity else 1)
            oi = None
            try:
                oi = int((255 - ((o * 255))))
            except BaseException as _g2:
                None
                oi = None
            oi1 = oi
            out_b.write(Std.string((((((((((((((("  <line x1=\"" + Std.string(x1)) + "\" y1=\"") + Std.string(y1)) + "\" x2=\"") + Std.string(x2)) + "\" y2=\"") + Std.string(y2)) + "\" fill=\"none\" stroke=\"rgb(") + Std.string(oi1)) + ",") + Std.string(oi1)) + ",") + Std.string(oi1)) + ")\" stroke-width=\"1\" stroke-linecap=\"round\"/>\n")))
        out_b.write("</svg>\n")
        return out_b.getvalue()

    @staticmethod
    def polylines(render,colorful = None):
        if (colorful is None):
            colorful = False
        w = render.width
        h = render.height
        out_b = python_lib_io_StringIO()
        out_b.write(Std.string((((("<svg version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" width=\"" + Std.string(w)) + "\" height=\"") + Std.string(h)) + "\">\n")))
        color = "black"
        _g = 0
        _g1 = len(render.polylines)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            out_b.write("  <polyline points=\"")
            _g2 = 0
            _g3 = len((render.polylines[i] if i >= 0 and i < len(render.polylines) else None))
            while (_g2 < _g3):
                j = _g2
                _g2 = (_g2 + 1)
                p = python_internal_ArrayImpl._get((render.polylines[i] if i >= 0 and i < len(render.polylines) else None), j)
                out_b.write(Std.string((((("" + Std.string((Math.floor(((p[0] * 100) + 0.5)) / 100))) + ",") + Std.string((Math.floor(((p[1] * 100) + 0.5)) / 100))) + " ")))
            if colorful:
                x = (python_lib_Random.random() * 128)
                color1 = None
                try:
                    color1 = int(x)
                except BaseException as _g4:
                    None
                    color1 = None
                color2 = (("rgb(" + Std.string(color1)) + ",")
                x1 = (python_lib_Random.random() * 128)
                color3 = None
                try:
                    color3 = int(x1)
                except BaseException as _g5:
                    None
                    color3 = None
                color4 = ((("null" if color2 is None else color2) + Std.string(color3)) + ",")
                x2 = (python_lib_Random.random() * 128)
                color5 = None
                try:
                    color5 = int(x2)
                except BaseException as _g6:
                    None
                    color5 = None
                color = ((("null" if color4 is None else color4) + Std.string(color5)) + ")")
            out_b.write(Std.string((("\" fill=\"none\" stroke=\"" + ("null" if color is None else color)) + "\" stroke-width=\"1\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/>\n")))
        out_b.write("</svg>\n")
        return out_b.getvalue()

    @staticmethod
    def gradients(render,acc = None):
        if (acc is None):
            acc = 1
        w = render.width
        h = render.height
        out_b = python_lib_io_StringIO()
        out_b.write(Std.string((((("<svg version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" width=\"" + Std.string(w)) + "\" height=\"") + Std.string(h)) + "\">\n")))
        gid = 0
        _g = 0
        _g1 = len(render.polylines)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            _g2 = 0
            _g3 = len((render.polylines[i] if i >= 0 and i < len(render.polylines) else None))
            while (_g2 < _g3):
                j = _g2
                _g2 = (_g2 + 1)
                p = python_internal_ArrayImpl._get((render.polylines[i] if i >= 0 and i < len(render.polylines) else None), j)
                x = (255 - ((p[2] * 255)))
                oi = None
                try:
                    oi = int(x)
                except BaseException as _g4:
                    None
                    oi = None
                out_b.write(Std.string((((((((((("  <circle cx=\"" + Std.string((Math.floor(((p[0] * 100) + 0.5)) / 100))) + "\" cy=\"") + Std.string((Math.floor(((p[1] * 100) + 0.5)) / 100))) + "\" r=\"0.5\" stroke=\"none\" fill=\"rgb(") + Std.string(oi)) + ",") + Std.string(oi)) + ",") + Std.string(oi)) + ")\"/>\n")))
        _g = 0
        _g1 = len(render.polylines)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            out_b.write("  <g fill=\"none\" stroke-width=\"1\">\n")
            _g2 = 0
            _g3 = (len((render.polylines[i] if i >= 0 and i < len(render.polylines) else None)) - 1)
            while (_g2 < _g3):
                j = _g2
                _g2 = (_g2 + 1)
                p = python_internal_ArrayImpl._get((render.polylines[i] if i >= 0 and i < len(render.polylines) else None), j)
                q = python_internal_ArrayImpl._get((render.polylines[i] if i >= 0 and i < len(render.polylines) else None), (j + 1))
                v = (p[2] - q[2])
                x = ((Reflect.field(Math,"fabs")(v) * 10) * acc)
                d = None
                try:
                    d = int(x)
                except BaseException as _g4:
                    None
                    d = None
                d1 = (d + 1)
                _g5 = 0
                _g6 = d1
                while (_g5 < _g6):
                    k = _g5
                    _g5 = (_g5 + 1)
                    t = ((k / d1) - 0.01)
                    s = ((((k + 1)) / d1) + 0.01)
                    rhs = (1 - t)
                    _x = (p[0] * rhs)
                    _y = (p[1] * rhs)
                    _z = (p[2] * rhs)
                    this1 = [None]*3
                    this2 = this1
                    this2[0] = _x
                    this2[1] = _y
                    this2[2] = _z
                    this3 = this2
                    _x1 = (q[0] * t)
                    _y1 = (q[1] * t)
                    _z1 = (q[2] * t)
                    this4 = [None]*3
                    this5 = this4
                    this5[0] = _x1
                    this5[1] = _y1
                    this5[2] = _z1
                    rhs1 = this5
                    _x2 = (this3[0] + rhs1[0])
                    _y2 = (this3[1] + rhs1[1])
                    _z2 = (this3[2] + rhs1[2])
                    this6 = [None]*3
                    this7 = this6
                    this7[0] = _x2
                    this7[1] = _y2
                    this7[2] = _z2
                    a = this7
                    rhs2 = (1 - s)
                    _x3 = (p[0] * rhs2)
                    _y3 = (p[1] * rhs2)
                    _z3 = (p[2] * rhs2)
                    this8 = [None]*3
                    this9 = this8
                    this9[0] = _x3
                    this9[1] = _y3
                    this9[2] = _z3
                    this10 = this9
                    _x4 = (q[0] * s)
                    _y4 = (q[1] * s)
                    _z4 = (q[2] * s)
                    this11 = [None]*3
                    this12 = this11
                    this12[0] = _x4
                    this12[1] = _y4
                    this12[2] = _z4
                    rhs3 = this12
                    _x5 = (this10[0] + rhs3[0])
                    _y5 = (this10[1] + rhs3[1])
                    _z5 = (this10[2] + rhs3[2])
                    this13 = [None]*3
                    this14 = this13
                    this14[0] = _x5
                    this14[1] = _y5
                    this14[2] = _z5
                    b = this14
                    o = (((a[2] + b[2])) / 2)
                    oi = None
                    try:
                        oi = int((255 - ((o * 255))))
                    except BaseException as _g7:
                        None
                        oi = None
                    oi1 = oi
                    out_b.write(Std.string((((((((((((((("    <line x1=\"" + Std.string((Math.floor(((a[0] * 100) + 0.5)) / 100))) + "\" y1=\"") + Std.string((Math.floor(((a[1] * 100) + 0.5)) / 100))) + "\" x2=\"") + Std.string((Math.floor(((b[0] * 100) + 0.5)) / 100))) + "\" y2=\"") + Std.string((Math.floor(((b[1] * 100) + 0.5)) / 100))) + "\" stroke=\"rgb(") + Std.string(oi1)) + ",") + Std.string(oi1)) + ",") + Std.string(oi1)) + ")\"/>\n")))
                gid = (gid + 1)
            out_b.write("  </g>\n")
        out_b.write("</svg>\n")
        return out_b.getvalue()


class haxe_Exception(Exception):
    _hx_class_name = "haxe.Exception"
    __slots__ = ("_hx___nativeStack", "_hx___nativeException", "_hx___previousException")
    _hx_fields = ["__nativeStack", "__nativeException", "__previousException"]
    _hx_methods = ["unwrap"]
    _hx_statics = ["caught"]
    _hx_interfaces = []
    _hx_super = Exception


    def __init__(self,message,previous = None,native = None):
        self._hx___previousException = None
        self._hx___nativeException = None
        self._hx___nativeStack = None
        super().__init__(message)
        self._hx___previousException = previous
        if ((native is not None) and Std.isOfType(native,BaseException)):
            self._hx___nativeException = native
            self._hx___nativeStack = haxe_NativeStackTrace.exceptionStack()
        else:
            self._hx___nativeException = self
            infos = python_lib_Traceback.extract_stack()
            if (len(infos) != 0):
                infos.pop()
            infos.reverse()
            self._hx___nativeStack = infos

    def unwrap(self):
        return self._hx___nativeException

    @staticmethod
    def caught(value):
        if Std.isOfType(value,haxe_Exception):
            return value
        elif Std.isOfType(value,BaseException):
            return haxe_Exception(str(value),None,value)
        else:
            return haxe_ValueException(value,None,value)



class haxe_NativeStackTrace:
    _hx_class_name = "haxe.NativeStackTrace"
    __slots__ = ()
    _hx_statics = ["saveStack", "exceptionStack"]

    @staticmethod
    def saveStack(exception):
        pass

    @staticmethod
    def exceptionStack():
        exc = python_lib_Sys.exc_info()
        if (exc[2] is not None):
            infos = python_lib_Traceback.extract_tb(exc[2])
            infos.reverse()
            return infos
        else:
            return []


class haxe_ValueException(haxe_Exception):
    _hx_class_name = "haxe.ValueException"
    __slots__ = ("value",)
    _hx_fields = ["value"]
    _hx_methods = ["unwrap"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = haxe_Exception


    def __init__(self,value,previous = None,native = None):
        self.value = None
        super().__init__(Std.string(value),previous,native)
        self.value = value

    def unwrap(self):
        return self.value



class haxe_iterators_ArrayIterator:
    _hx_class_name = "haxe.iterators.ArrayIterator"
    __slots__ = ("array", "current")
    _hx_fields = ["array", "current"]
    _hx_methods = ["hasNext", "next"]

    def __init__(self,array):
        self.current = 0
        self.array = array

    def hasNext(self):
        return (self.current < len(self.array))

    def next(self):
        def _hx_local_3():
            def _hx_local_2():
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.current
                _hx_local_0.current = (_hx_local_1 + 1)
                return _hx_local_1
            return python_internal_ArrayImpl._get(self.array, _hx_local_2())
        return _hx_local_3()



class haxe_iterators_ArrayKeyValueIterator:
    _hx_class_name = "haxe.iterators.ArrayKeyValueIterator"
    __slots__ = ("current", "array")
    _hx_fields = ["current", "array"]
    _hx_methods = ["hasNext", "next"]

    def __init__(self,array):
        self.current = 0
        self.array = array

    def hasNext(self):
        return (self.current < len(self.array))

    def next(self):
        def _hx_local_3():
            def _hx_local_2():
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.current
                _hx_local_0.current = (_hx_local_1 + 1)
                return _hx_local_1
            return _hx_AnonObject({'value': python_internal_ArrayImpl._get(self.array, self.current), 'key': _hx_local_2()})
        return _hx_local_3()



class python_Boot:
    _hx_class_name = "python.Boot"
    __slots__ = ()
    _hx_statics = ["keywords", "toString1", "fields", "simpleField", "field", "getInstanceFields", "getSuperClass", "getClassFields", "prefixLength", "unhandleKeywords"]

    @staticmethod
    def toString1(o,s):
        if (o is None):
            return "null"
        if isinstance(o,str):
            return o
        if (s is None):
            s = ""
        if (len(s) >= 5):
            return "<...>"
        if isinstance(o,bool):
            if o:
                return "true"
            else:
                return "false"
        if (isinstance(o,int) and (not isinstance(o,bool))):
            return str(o)
        if isinstance(o,float):
            try:
                if (o == int(o)):
                    return str(Math.floor((o + 0.5)))
                else:
                    return str(o)
            except BaseException as _g:
                None
                return str(o)
        if isinstance(o,list):
            o1 = o
            l = len(o1)
            st = "["
            s = (("null" if s is None else s) + "\t")
            _g = 0
            _g1 = l
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                prefix = ""
                if (i > 0):
                    prefix = ","
                st = (("null" if st is None else st) + HxOverrides.stringOrNull(((("null" if prefix is None else prefix) + HxOverrides.stringOrNull(python_Boot.toString1((o1[i] if i >= 0 and i < len(o1) else None),s))))))
            st = (("null" if st is None else st) + "]")
            return st
        try:
            if hasattr(o,"toString"):
                return o.toString()
        except BaseException as _g:
            None
        if hasattr(o,"__class__"):
            if isinstance(o,_hx_AnonObject):
                toStr = None
                try:
                    fields = python_Boot.fields(o)
                    _g = []
                    _g1 = 0
                    while (_g1 < len(fields)):
                        f = (fields[_g1] if _g1 >= 0 and _g1 < len(fields) else None)
                        _g1 = (_g1 + 1)
                        x = ((("" + ("null" if f is None else f)) + " : ") + HxOverrides.stringOrNull(python_Boot.toString1(python_Boot.simpleField(o,f),(("null" if s is None else s) + "\t"))))
                        _g.append(x)
                    fieldsStr = _g
                    toStr = (("{ " + HxOverrides.stringOrNull(", ".join([x1 for x1 in fieldsStr]))) + " }")
                except BaseException as _g:
                    None
                    return "{ ... }"
                if (toStr is None):
                    return "{ ... }"
                else:
                    return toStr
            if isinstance(o,Enum):
                o1 = o
                l = len(o1.params)
                hasParams = (l > 0)
                if hasParams:
                    paramsStr = ""
                    _g = 0
                    _g1 = l
                    while (_g < _g1):
                        i = _g
                        _g = (_g + 1)
                        prefix = ""
                        if (i > 0):
                            prefix = ","
                        paramsStr = (("null" if paramsStr is None else paramsStr) + HxOverrides.stringOrNull(((("null" if prefix is None else prefix) + HxOverrides.stringOrNull(python_Boot.toString1(o1.params[i],s))))))
                    return (((HxOverrides.stringOrNull(o1.tag) + "(") + ("null" if paramsStr is None else paramsStr)) + ")")
                else:
                    return o1.tag
            if hasattr(o,"_hx_class_name"):
                if (o.__class__.__name__ != "type"):
                    fields = python_Boot.getInstanceFields(o)
                    _g = []
                    _g1 = 0
                    while (_g1 < len(fields)):
                        f = (fields[_g1] if _g1 >= 0 and _g1 < len(fields) else None)
                        _g1 = (_g1 + 1)
                        x = ((("" + ("null" if f is None else f)) + " : ") + HxOverrides.stringOrNull(python_Boot.toString1(python_Boot.simpleField(o,f),(("null" if s is None else s) + "\t"))))
                        _g.append(x)
                    fieldsStr = _g
                    toStr = (((HxOverrides.stringOrNull(o._hx_class_name) + "( ") + HxOverrides.stringOrNull(", ".join([x1 for x1 in fieldsStr]))) + " )")
                    return toStr
                else:
                    fields = python_Boot.getClassFields(o)
                    _g = []
                    _g1 = 0
                    while (_g1 < len(fields)):
                        f = (fields[_g1] if _g1 >= 0 and _g1 < len(fields) else None)
                        _g1 = (_g1 + 1)
                        x = ((("" + ("null" if f is None else f)) + " : ") + HxOverrides.stringOrNull(python_Boot.toString1(python_Boot.simpleField(o,f),(("null" if s is None else s) + "\t"))))
                        _g.append(x)
                    fieldsStr = _g
                    toStr = (((("#" + HxOverrides.stringOrNull(o._hx_class_name)) + "( ") + HxOverrides.stringOrNull(", ".join([x1 for x1 in fieldsStr]))) + " )")
                    return toStr
            if (o == str):
                return "#String"
            if (o == list):
                return "#Array"
            if callable(o):
                return "function"
            try:
                if hasattr(o,"__repr__"):
                    return o.__repr__()
            except BaseException as _g:
                None
            if hasattr(o,"__str__"):
                return o.__str__([])
            if hasattr(o,"__name__"):
                return o.__name__
            return "???"
        else:
            return str(o)

    @staticmethod
    def fields(o):
        a = []
        if (o is not None):
            if hasattr(o,"_hx_fields"):
                fields = o._hx_fields
                if (fields is not None):
                    return list(fields)
            if isinstance(o,_hx_AnonObject):
                d = o.__dict__
                keys = d.keys()
                handler = python_Boot.unhandleKeywords
                for k in keys:
                    if (k != '_hx_disable_getattr'):
                        a.append(handler(k))
            elif hasattr(o,"__dict__"):
                d = o.__dict__
                keys1 = d.keys()
                for k in keys1:
                    a.append(k)
        return a

    @staticmethod
    def simpleField(o,field):
        if (field is None):
            return None
        field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
        if hasattr(o,field1):
            return getattr(o,field1)
        else:
            return None

    @staticmethod
    def field(o,field):
        if (field is None):
            return None
        if isinstance(o,str):
            field1 = field
            _hx_local_0 = len(field1)
            if (_hx_local_0 == 10):
                if (field1 == "charCodeAt"):
                    return python_internal_MethodClosure(o,HxString.charCodeAt)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_0 == 11):
                if (field1 == "lastIndexOf"):
                    return python_internal_MethodClosure(o,HxString.lastIndexOf)
                elif (field1 == "toLowerCase"):
                    return python_internal_MethodClosure(o,HxString.toLowerCase)
                elif (field1 == "toUpperCase"):
                    return python_internal_MethodClosure(o,HxString.toUpperCase)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_0 == 9):
                if (field1 == "substring"):
                    return python_internal_MethodClosure(o,HxString.substring)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_0 == 5):
                if (field1 == "split"):
                    return python_internal_MethodClosure(o,HxString.split)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_0 == 7):
                if (field1 == "indexOf"):
                    return python_internal_MethodClosure(o,HxString.indexOf)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_0 == 8):
                if (field1 == "toString"):
                    return python_internal_MethodClosure(o,HxString.toString)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_0 == 6):
                if (field1 == "charAt"):
                    return python_internal_MethodClosure(o,HxString.charAt)
                elif (field1 == "length"):
                    return len(o)
                elif (field1 == "substr"):
                    return python_internal_MethodClosure(o,HxString.substr)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            else:
                field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                if hasattr(o,field1):
                    return getattr(o,field1)
                else:
                    return None
        elif isinstance(o,list):
            field1 = field
            _hx_local_1 = len(field1)
            if (_hx_local_1 == 11):
                if (field1 == "lastIndexOf"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.lastIndexOf)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_1 == 4):
                if (field1 == "copy"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.copy)
                elif (field1 == "join"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.join)
                elif (field1 == "push"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.push)
                elif (field1 == "sort"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.sort)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_1 == 5):
                if (field1 == "shift"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.shift)
                elif (field1 == "slice"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.slice)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_1 == 7):
                if (field1 == "indexOf"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.indexOf)
                elif (field1 == "reverse"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.reverse)
                elif (field1 == "unshift"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.unshift)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_1 == 3):
                if (field1 == "map"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.map)
                elif (field1 == "pop"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.pop)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_1 == 8):
                if (field1 == "contains"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.contains)
                elif (field1 == "iterator"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.iterator)
                elif (field1 == "toString"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.toString)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_1 == 16):
                if (field1 == "keyValueIterator"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.keyValueIterator)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_1 == 6):
                if (field1 == "concat"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.concat)
                elif (field1 == "filter"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.filter)
                elif (field1 == "insert"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.insert)
                elif (field1 == "length"):
                    return len(o)
                elif (field1 == "remove"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.remove)
                elif (field1 == "splice"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.splice)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            else:
                field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                if hasattr(o,field1):
                    return getattr(o,field1)
                else:
                    return None
        else:
            field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
            if hasattr(o,field1):
                return getattr(o,field1)
            else:
                return None

    @staticmethod
    def getInstanceFields(c):
        f = (list(c._hx_fields) if (hasattr(c,"_hx_fields")) else [])
        if hasattr(c,"_hx_methods"):
            f = (f + c._hx_methods)
        sc = python_Boot.getSuperClass(c)
        if (sc is None):
            return f
        else:
            scArr = python_Boot.getInstanceFields(sc)
            scMap = set(scArr)
            _g = 0
            while (_g < len(f)):
                f1 = (f[_g] if _g >= 0 and _g < len(f) else None)
                _g = (_g + 1)
                if (not (f1 in scMap)):
                    scArr.append(f1)
            return scArr

    @staticmethod
    def getSuperClass(c):
        if (c is None):
            return None
        try:
            if hasattr(c,"_hx_super"):
                return c._hx_super
            return None
        except BaseException as _g:
            None
        return None

    @staticmethod
    def getClassFields(c):
        if hasattr(c,"_hx_statics"):
            x = c._hx_statics
            return list(x)
        else:
            return []

    @staticmethod
    def unhandleKeywords(name):
        if (HxString.substr(name,0,python_Boot.prefixLength) == "_hx_"):
            real = HxString.substr(name,python_Boot.prefixLength,None)
            if (real in python_Boot.keywords):
                return real
        return name


class python_internal_ArrayImpl:
    _hx_class_name = "python.internal.ArrayImpl"
    __slots__ = ()
    _hx_statics = ["concat", "copy", "iterator", "keyValueIterator", "indexOf", "lastIndexOf", "join", "toString", "pop", "push", "unshift", "remove", "contains", "shift", "slice", "sort", "splice", "map", "filter", "insert", "reverse", "_get", "_set"]

    @staticmethod
    def concat(a1,a2):
        return (a1 + a2)

    @staticmethod
    def copy(x):
        return list(x)

    @staticmethod
    def iterator(x):
        return python_HaxeIterator(x.__iter__())

    @staticmethod
    def keyValueIterator(x):
        return haxe_iterators_ArrayKeyValueIterator(x)

    @staticmethod
    def indexOf(a,x,fromIndex = None):
        _hx_len = len(a)
        l = (0 if ((fromIndex is None)) else ((_hx_len + fromIndex) if ((fromIndex < 0)) else fromIndex))
        if (l < 0):
            l = 0
        _g = l
        _g1 = _hx_len
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            if HxOverrides.eq(a[i],x):
                return i
        return -1

    @staticmethod
    def lastIndexOf(a,x,fromIndex = None):
        _hx_len = len(a)
        l = (_hx_len if ((fromIndex is None)) else (((_hx_len + fromIndex) + 1) if ((fromIndex < 0)) else (fromIndex + 1)))
        if (l > _hx_len):
            l = _hx_len
        while True:
            l = (l - 1)
            tmp = l
            if (not ((tmp > -1))):
                break
            if HxOverrides.eq(a[l],x):
                return l
        return -1

    @staticmethod
    def join(x,sep):
        return sep.join([python_Boot.toString1(x1,'') for x1 in x])

    @staticmethod
    def toString(x):
        return (("[" + HxOverrides.stringOrNull(",".join([python_Boot.toString1(x1,'') for x1 in x]))) + "]")

    @staticmethod
    def pop(x):
        if (len(x) == 0):
            return None
        else:
            return x.pop()

    @staticmethod
    def push(x,e):
        x.append(e)
        return len(x)

    @staticmethod
    def unshift(x,e):
        x.insert(0, e)

    @staticmethod
    def remove(x,e):
        try:
            x.remove(e)
            return True
        except BaseException as _g:
            None
            return False

    @staticmethod
    def contains(x,e):
        return (e in x)

    @staticmethod
    def shift(x):
        if (len(x) == 0):
            return None
        return x.pop(0)

    @staticmethod
    def slice(x,pos,end = None):
        return x[pos:end]

    @staticmethod
    def sort(x,f):
        x.sort(key= python_lib_Functools.cmp_to_key(f))

    @staticmethod
    def splice(x,pos,_hx_len):
        if (pos < 0):
            pos = (len(x) + pos)
        if (pos < 0):
            pos = 0
        res = x[pos:(pos + _hx_len)]
        del x[pos:(pos + _hx_len)]
        return res

    @staticmethod
    def map(x,f):
        return list(map(f,x))

    @staticmethod
    def filter(x,f):
        return list(filter(f,x))

    @staticmethod
    def insert(a,pos,x):
        a.insert(pos, x)

    @staticmethod
    def reverse(a):
        a.reverse()

    @staticmethod
    def _get(x,idx):
        if ((idx > -1) and ((idx < len(x)))):
            return x[idx]
        else:
            return None

    @staticmethod
    def _set(x,idx,v):
        l = len(x)
        while (l < idx):
            x.append(None)
            l = (l + 1)
        if (l == idx):
            x.append(v)
        else:
            x[idx] = v
        return v


class HxOverrides:
    _hx_class_name = "HxOverrides"
    __slots__ = ()
    _hx_statics = ["eq", "stringOrNull", "modf", "mod"]

    @staticmethod
    def eq(a,b):
        if (isinstance(a,list) or isinstance(b,list)):
            return a is b
        return (a == b)

    @staticmethod
    def stringOrNull(s):
        if (s is None):
            return "null"
        else:
            return s

    @staticmethod
    def modf(a,b):
        if (b == 0.0):
            return float('nan')
        elif (a < 0):
            if (b < 0):
                return -(-a % (-b))
            else:
                return -(-a % b)
        elif (b < 0):
            return a % (-b)
        else:
            return a % b

    @staticmethod
    def mod(a,b):
        if (a < 0):
            if (b < 0):
                return -(-a % (-b))
            else:
                return -(-a % b)
        elif (b < 0):
            return a % (-b)
        else:
            return a % b


class python_internal_MethodClosure:
    _hx_class_name = "python.internal.MethodClosure"
    __slots__ = ("obj", "func")
    _hx_fields = ["obj", "func"]
    _hx_methods = ["__call__"]

    def __init__(self,obj,func):
        self.obj = obj
        self.func = func

    def __call__(self,*args):
        return self.func(self.obj,*args)



class HxString:
    _hx_class_name = "HxString"
    __slots__ = ()
    _hx_statics = ["split", "charCodeAt", "charAt", "lastIndexOf", "toUpperCase", "toLowerCase", "indexOf", "indexOfImpl", "toString", "substring", "substr"]

    @staticmethod
    def split(s,d):
        if (d == ""):
            return list(s)
        else:
            return s.split(d)

    @staticmethod
    def charCodeAt(s,index):
        if ((((s is None) or ((len(s) == 0))) or ((index < 0))) or ((index >= len(s)))):
            return None
        else:
            return ord(s[index])

    @staticmethod
    def charAt(s,index):
        if ((index < 0) or ((index >= len(s)))):
            return ""
        else:
            return s[index]

    @staticmethod
    def lastIndexOf(s,_hx_str,startIndex = None):
        if (startIndex is None):
            return s.rfind(_hx_str, 0, len(s))
        elif (_hx_str == ""):
            length = len(s)
            if (startIndex < 0):
                startIndex = (length + startIndex)
                if (startIndex < 0):
                    startIndex = 0
            if (startIndex > length):
                return length
            else:
                return startIndex
        else:
            i = s.rfind(_hx_str, 0, (startIndex + 1))
            startLeft = (max(0,((startIndex + 1) - len(_hx_str))) if ((i == -1)) else (i + 1))
            check = s.find(_hx_str, startLeft, len(s))
            if ((check > i) and ((check <= startIndex))):
                return check
            else:
                return i

    @staticmethod
    def toUpperCase(s):
        return s.upper()

    @staticmethod
    def toLowerCase(s):
        return s.lower()

    @staticmethod
    def indexOf(s,_hx_str,startIndex = None):
        if (startIndex is None):
            return s.find(_hx_str)
        else:
            return HxString.indexOfImpl(s,_hx_str,startIndex)

    @staticmethod
    def indexOfImpl(s,_hx_str,startIndex):
        if (_hx_str == ""):
            length = len(s)
            if (startIndex < 0):
                startIndex = (length + startIndex)
                if (startIndex < 0):
                    startIndex = 0
            if (startIndex > length):
                return length
            else:
                return startIndex
        return s.find(_hx_str, startIndex)

    @staticmethod
    def toString(s):
        return s

    @staticmethod
    def substring(s,startIndex,endIndex = None):
        if (startIndex < 0):
            startIndex = 0
        if (endIndex is None):
            return s[startIndex:]
        else:
            if (endIndex < 0):
                endIndex = 0
            if (endIndex < startIndex):
                return s[endIndex:startIndex]
            else:
                return s[startIndex:endIndex]

    @staticmethod
    def substr(s,startIndex,_hx_len = None):
        if (_hx_len is None):
            return s[startIndex:]
        else:
            if (_hx_len == 0):
                return ""
            if (startIndex < 0):
                startIndex = (len(s) + startIndex)
                if (startIndex < 0):
                    startIndex = 0
            return s[startIndex:(startIndex + _hx_len)]


class sys_io_File:
    _hx_class_name = "sys.io.File"
    __slots__ = ()
    _hx_statics = ["getContent", "saveContent"]

    @staticmethod
    def getContent(path):
        f = python_lib_Builtins.open(path,"r",-1,"utf-8",None,"")
        content = f.read(-1)
        f.close()
        return content

    @staticmethod
    def saveContent(path,content):
        f = python_lib_Builtins.open(path,"w",-1,"utf-8",None,"")
        f.write(content)
        f.close()

Math.NEGATIVE_INFINITY = float("-inf")
Math.POSITIVE_INFINITY = float("inf")
Math.NaN = float("nan")
Math.PI = python_lib_Math.pi

python_Boot.keywords = set(["and", "del", "from", "not", "with", "as", "elif", "global", "or", "yield", "assert", "else", "if", "pass", "None", "break", "except", "import", "raise", "True", "class", "exec", "in", "return", "False", "continue", "finally", "is", "try", "def", "for", "lambda", "while"])
python_Boot.prefixLength = len("_hx_")