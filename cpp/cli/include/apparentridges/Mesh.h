// Generated by Haxe 4.1.3
#ifndef INCLUDED_apparentridges_Mesh
#define INCLUDED_apparentridges_Mesh

#ifndef HXCPP_H
#include <hxcpp.h>
#endif

HX_DECLARE_CLASS1(apparentridges,BSphere)
HX_DECLARE_CLASS1(apparentridges,BVHTree)
HX_DECLARE_CLASS1(apparentridges,Mesh)
HX_DECLARE_CLASS1(apparentridges,Ridge)

namespace apparentridges{


class HXCPP_CLASS_ATTRIBUTES Mesh_obj : public ::hx::Object
{
	public:
		typedef ::hx::Object super;
		typedef Mesh_obj OBJ_;
		Mesh_obj();

	public:
		enum { _hx_ClassId = 0x49d2b44e };

		void __construct();
		inline void *operator new(size_t inSize, bool inContainer=true,const char *inName="apparentridges.Mesh")
			{ return ::hx::Object::operator new(inSize,inContainer,inName); }
		inline void *operator new(size_t inSize, int extra)
			{ return ::hx::Object::operator new(inSize+extra,true,"apparentridges.Mesh"); }
		static ::hx::ObjectPtr< Mesh_obj > __new();
		static ::hx::ObjectPtr< Mesh_obj > __alloc(::hx::Ctx *_hx_ctx);
		static void * _hx_vtable;
		static Dynamic __CreateEmpty();
		static Dynamic __Create(::hx::DynamicArray inArgs);
		//~Mesh_obj();

		HX_DO_RTTI_ALL;
		::hx::Val __Field(const ::String &inString, ::hx::PropertyAccess inCallProp);
		static bool __GetStatic(const ::String &inString, Dynamic &outValue, ::hx::PropertyAccess inCallProp);
		::hx::Val __SetField(const ::String &inString,const ::hx::Val &inValue, ::hx::PropertyAccess inCallProp);
		void __GetFields(Array< ::String> &outFields);
		static void __register();
		void __Mark(HX_MARK_PARAMS);
		void __Visit(HX_VISIT_PARAMS);
		bool _hx_isInstanceOf(int inClassId);
		::String __ToString() const { return HX_("Mesh",0d,76,32,33); }

		static void rotCoordSys(::Array< Float > old_u,::Array< Float > old_v,::Array< Float > new_norm,::Array< Float > new_u,::Array< Float > new_v);
		static ::Dynamic rotCoordSys_dyn();

		static ::Array< Float > projCurv(::Array< Float > old_u,::Array< Float > old_v,Float old_ku,Float old_kuv,Float old_kv,::Array< Float > new_u,::Array< Float > new_v);
		static ::Dynamic projCurv_dyn();

		static void diagonalizeCurv(::Array< Float > old_u,::Array< Float > old_v,Float ku,Float kuv,Float kv,::Array< Float > new_norm,::Array< Float > pd1,::Array< Float > pd2,::Array< Float > k1k2);
		static ::Dynamic diagonalizeCurv_dyn();

		::Array< ::Dynamic> vertices;
		::Array< ::Dynamic> faces;
		::Array< ::Dynamic> normals;
		::Array< Float > curv1;
		::Array< Float > curv2;
		::Array< ::Dynamic> pdir1;
		::Array< ::Dynamic> pdir2;
		::Array< Float > pointAreas;
		::Array< ::Dynamic> cornerAreas;
		::Array< ::Dynamic> adjacentFaces;
		::Array< Float > ndotv;
		::Array< ::Dynamic> t1q1;
		::Array< Float > Dt1q1;
		 ::apparentridges::BSphere bsphere;
		Float featureSize;
		 ::apparentridges::BVHTree bvh;
		void precompute(::hx::Null< bool >  doBVH,::hx::Null< bool >  verb);
		::Dynamic precompute_dyn();

		void computeNormals();
		::Dynamic computeNormals_dyn();

		void computeBSphere();
		::Dynamic computeBSphere_dyn();

		void computeFeatureSize();
		::Dynamic computeFeatureSize_dyn();

		void computeAdjacentFaces();
		::Dynamic computeAdjacentFaces_dyn();

		::Array< ::Dynamic> getFaceEdges(::Array< int > f);
		::Dynamic getFaceEdges_dyn();

		void computePointAreas();
		::Dynamic computePointAreas_dyn();

		void computeCurvatures();
		::Dynamic computeCurvatures_dyn();

		::Array< Float > computeVertViewDepCurv(int i,Float ndotv,Float u2,Float uv,Float v2);
		::Dynamic computeVertViewDepCurv_dyn();

		Float computeVertDt1q1(int i,Float ndotv,::Array< ::Dynamic> t1q1);
		::Dynamic computeVertDt1q1_dyn();

		 ::apparentridges::Ridge segmentApparentRidge(int v0,int v1,int v2,Float emax0,Float emax1,Float emax2,Float kmax0,Float kmax1,Float kmax2,::Array< Float > tmax0,::Array< Float > tmax1,::Array< Float > tmax2,Float thresh,bool to_center,bool do_test);
		::Dynamic segmentApparentRidge_dyn();

		::Array< ::Dynamic> facesApparentRidges(::Array< Float > ndotv,::Array< ::Dynamic> t1q1,::Array< Float > Dt1q1,bool do_bfcull,bool do_test,Float thresh);
		::Dynamic facesApparentRidges_dyn();

		::Array< ::Dynamic> apparentRidges(::Array< Float > eye,Float thresh);
		::Dynamic apparentRidges_dyn();

		void computeBVHTrivial();
		::Dynamic computeBVHTrivial_dyn();

		void computeBVH();
		::Dynamic computeBVH_dyn();

		bool visible(::Array< Float > eye,::Array< Float > p,::hx::Null< Float >  tolerance);
		::Dynamic visible_dyn();

};

} // end namespace apparentridges

#endif /* INCLUDED_apparentridges_Mesh */ 
