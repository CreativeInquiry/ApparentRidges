-- Generated by Haxe 4.1.3
local _hx_hidden = {__id__=true, hx__closures=true, super=true, prototype=true, __fields__=true, __ifields__=true, __class__=true, __properties__=true, __fields__=true, __name__=true}

_hx_array_mt = {
    __newindex = function(t,k,v)
        local len = t.length
        t.length =  k >= len and (k + 1) or len
        rawset(t,k,v)
    end
}

function _hx_is_array(o)
    return type(o) == "table"
        and o.__enum__ == nil
        and getmetatable(o) == _hx_array_mt
end



function _hx_tab_array(tab, length)
    tab.length = length
    return setmetatable(tab, _hx_array_mt)
end



function _hx_print_class(obj, depth)
    local first = true
    local result = ''
    for k,v in pairs(obj) do
        if _hx_hidden[k] == nil then
            if first then
                first = false
            else
                result = result .. ', '
            end
            if _hx_hidden[k] == nil then
                result = result .. k .. ':' .. _hx_tostring(v, depth+1)
            end
        end
    end
    return '{ ' .. result .. ' }'
end

function _hx_print_enum(o, depth)
    if o.length == 2 then
        return o[0]
    else
        local str = o[0] .. "("
        for i = 2, (o.length-1) do
            if i ~= 2 then
                str = str .. "," .. _hx_tostring(o[i], depth+1)
            else
                str = str .. _hx_tostring(o[i], depth+1)
            end
        end
        return str .. ")"
    end
end

function _hx_tostring(obj, depth)
    if depth == nil then
        depth = 0
    elseif depth > 5 then
        return "<...>"
    end

    local tstr = _G.type(obj)
    if tstr == "string" then return obj
    elseif tstr == "nil" then return "null"
    elseif tstr == "number" then
        if obj == _G.math.POSITIVE_INFINITY then return "Infinity"
        elseif obj == _G.math.NEGATIVE_INFINITY then return "-Infinity"
        elseif obj == 0 then return "0"
        elseif obj ~= obj then return "NaN"
        else return _G.tostring(obj)
        end
    elseif tstr == "boolean" then return _G.tostring(obj)
    elseif tstr == "userdata" then
        local mt = _G.getmetatable(obj)
        if mt ~= nil and mt.__tostring ~= nil then
            return _G.tostring(obj)
        else
            return "<userdata>"
        end
    elseif tstr == "function" then return "<function>"
    elseif tstr == "thread" then return "<thread>"
    elseif tstr == "table" then
        if obj.__enum__ ~= nil then
            return _hx_print_enum(obj, depth)
        elseif obj.toString ~= nil and not _hx_is_array(obj) then return obj:toString()
        elseif _hx_is_array(obj) then
            if obj.length > 5 then
                return "[...]"
            else
                str = ""
                for i=0, (obj.length-1) do
                    if i == 0 then
                        str = str .. _hx_tostring(obj[i], depth+1)
                    else
                        str = str .. "," .. _hx_tostring(obj[i], depth+1)
                    end
                end
                return "[" .. str .. "]"
            end
        elseif obj.__class__ ~= nil then
            return _hx_print_class(obj, depth)
        else
            first = true
            buffer = {}
            for k,v in pairs(obj) do
                if _hx_hidden[k] == nil then
                    _G.table.insert(buffer, _hx_tostring(k, depth+1) .. ' : ' .. _hx_tostring(obj[k], depth+1))
                end
            end
            return "{ " .. table.concat(buffer, ", ") .. " }"
        end
    else
        _G.error("Unknown Lua type", 0)
        return ""
    end
end

function _hx_error(obj)
    print(obj)
    if obj.value then
        _G.print("Runtime Error: " .. _hx_tostring(obj.value));
    else
        _G.print("Runtime Error: " .. tostring(obj));
    end

    if _G.debug and _G.debug.traceback then
        _G.print(debug.traceback());
    end
end


local function _hx_obj_newindex(t,k,v)
    t.__fields__[k] = true
    rawset(t,k,v)
end

local _hx_obj_mt = {__newindex=_hx_obj_newindex, __tostring=_hx_tostring}

local function _hx_a(...)
  local __fields__ = {};
  local ret = {__fields__ = __fields__};
  local max = select('#',...);
  local tab = {...};
  local cur = 1;
  while cur < max do
    local v = tab[cur];
    __fields__[v] = true;
    ret[v] = tab[cur+1];
    cur = cur + 2
  end
  return setmetatable(ret, _hx_obj_mt)
end

local function _hx_e()
  return setmetatable({__fields__ = {}}, _hx_obj_mt)
end

local function _hx_o(obj)
  return setmetatable(obj, _hx_obj_mt)
end

local function _hx_new(prototype)
  return setmetatable({__fields__ = {}}, {__newindex=_hx_obj_newindex, __index=prototype, __tostring=_hx_tostring})
end

function _hx_field_arr(obj)
    res = {}
    idx = 0
    if obj.__fields__ ~= nil then
        obj = obj.__fields__
    end
    for k,v in pairs(obj) do
        if _hx_hidden[k] == nil then
            res[idx] = k
            idx = idx + 1
        end
    end
    return _hx_tab_array(res, idx)
end

local _hxClasses = {}
local Int = _hx_e();
local Dynamic = _hx_e();
local Float = _hx_e();
local Bool = _hx_e();
local Class = _hx_e();
local Enum = _hx_e();

local _hx_exports = _hx_exports or {}
_hx_exports["apparentridges"] = _hx_exports["apparentridges"] or _hx_e()
_hx_exports["apparentridges"]["_ApparentRidges"] = _hx_exports["apparentridges"]["_ApparentRidges"] or _hx_e()
local Array = _hx_e()
local Math = _hx_e()
local String = _hx_e()
local Std = _hx_e()
local StringTools = _hx_e()
__apparentridges_Util = _hx_e()
__apparentridges__ApparentRidges_Vec3_Impl_ = _hx_e()
__apparentridges__ApparentRidges_Face_Impl_ = _hx_e()
__apparentridges_Ridge = _hx_e()
__apparentridges_BSphere = _hx_e()
__apparentridges_Mesh = _hx_e()
__apparentridges_Ray = _hx_e()
__apparentridges_RayHit = _hx_e()
__apparentridges_BBox = _hx_e()
__apparentridges_BVHNode = _hx_e()
__apparentridges_BVHTree = _hx_e()
__apparentridges_BVHBucket = _hx_e()
__apparentridges_BVHPartition = _hx_e()
__apparentridges_OBJParser = _hx_e()
__apparentridges_Line = _hx_e()
__apparentridges__ApparentRidges_Polyline_Impl_ = _hx_e()
__apparentridges_Render = _hx_e()
__apparentridges_PixelMap = _hx_e()
__apparentridges_SVGWriter = _hx_e()
__haxe_Exception = _hx_e()
__haxe_Log = _hx_e()
__haxe_NativeStackTrace = _hx_e()
__haxe_ValueException = _hx_e()
__haxe_io_Bytes = _hx_e()
__haxe_io_Encoding = _hx_e()
__haxe_io_Error = _hx_e()
__haxe_io_Output = _hx_e()
__haxe_iterators_ArrayIterator = _hx_e()
__haxe_iterators_ArrayKeyValueIterator = _hx_e()
__lua_Boot = _hx_e()
__lua_UserData = _hx_e()
__lua_Thread = _hx_e()
__sys_io_File = _hx_e()
__sys_io_FileOutput = _hx_e()

local _hx_bind, _hx_bit, _hx_staticToInstance, _hx_funcToField, _hx_maxn, _hx_print, _hx_apply_self, _hx_box_mr, _hx_bit_clamp, _hx_table, _hx_bit_raw
local _hx_pcall_default = {};
local _hx_pcall_break = {};

Array.new = function() 
  local self = _hx_new(Array.prototype)
  Array.super(self)
  return self
end
Array.super = function(self) 
  _hx_tab_array(self, 0);
end
Array.__name__ = true
Array.prototype = _hx_e();
Array.prototype.concat = function(self,a) 
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = self;
  while (_g1 < _g2.length) do 
    local i = _g2[_g1];
    _g1 = _g1 + 1;
    _g:push(i);
  end;
  local ret = _g;
  local _g = 0;
  while (_g < a.length) do 
    local i = a[_g];
    _g = _g + 1;
    ret:push(i);
  end;
  do return ret end
end
Array.prototype.join = function(self,sep) 
  local tbl = ({});
  local _g_current = 0;
  local _g_array = self;
  while (_g_current < _g_array.length) do 
    _g_current = _g_current + 1;
    local i = _g_array[_g_current - 1];
    _G.table.insert(tbl, Std.string(i));
  end;
  do return _G.table.concat(tbl, sep) end
end
Array.prototype.pop = function(self) 
  if (self.length == 0) then 
    do return nil end;
  end;
  local ret = self[self.length - 1];
  self[self.length - 1] = nil;
  self.length = self.length - 1;
  do return ret end
end
Array.prototype.push = function(self,x) 
  self[self.length] = x;
  do return self.length end
end
Array.prototype.reverse = function(self) 
  local tmp;
  local i = 0;
  while (i < Std.int(self.length / 2)) do 
    tmp = self[i];
    self[i] = self[(self.length - i) - 1];
    self[(self.length - i) - 1] = tmp;
    i = i + 1;
  end;
end
Array.prototype.shift = function(self) 
  if (self.length == 0) then 
    do return nil end;
  end;
  local ret = self[0];
  if (self.length == 1) then 
    self[0] = nil;
  else
    if (self.length > 1) then 
      self[0] = self[1];
      _G.table.remove(self, 1);
    end;
  end;
  local tmp = self;
  tmp.length = tmp.length - 1;
  do return ret end
end
Array.prototype.slice = function(self,pos,_end) 
  if ((_end == nil) or (_end > self.length)) then 
    _end = self.length;
  else
    if (_end < 0) then 
      _end = _G.math.fmod((self.length - (_G.math.fmod(-_end, self.length))), self.length);
    end;
  end;
  if (pos < 0) then 
    pos = _G.math.fmod((self.length - (_G.math.fmod(-pos, self.length))), self.length);
  end;
  if ((pos > _end) or (pos > self.length)) then 
    do return _hx_tab_array({}, 0) end;
  end;
  local ret = _hx_tab_array({}, 0);
  local _g = pos;
  local _g1 = _end;
  while (_g < _g1) do 
    _g = _g + 1;
    local i = _g - 1;
    ret:push(self[i]);
  end;
  do return ret end
end
Array.prototype.sort = function(self,f) 
  local i = 0;
  local l = self.length;
  while (i < l) do 
    local swap = false;
    local j = 0;
    local max = (l - i) - 1;
    while (j < max) do 
      if (f(self[j], self[j + 1]) > 0) then 
        local tmp = self[j + 1];
        self[j + 1] = self[j];
        self[j] = tmp;
        swap = true;
      end;
      j = j + 1;
    end;
    if (not swap) then 
      break;
    end;
    i = i + 1;
  end;
end
Array.prototype.splice = function(self,pos,len) 
  if ((len < 0) or (pos > self.length)) then 
    do return _hx_tab_array({}, 0) end;
  else
    if (pos < 0) then 
      pos = self.length - (_G.math.fmod(-pos, self.length));
    end;
  end;
  len = Math.min(len, self.length - pos);
  local ret = _hx_tab_array({}, 0);
  local _g = pos;
  local _g1 = pos + len;
  while (_g < _g1) do 
    _g = _g + 1;
    local i = _g - 1;
    ret:push(self[i]);
    self[i] = self[i + len];
  end;
  local _g = pos + len;
  local _g1 = self.length;
  while (_g < _g1) do 
    _g = _g + 1;
    local i = _g - 1;
    self[i] = self[i + len];
  end;
  local tmp = self;
  tmp.length = tmp.length - len;
  do return ret end
end
Array.prototype.toString = function(self) 
  local tbl = ({});
  _G.table.insert(tbl, "[");
  _G.table.insert(tbl, self:join(","));
  _G.table.insert(tbl, "]");
  do return _G.table.concat(tbl, "") end
end
Array.prototype.unshift = function(self,x) 
  local len = self.length;
  local _g = 0;
  local _g1 = len;
  while (_g < _g1) do 
    _g = _g + 1;
    local i = _g - 1;
    self[len - i] = self[(len - i) - 1];
  end;
  self[0] = x;
end
Array.prototype.insert = function(self,pos,x) 
  if (pos > self.length) then 
    pos = self.length;
  end;
  if (pos < 0) then 
    pos = self.length + pos;
    if (pos < 0) then 
      pos = 0;
    end;
  end;
  local cur_len = self.length;
  while (cur_len > pos) do 
    self[cur_len] = self[cur_len - 1];
    cur_len = cur_len - 1;
  end;
  self[pos] = x;
end
Array.prototype.remove = function(self,x) 
  local _g = 0;
  local _g1 = self.length;
  while (_g < _g1) do 
    _g = _g + 1;
    local i = _g - 1;
    if (self[i] == x) then 
      local _g = i;
      local _g1 = self.length - 1;
      while (_g < _g1) do 
        _g = _g + 1;
        local j = _g - 1;
        self[j] = self[j + 1];
      end;
      self[self.length - 1] = nil;
      self.length = self.length - 1;
      do return true end;
    end;
  end;
  do return false end
end
Array.prototype.contains = function(self,x) 
  local _g = 0;
  local _g1 = self.length;
  while (_g < _g1) do 
    _g = _g + 1;
    local i = _g - 1;
    if (self[i] == x) then 
      do return true end;
    end;
  end;
  do return false end
end
Array.prototype.indexOf = function(self,x,fromIndex) 
  local _end = self.length;
  if (fromIndex == nil) then 
    fromIndex = 0;
  else
    if (fromIndex < 0) then 
      fromIndex = self.length + fromIndex;
      if (fromIndex < 0) then 
        fromIndex = 0;
      end;
    end;
  end;
  local _g = fromIndex;
  local _g1 = _end;
  while (_g < _g1) do 
    _g = _g + 1;
    local i = _g - 1;
    if (x == self[i]) then 
      do return i end;
    end;
  end;
  do return -1 end
end
Array.prototype.lastIndexOf = function(self,x,fromIndex) 
  if ((fromIndex == nil) or (fromIndex >= self.length)) then 
    fromIndex = self.length - 1;
  else
    if (fromIndex < 0) then 
      fromIndex = self.length + fromIndex;
      if (fromIndex < 0) then 
        do return -1 end;
      end;
    end;
  end;
  local i = fromIndex;
  while (i >= 0) do 
    if (self[i] == x) then 
      do return i end;
    else
      i = i - 1;
    end;
  end;
  do return -1 end
end
Array.prototype.copy = function(self) 
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = self;
  while (_g1 < _g2.length) do 
    local i = _g2[_g1];
    _g1 = _g1 + 1;
    _g:push(i);
  end;
  do return _g end
end
Array.prototype.map = function(self,f) 
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = self;
  while (_g1 < _g2.length) do 
    local i = _g2[_g1];
    _g1 = _g1 + 1;
    _g:push(f(i));
  end;
  do return _g end
end
Array.prototype.filter = function(self,f) 
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = self;
  while (_g1 < _g2.length) do 
    local i = _g2[_g1];
    _g1 = _g1 + 1;
    if (f(i)) then 
      _g:push(i);
    end;
  end;
  do return _g end
end
Array.prototype.iterator = function(self) 
  do return __haxe_iterators_ArrayIterator.new(self) end
end
Array.prototype.keyValueIterator = function(self) 
  do return __haxe_iterators_ArrayKeyValueIterator.new(self) end
end
Array.prototype.resize = function(self,len) 
  if (self.length < len) then 
    self.length = len;
  else
    if (self.length > len) then 
      local _g = len;
      local _g1 = self.length;
      while (_g < _g1) do 
        _g = _g + 1;
        local i = _g - 1;
        self[i] = nil;
      end;
      self.length = len;
    end;
  end;
end

Array.prototype.__class__ =  Array

Math.new = {}
Math.__name__ = true
Math.isNaN = function(f) 
  do return f ~= f end;
end
Math.isFinite = function(f) 
  if (f > -_G.math.huge) then 
    do return f < _G.math.huge end;
  else
    do return false end;
  end;
end
Math.max = function(a,b) 
  if (Math.isNaN(a) or Math.isNaN(b)) then 
    do return (0/0) end;
  else
    do return _G.math.max(a, b) end;
  end;
end
Math.min = function(a,b) 
  if (Math.isNaN(a) or Math.isNaN(b)) then 
    do return (0/0) end;
  else
    do return _G.math.min(a, b) end;
  end;
end

String.new = function(string) 
  local self = _hx_new(String.prototype)
  String.super(self,string)
  self = string
  return self
end
String.super = function(self,string) 
end
String.__name__ = true
String.__index = function(s,k) 
  if (k == "length") then 
    do return _G.string.len(s) end;
  else
    local o = String.prototype;
    local field = k;
    if ((function() 
      local _hx_1
      if ((_G.type(o) == "string") and ((String.prototype[field] ~= nil) or (field == "length"))) then 
      _hx_1 = true; elseif (o.__fields__ ~= nil) then 
      _hx_1 = o.__fields__[field] ~= nil; else 
      _hx_1 = o[field] ~= nil; end
      return _hx_1
    end )()) then 
      do return String.prototype[k] end;
    else
      if (String.__oldindex ~= nil) then 
        if (_G.type(String.__oldindex) == "function") then 
          do return String.__oldindex(s, k) end;
        else
          if (_G.type(String.__oldindex) == "table") then 
            do return String.__oldindex[k] end;
          end;
        end;
        do return nil end;
      else
        do return nil end;
      end;
    end;
  end;
end
String.indexOfEmpty = function(s,startIndex) 
  local length = _G.string.len(s);
  if (startIndex < 0) then 
    startIndex = length + startIndex;
    if (startIndex < 0) then 
      startIndex = 0;
    end;
  end;
  if (startIndex > length) then 
    do return length end;
  else
    do return startIndex end;
  end;
end
String.fromCharCode = function(code) 
  do return _G.string.char(code) end;
end
String.prototype = _hx_e();
String.prototype.toUpperCase = function(self) 
  do return _G.string.upper(self) end
end
String.prototype.toLowerCase = function(self) 
  do return _G.string.lower(self) end
end
String.prototype.indexOf = function(self,str,startIndex) 
  if (startIndex == nil) then 
    startIndex = 1;
  else
    startIndex = startIndex + 1;
  end;
  if (str == "") then 
    do return String.indexOfEmpty(self, startIndex - 1) end;
  end;
  local r = _G.string.find(self, str, startIndex, true);
  if ((r ~= nil) and (r > 0)) then 
    do return r - 1 end;
  else
    do return -1 end;
  end;
end
String.prototype.lastIndexOf = function(self,str,startIndex) 
  local ret = -1;
  if (startIndex == nil) then 
    startIndex = #self;
  end;
  while (true) do 
    local startIndex1 = ret + 1;
    if (startIndex1 == nil) then 
      startIndex1 = 1;
    else
      startIndex1 = startIndex1 + 1;
    end;
    local p;
    if (str == "") then 
      p = String.indexOfEmpty(self, startIndex1 - 1);
    else
      local r = _G.string.find(self, str, startIndex1, true);
      p = (function() 
        local _hx_1
        if ((r ~= nil) and (r > 0)) then 
        _hx_1 = r - 1; else 
        _hx_1 = -1; end
        return _hx_1
      end )();
    end;
    if (((p == -1) or (p > startIndex)) or (p == ret)) then 
      break;
    end;
    ret = p;
  end;
  do return ret end
end
String.prototype.split = function(self,delimiter) 
  local idx = 1;
  local ret = _hx_tab_array({}, 0);
  while (idx ~= nil) do 
    local newidx = 0;
    if (#delimiter > 0) then 
      newidx = _G.string.find(self, delimiter, idx, true);
    else
      if (idx >= #self) then 
        newidx = nil;
      else
        newidx = idx + 1;
      end;
    end;
    if (newidx ~= nil) then 
      local match = _G.string.sub(self, idx, newidx - 1);
      ret:push(match);
      idx = newidx + #delimiter;
    else
      ret:push(_G.string.sub(self, idx, #self));
      idx = nil;
    end;
  end;
  do return ret end
end
String.prototype.toString = function(self) 
  do return self end
end
String.prototype.substring = function(self,startIndex,endIndex) 
  if (endIndex == nil) then 
    endIndex = #self;
  end;
  if (endIndex < 0) then 
    endIndex = 0;
  end;
  if (startIndex < 0) then 
    startIndex = 0;
  end;
  if (endIndex < startIndex) then 
    do return _G.string.sub(self, endIndex + 1, startIndex) end;
  else
    do return _G.string.sub(self, startIndex + 1, endIndex) end;
  end;
end
String.prototype.charAt = function(self,index) 
  do return _G.string.sub(self, index + 1, index + 1) end
end
String.prototype.charCodeAt = function(self,index) 
  do return _G.string.byte(self, index + 1) end
end
String.prototype.substr = function(self,pos,len) 
  if ((len == nil) or (len > (pos + #self))) then 
    len = #self;
  else
    if (len < 0) then 
      len = #self + len;
    end;
  end;
  if (pos < 0) then 
    pos = #self + pos;
  end;
  if (pos < 0) then 
    pos = 0;
  end;
  do return _G.string.sub(self, pos + 1, pos + len) end
end

String.prototype.__class__ =  String

Std.new = {}
Std.__name__ = true
Std.string = function(s) 
  do return _hx_tostring(s, 0) end;
end
Std.int = function(x) 
  if (not Math.isFinite(x) or Math.isNaN(x)) then 
    do return 0 end;
  else
    do return _hx_bit_clamp(x) end;
  end;
end
Std.parseInt = function(x) 
  if (x == nil) then 
    do return nil end;
  end;
  local hexMatch = _G.string.match(x, "^[ \t\r\n]*([%-+]*0[xX][%da-fA-F]*)");
  if (hexMatch ~= nil) then 
    local sign;
    local _g = _G.string.byte(hexMatch, 1);
    if (_g) == 43 then 
      sign = 1;
    elseif (_g) == 45 then 
      sign = -1;else
    sign = 0; end;
    local pos = (function() 
      local _hx_1
      if (sign == 0) then 
      _hx_1 = 2; else 
      _hx_1 = 3; end
      return _hx_1
    end )();
    local len = nil;
    if ((len == nil) or (len > (pos + #hexMatch))) then 
      len = #hexMatch;
    else
      if (len < 0) then 
        len = #hexMatch + len;
      end;
    end;
    if (pos < 0) then 
      pos = #hexMatch + pos;
    end;
    if (pos < 0) then 
      pos = 0;
    end;
    do return (function() 
      local _hx_2
      if (sign == -1) then 
      _hx_2 = -1; else 
      _hx_2 = 1; end
      return _hx_2
    end )() * _G.tonumber(_G.string.sub(hexMatch, pos + 1, pos + len), 16) end;
  else
    local intMatch = _G.string.match(x, "^ *[%-+]?%d*");
    if (intMatch ~= nil) then 
      do return _G.tonumber(intMatch) end;
    else
      do return nil end;
    end;
  end;
end
Std.parseFloat = function(x) 
  if ((x == nil) or (x == "")) then 
    do return (0/0) end;
  end;
  local digitMatch = _G.string.match(x, "^ *[%.%-+]?[0-9]%d*");
  if (digitMatch == nil) then 
    do return (0/0) end;
  end;
  local pos = #digitMatch;
  local len = nil;
  if ((len == nil) or (len > (pos + #x))) then 
    len = #x;
  else
    if (len < 0) then 
      len = #x + len;
    end;
  end;
  if (pos < 0) then 
    pos = #x + pos;
  end;
  if (pos < 0) then 
    pos = 0;
  end;
  x = _G.string.sub(x, pos + 1, pos + len);
  local decimalMatch = _G.string.match(x, "^%.%d*");
  if (decimalMatch == nil) then 
    decimalMatch = "";
  end;
  local pos = #decimalMatch;
  local len = nil;
  if ((len == nil) or (len > (pos + #x))) then 
    len = #x;
  else
    if (len < 0) then 
      len = #x + len;
    end;
  end;
  if (pos < 0) then 
    pos = #x + pos;
  end;
  if (pos < 0) then 
    pos = 0;
  end;
  x = _G.string.sub(x, pos + 1, pos + len);
  local eMatch = _G.string.match(x, "^[eE][+%-]?%d+");
  if (eMatch == nil) then 
    eMatch = "";
  end;
  local result = _G.tonumber(Std.string(Std.string(digitMatch) .. Std.string(decimalMatch)) .. Std.string(eMatch));
  if (result ~= nil) then 
    do return result end;
  else
    do return (0/0) end;
  end;
end

StringTools.new = {}
StringTools.__name__ = true
StringTools.isSpace = function(s,pos) 
  if (((#s == 0) or (pos < 0)) or (pos >= #s)) then 
    do return false end;
  end;
  local c = _G.string.byte(s, pos + 1);
  if (not ((c > 8) and (c < 14))) then 
    do return c == 32 end;
  else
    do return true end;
  end;
end
StringTools.ltrim = function(s) 
  local l = #s;
  local r = 0;
  while ((r < l) and StringTools.isSpace(s, r)) do 
    r = r + 1;
  end;
  if (r > 0) then 
    local pos = r;
    local len = l - r;
    if ((len == nil) or (len > (pos + #s))) then 
      len = #s;
    else
      if (len < 0) then 
        len = #s + len;
      end;
    end;
    if (pos < 0) then 
      pos = #s + pos;
    end;
    if (pos < 0) then 
      pos = 0;
    end;
    do return _G.string.sub(s, pos + 1, pos + len) end;
  else
    do return s end;
  end;
end
StringTools.rtrim = function(s) 
  local l = #s;
  local r = 0;
  while ((r < l) and StringTools.isSpace(s, (l - r) - 1)) do 
    r = r + 1;
  end;
  if (r > 0) then 
    local pos = 0;
    local len = l - r;
    if ((len == nil) or (len > (pos + #s))) then 
      len = #s;
    else
      if (len < 0) then 
        len = #s + len;
      end;
    end;
    if (pos < 0) then 
      pos = #s + pos;
    end;
    if (pos < 0) then 
      pos = 0;
    end;
    do return _G.string.sub(s, pos + 1, pos + len) end;
  else
    do return s end;
  end;
end
StringTools.trim = function(s) 
  do return StringTools.ltrim(StringTools.rtrim(s)) end;
end

__apparentridges_Util.new = {}
_hx_exports["apparentridges"]["Util"] = __apparentridges_Util
__apparentridges_Util.__name__ = true
__apparentridges_Util.rndInt = function(x) 
  do return Std.int(_G.math.floor(x + 0.5)) end;
end
__apparentridges_Util.min = function(a,b) 
  if (a > b) then 
    do return b end;
  else
    do return a end;
  end;
end
__apparentridges_Util.sq = function(x) 
  do return x * x end;
end
__apparentridges_Util.nextMod3 = function(i) 
  if (i < 2) then 
    do return i + 1 end;
  else
    do return i - 2 end;
  end;
end
__apparentridges_Util.prevMod3 = function(i) 
  if (i > 0) then 
    do return i - 1 end;
  else
    do return i + 2 end;
  end;
end
__apparentridges_Util.trinorm = function(v0,v1,v2) 
  local this1 = ({length = 3});
  local this1 = this1;
  this1[0] = v1[0] - v0[0];
  this1[1] = v1[1] - v0[1];
  this1[2] = v1[2] - v0[2];
  local v1 = this1;
  local this1 = ({length = 3});
  local this1 = this1;
  this1[0] = v2[0] - v0[0];
  this1[1] = v2[1] - v0[1];
  this1[2] = v2[2] - v0[2];
  local v2 = this1;
  local this1 = ({length = 3});
  local this1 = this1;
  this1[0] = (v1[1] * v2[2]) - (v1[2] * v2[1]);
  this1[1] = (v1[2] * v2[0]) - (v1[0] * v2[2]);
  this1[2] = (v1[0] * v2[1]) - (v1[1] * v2[0]);
  local this1 = this1;
  local this2 = ({length = 3});
  local this2 = this2;
  this2[0] = this1[0] * 0.5;
  this2[1] = this1[1] * 0.5;
  this2[2] = this1[2] * 0.5;
  do return this2 end;
end
__apparentridges_Util.ldltdc = function(A,rdiag) 
  local N = rdiag.length;
  if (N < 1) then 
    do return false end;
  else
    if (N <= 3) then 
      local d0 = A[0][0];
      rdiag[0] = 1 / d0;
      if (N == 1) then 
        do return d0 ~= 0 end;
      end;
      A[1][0] = A[0][1];
      local l10 = rdiag[0] * A[1][0];
      local d1 = A[1][1] - (l10 * A[1][0]);
      rdiag[1] = 1 / d1;
      if (N == 2) then 
        if (d0 ~= 0) then 
          do return d1 ~= 0 end;
        else
          do return false end;
        end;
      end;
      local x = A[2][0];
      local x1 = A[2][1];
      local d2 = (A[2][2] - (rdiag[0] * (x * x))) - (rdiag[1] * (x1 * x1));
      rdiag[2] = 1 / d2;
      A[2][0] = A[0][2];
      A[2][1] = A[1][2] - (l10 * A[2][0]);
      if ((d0 ~= 0) and (d1 ~= 0)) then 
        do return d2 ~= 0 end;
      else
        do return false end;
      end;
    end;
  end;
  local v = _hx_tab_array({}, 0);
  local _g = 0;
  local _g1 = N;
  while (_g < _g1) do 
    _g = _g + 1;
    local i = _g - 1;
    local _g = 0;
    local _g1 = i;
    while (_g < _g1) do 
      _g = _g + 1;
      local k = _g - 1;
      v[k] = A[i][k] * rdiag[k];
    end;
    local _g = i;
    local _g1 = N;
    while (_g < _g1) do 
      _g = _g + 1;
      local j = _g - 1;
      local sum = A[i][j];
      local _g = 0;
      local _g1 = i;
      while (_g < _g1) do 
        _g = _g + 1;
        local k = _g - 1;
        sum = sum - (v[k] * A[j][k]);
      end;
      if (i == j) then 
        if (sum == 0) then 
          do return false end;
        end;
        rdiag[i] = 1 / sum;
      else
        A[j][i] = sum;
      end;
    end;
  end;
  do return true end;
end
__apparentridges_Util.ldltsl = function(A,rdiag,b,x) 
  local N = rdiag.length;
  local _g = 0;
  local _g1 = N;
  while (_g < _g1) do 
    _g = _g + 1;
    local i = _g - 1;
    local sum = b[i];
    local _g = 0;
    local _g1 = i;
    while (_g < _g1) do 
      _g = _g + 1;
      local k = _g - 1;
      sum = sum - (A[i][k] * x[k]);
    end;
    x[i] = sum * rdiag[i];
  end;
  local _g = 0;
  local _g1 = N;
  while (_g < _g1) do 
    _g = _g + 1;
    local _i = _g - 1;
    local i = (N - _i) - 1;
    local sum = 0;
    local _g = i + 1;
    local _g1 = N;
    while (_g < _g1) do 
      _g = _g + 1;
      local k = _g - 1;
      sum = sum + (A[k][i] * x[k]);
    end;
    local x = x;
    local i1 = i;
    x[i1] = x[i1] - (sum * rdiag[i]);
  end;
end
__apparentridges_Util.largestEig2x2 = function(m1,m12,m2) 
  local l1 = 0.5 * (m1 + m2);
  if (l1 > 0.0) then 
    local x = m2 - m1;
    l1 = l1 + _G.math.sqrt((m12 * m12) + (0.25 * (x * x)));
  else
    local x = m2 - m1;
    l1 = l1 - _G.math.sqrt((m12 * m12) + (0.25 * (x * x)));
  end;
  local this1 = ({length = 3});
  local this1 = this1;
  this1[0] = m2 - l1;
  this1[1] = -m12;
  this1[2] = 0;
  local e1 = this1;
  local l = _G.math.sqrt(((e1[0] * e1[0]) + (e1[1] * e1[1])) + (e1[2] * e1[2]));
  if (l > 0) then 
    l = 1 / l;
    local _g = e1;
    _g[0] = _g[0] * l;
    local _g = e1;
    _g[1] = _g[1] * l;
    local _g = e1;
    _g[2] = _g[2] * l;
  else
    e1[0] = 0;
    e1[1] = 0;
    e1[2] = 1;
  end;
  e1[2] = l1;
  do return e1 end;
end
__apparentridges_Util.matIden = function() 
  do return _hx_tab_array({[0]=1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1}, 16) end;
end
__apparentridges_Util.matRotx = function(a) 
  do return _hx_tab_array({[0]=1, 0, 0, 0, 0, _G.math.cos(a), -_G.math.sin(a), 0, 0, _G.math.sin(a), _G.math.cos(a), 0, 0, 0, 0, 1}, 16) end;
end
__apparentridges_Util.matRoty = function(a) 
  do return _hx_tab_array({[0]=_G.math.cos(a), 0, _G.math.sin(a), 0, 0, 1, 0, 0, -_G.math.sin(a), 0, _G.math.cos(a), 0, 0, 0, 0, 1}, 16) end;
end
__apparentridges_Util.matRotz = function(a) 
  do return _hx_tab_array({[0]=_G.math.cos(a), -_G.math.sin(a), 0, 0, _G.math.sin(a), _G.math.cos(a), 0, 0, 0, 0, 1, 0, 0, 0, 0, 1}, 16) end;
end
__apparentridges_Util.matTrsl = function(x,y,z) 
  do return _hx_tab_array({[0]=1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1}, 16) end;
end
__apparentridges_Util.matScal = function(x,y,z) 
  do return _hx_tab_array({[0]=x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1}, 16) end;
end
__apparentridges_Util.matMult = function(A,B) 
  do return _hx_tab_array({[0]=(((A[0] * B[0]) + (A[1] * B[4])) + (A[2] * B[8])) + (A[3] * B[12]), (((A[0] * B[1]) + (A[1] * B[5])) + (A[2] * B[9])) + (A[3] * B[13]), (((A[0] * B[2]) + (A[1] * B[6])) + (A[2] * B[10])) + (A[3] * B[14]), (((A[0] * B[3]) + (A[1] * B[7])) + (A[2] * B[11])) + (A[3] * B[15]), (((A[4] * B[0]) + (A[5] * B[4])) + (A[6] * B[8])) + (A[7] * B[12]), (((A[4] * B[1]) + (A[5] * B[5])) + (A[6] * B[9])) + (A[7] * B[13]), (((A[4] * B[2]) + (A[5] * B[6])) + (A[6] * B[10])) + (A[7] * B[14]), (((A[4] * B[3]) + (A[5] * B[7])) + (A[6] * B[11])) + (A[7] * B[15]), (((A[8] * B[0]) + (A[9] * B[4])) + (A[10] * B[8])) + (A[11] * B[12]), (((A[8] * B[1]) + (A[9] * B[5])) + (A[10] * B[9])) + (A[11] * B[13]), (((A[8] * B[2]) + (A[9] * B[6])) + (A[10] * B[10])) + (A[11] * B[14]), (((A[8] * B[3]) + (A[9] * B[7])) + (A[10] * B[11])) + (A[11] * B[15]), (((A[12] * B[0]) + (A[13] * B[4])) + (A[14] * B[8])) + (A[15] * B[12]), (((A[12] * B[1]) + (A[13] * B[5])) + (A[14] * B[9])) + (A[15] * B[13]), (((A[12] * B[2]) + (A[13] * B[6])) + (A[14] * B[10])) + (A[15] * B[14]), (((A[12] * B[3]) + (A[13] * B[7])) + (A[14] * B[11])) + (A[15] * B[15])}, 16) end;
end
__apparentridges_Util.matTrfm = function(A,v) 
  local this1 = ({length = 3});
  local this1 = this1;
  this1[0] = ((((A[0] * v[0]) + (A[1] * v[1])) + (A[2] * v[2])) + A[3]) / ((((A[12] * v[0]) + (A[13] * v[1])) + (A[14] * v[2])) + A[15]);
  this1[1] = ((((A[4] * v[0]) + (A[5] * v[1])) + (A[6] * v[2])) + A[7]) / ((((A[12] * v[0]) + (A[13] * v[1])) + (A[14] * v[2])) + A[15]);
  this1[2] = ((((A[8] * v[0]) + (A[9] * v[1])) + (A[10] * v[2])) + A[11]) / ((((A[12] * v[0]) + (A[13] * v[1])) + (A[14] * v[2])) + A[15]);
  do return this1 end;
end
__apparentridges_Util.matProj = function(f,v) 
  local this1 = ({length = 3});
  local this1 = this1;
  this1[0] = (f * v[0]) / v[2];
  this1[1] = (f * v[1]) / v[2];
  this1[2] = 0;
  do return this1 end;
end
__apparentridges_Util.uniformHemisphereSampler = function() 
  local Xi1 = _G.math.random();
  local Xi2 = _G.math.random();
  local theta = _G.math.acos(Xi1);
  local phi = (2 * _G.math.pi) * Xi2;
  local xs = _G.math.sin(theta) * _G.math.cos(phi);
  local ys = _G.math.sin(theta) * _G.math.sin(phi);
  local zs = _G.math.cos(theta);
  local this1 = ({length = 3});
  local this1 = this1;
  this1[0] = xs;
  this1[1] = ys;
  this1[2] = zs;
  local v = this1;
  do return v end;
end
__apparentridges_Util.writeFile = function(filename,content) 
  __sys_io_File.saveContent(filename, content);
end

__apparentridges__ApparentRidges_Vec3_Impl_.new = {}
_hx_exports["apparentridges"]["_ApparentRidges"]["Vec3_Impl_"] = __apparentridges__ApparentRidges_Vec3_Impl_
__apparentridges__ApparentRidges_Vec3_Impl_.__name__ = true
__apparentridges__ApparentRidges_Vec3_Impl_._new = function(_x,_y,_z) 
  local this1 = ({length = 3});
  local this1 = this1;
  this1[0] = _x;
  this1[1] = _y;
  this1[2] = _z;
  do return this1 end;
end
__apparentridges__ApparentRidges_Vec3_Impl_.get_x = function(this1) 
  do return this1[0] end;
end
__apparentridges__ApparentRidges_Vec3_Impl_.get_y = function(this1) 
  do return this1[1] end;
end
__apparentridges__ApparentRidges_Vec3_Impl_.get_z = function(this1) 
  do return this1[2] end;
end
__apparentridges__ApparentRidges_Vec3_Impl_.set_x = function(this1,v) 
  this1[0] = v do return this1[0] end;
end
__apparentridges__ApparentRidges_Vec3_Impl_.set_y = function(this1,v) 
  this1[1] = v do return this1[1] end;
end
__apparentridges__ApparentRidges_Vec3_Impl_.set_z = function(this1,v) 
  this1[2] = v do return this1[2] end;
end
__apparentridges__ApparentRidges_Vec3_Impl_.copy = function(this1) 
  local this2 = ({length = 3});
  local this2 = this2;
  this2[0] = this1[0];
  this2[1] = this1[1];
  this2[2] = this1[2];
  do return this2 end;
end
__apparentridges__ApparentRidges_Vec3_Impl_.assign = function(this1,v) 
  this1[0] = v[0];
  this1[1] = v[1];
  this1[2] = v[2];
end
__apparentridges__ApparentRidges_Vec3_Impl_.cross = function(v1,v2) 
  local this1 = ({length = 3});
  local this1 = this1;
  this1[0] = (v1[1] * v2[2]) - (v1[2] * v2[1]);
  this1[1] = (v1[2] * v2[0]) - (v1[0] * v2[2]);
  this1[2] = (v1[0] * v2[1]) - (v1[1] * v2[0]);
  do return this1 end;
end
__apparentridges__ApparentRidges_Vec3_Impl_.dot = function(v1,v2) 
  do return ((v1[0] * v2[0]) + (v1[1] * v2[1])) + (v1[2] * v2[2]) end;
end
__apparentridges__ApparentRidges_Vec3_Impl_.dist2 = function(v1,v2) 
  local x = v1[0] - v2[0];
  local x1 = v1[1] - v2[1];
  local x2 = v1[2] - v2[2];
  do return ((x * x) + (x1 * x1)) + (x2 * x2) end;
end
__apparentridges__ApparentRidges_Vec3_Impl_.dist = function(v1,v2) 
  local x = v1[0] - v2[0];
  local x1 = v1[1] - v2[1];
  local x2 = v1[2] - v2[2];
  do return _G.math.sqrt(((x * x) + (x1 * x1)) + (x2 * x2)) end;
end
__apparentridges__ApparentRidges_Vec3_Impl_.len = function(this1) 
  do return _G.math.sqrt(((this1[0] * this1[0]) + (this1[1] * this1[1])) + (this1[2] * this1[2])) end;
end
__apparentridges__ApparentRidges_Vec3_Impl_.len2 = function(this1) 
  do return ((this1[0] * this1[0]) + (this1[1] * this1[1])) + (this1[2] * this1[2]) end;
end
__apparentridges__ApparentRidges_Vec3_Impl_.normalize = function(this1) 
  local l = _G.math.sqrt(((this1[0] * this1[0]) + (this1[1] * this1[1])) + (this1[2] * this1[2]));
  if (l > 0) then 
    l = 1 / l;
    local _g = this1;
    _g[0] = _g[0] * l;
    local _g = this1;
    _g[1] = _g[1] * l;
    local _g = this1;
    _g[2] = _g[2] * l;
  else
    this1[0] = 0;
    this1[1] = 0;
    this1[2] = 1;
  end;
end
__apparentridges__ApparentRidges_Vec3_Impl_.scale = function(this1,s) 
  local _g = this1;
  _g[0] = _g[0] * s;
  local _g = this1;
  _g[1] = _g[1] * s;
  local _g = this1;
  _g[2] = _g[2] * s;
end
__apparentridges__ApparentRidges_Vec3_Impl_.get = function(this1,i) 
  do return this1[i] end;
end
__apparentridges__ApparentRidges_Vec3_Impl_.set = function(this1,i,v) 
  this1[i] = v;
  do return v end;
end
__apparentridges__ApparentRidges_Vec3_Impl_.add = function(this1,rhs) 
  local this2 = ({length = 3});
  local this2 = this2;
  this2[0] = this1[0] + rhs[0];
  this2[1] = this1[1] + rhs[1];
  this2[2] = this1[2] + rhs[2];
  do return this2 end;
end
__apparentridges__ApparentRidges_Vec3_Impl_.sub = function(this1,rhs) 
  local this2 = ({length = 3});
  local this2 = this2;
  this2[0] = this1[0] - rhs[0];
  this2[1] = this1[1] - rhs[1];
  this2[2] = this1[2] - rhs[2];
  do return this2 end;
end
__apparentridges__ApparentRidges_Vec3_Impl_.mul = function(this1,rhs) 
  local this2 = ({length = 3});
  local this2 = this2;
  this2[0] = this1[0] * rhs[0];
  this2[1] = this1[1] * rhs[1];
  this2[2] = this1[2] * rhs[2];
  do return this2 end;
end
__apparentridges__ApparentRidges_Vec3_Impl_.mulf = function(this1,rhs) 
  local this2 = ({length = 3});
  local this2 = this2;
  this2[0] = this1[0] * rhs;
  this2[1] = this1[1] * rhs;
  this2[2] = this1[2] * rhs;
  do return this2 end;
end

__apparentridges__ApparentRidges_Face_Impl_.new = {}
_hx_exports["apparentridges"]["_ApparentRidges"]["Face_Impl_"] = __apparentridges__ApparentRidges_Face_Impl_
__apparentridges__ApparentRidges_Face_Impl_.__name__ = true
__apparentridges__ApparentRidges_Face_Impl_._new = function(a,b,c) 
  local this1 = ({length = 3});
  local this1 = this1;
  this1[0] = a;
  this1[1] = b;
  this1[2] = c;
  do return this1 end;
end
__apparentridges__ApparentRidges_Face_Impl_.get = function(this1,i) 
  do return this1[i] end;
end
__apparentridges__ApparentRidges_Face_Impl_.set = function(this1,i,v) 
  this1[i] = v;
  do return v end;
end
__apparentridges__ApparentRidges_Face_Impl_.indexOf = function(this1,v) 
  if (this1[0] == v) then 
    do return 0 end;
  end;
  if (this1[1] == v) then 
    do return 1 end;
  end;
  if (this1[2] == v) then 
    do return 2 end;
  end;
  do return -1 end;
end

__apparentridges_Ridge.new = function(a,sa,b,sb) 
  local self = _hx_new(__apparentridges_Ridge.prototype)
  __apparentridges_Ridge.super(self,a,sa,b,sb)
  return self
end
__apparentridges_Ridge.super = function(self,a,sa,b,sb) 
  self.A = a;
  self.strengthA = sa;
  self.B = b;
  self.strengthB = sb;
end
_hx_exports["apparentridges"]["Ridge"] = __apparentridges_Ridge
__apparentridges_Ridge.__name__ = true
__apparentridges_Ridge.prototype = _hx_e();

__apparentridges_Ridge.prototype.__class__ =  __apparentridges_Ridge

__apparentridges_BSphere.new = function() 
  local self = _hx_new(__apparentridges_BSphere.prototype)
  __apparentridges_BSphere.super(self)
  return self
end
__apparentridges_BSphere.super = function(self) 
end
_hx_exports["apparentridges"]["BSphere"] = __apparentridges_BSphere
__apparentridges_BSphere.__name__ = true
__apparentridges_BSphere.prototype = _hx_e();

__apparentridges_BSphere.prototype.__class__ =  __apparentridges_BSphere

__apparentridges_Mesh.new = function() 
  local self = _hx_new(__apparentridges_Mesh.prototype)
  __apparentridges_Mesh.super(self)
  return self
end
__apparentridges_Mesh.super = function(self) 
  self.Dt1q1 = _hx_tab_array({}, 0);
  self.t1q1 = _hx_tab_array({}, 0);
  self.ndotv = _hx_tab_array({}, 0);
  self.adjacentFaces = _hx_tab_array({}, 0);
  self.cornerAreas = _hx_tab_array({}, 0);
  self.pointAreas = _hx_tab_array({}, 0);
  self.pdir2 = _hx_tab_array({}, 0);
  self.pdir1 = _hx_tab_array({}, 0);
  self.curv2 = _hx_tab_array({}, 0);
  self.curv1 = _hx_tab_array({}, 0);
  self.normals = _hx_tab_array({}, 0);
  self.faces = _hx_tab_array({}, 0);
  self.vertices = _hx_tab_array({}, 0);
end
_hx_exports["apparentridges"]["Mesh"] = __apparentridges_Mesh
__apparentridges_Mesh.__name__ = true
__apparentridges_Mesh.rotCoordSys = function(old_u,old_v,new_norm,new_u,new_v) 
  new_u[0] = old_u[0];
  new_u[1] = old_u[1];
  new_u[2] = old_u[2];
  new_v[0] = old_v[0];
  new_v[1] = old_v[1];
  new_v[2] = old_v[2];
  local this1 = ({length = 3});
  local this1 = this1;
  this1[0] = (old_u[1] * old_v[2]) - (old_u[2] * old_v[1]);
  this1[1] = (old_u[2] * old_v[0]) - (old_u[0] * old_v[2]);
  this1[2] = (old_u[0] * old_v[1]) - (old_u[1] * old_v[0]);
  local old_norm = this1;
  local ndot = ((old_norm[0] * new_norm[0]) + (old_norm[1] * new_norm[1])) + (old_norm[2] * new_norm[2]);
  if (ndot <= -1) then 
    local _g = new_u;
    _g[0] = _g[0] * -1;
    local _g = new_u;
    _g[1] = _g[1] * -1;
    local _g = new_u;
    _g[2] = _g[2] * -1;
    local _g = new_v;
    _g[0] = _g[0] * -1;
    local _g = new_v;
    _g[1] = _g[1] * -1;
    local _g = new_v;
    _g[2] = _g[2] * -1;
    do return end;
  end;
  local this1 = ({length = 3});
  local this1 = this1;
  this1[0] = old_norm[0] * ndot;
  this1[1] = old_norm[1] * ndot;
  this1[2] = old_norm[2] * ndot;
  local rhs = this1;
  local this1 = ({length = 3});
  local this1 = this1;
  this1[0] = new_norm[0] - rhs[0];
  this1[1] = new_norm[1] - rhs[1];
  this1[2] = new_norm[2] - rhs[2];
  local perp_old = this1;
  local this1 = ({length = 3});
  local this1 = this1;
  this1[0] = old_norm[0] + new_norm[0];
  this1[1] = old_norm[1] + new_norm[1];
  this1[2] = old_norm[2] + new_norm[2];
  local this1 = this1;
  local rhs = 1 / (1 + ndot);
  local this2 = ({length = 3});
  local this2 = this2;
  this2[0] = this1[0] * rhs;
  this2[1] = this1[1] * rhs;
  this2[2] = this1[2] * rhs;
  local dperp = this2;
  local rhs = ((new_u[0] * perp_old[0]) + (new_u[1] * perp_old[1])) + (new_u[2] * perp_old[2]);
  local this1 = ({length = 3});
  local this1 = this1;
  this1[0] = dperp[0] * rhs;
  this1[1] = dperp[1] * rhs;
  this1[2] = dperp[2] * rhs;
  local rhs = this1;
  local this1 = ({length = 3});
  local this1 = this1;
  this1[0] = new_u[0] - rhs[0];
  this1[1] = new_u[1] - rhs[1];
  this1[2] = new_u[2] - rhs[2];
  new_u = this1;
  local rhs = ((new_v[0] * perp_old[0]) + (new_v[1] * perp_old[1])) + (new_v[2] * perp_old[2]);
  local this1 = ({length = 3});
  local this1 = this1;
  this1[0] = dperp[0] * rhs;
  this1[1] = dperp[1] * rhs;
  this1[2] = dperp[2] * rhs;
  local rhs = this1;
  local this1 = ({length = 3});
  local this1 = this1;
  this1[0] = new_v[0] - rhs[0];
  this1[1] = new_v[1] - rhs[1];
  this1[2] = new_v[2] - rhs[2];
  new_v = this1;
end
__apparentridges_Mesh.projCurv = function(old_u,old_v,old_ku,old_kuv,old_kv,new_u,new_v) 
  local this1 = ({length = 3});
  local this1 = this1;
  this1[0] = 0;
  this1[1] = 0;
  this1[2] = 0;
  local r_new_u = this1;
  local this1 = ({length = 3});
  local this1 = this1;
  this1[0] = 0;
  this1[1] = 0;
  this1[2] = 0;
  local r_new_v = this1;
  local this1 = ({length = 3});
  local this1 = this1;
  this1[0] = (old_u[1] * old_v[2]) - (old_u[2] * old_v[1]);
  this1[1] = (old_u[2] * old_v[0]) - (old_u[0] * old_v[2]);
  this1[2] = (old_u[0] * old_v[1]) - (old_u[1] * old_v[0]);
  __apparentridges_Mesh.rotCoordSys(new_u, new_v, this1, r_new_u, r_new_v);
  local u1 = ((r_new_u[0] * old_u[0]) + (r_new_u[1] * old_u[1])) + (r_new_u[2] * old_u[2]);
  local v1 = ((r_new_u[0] * old_v[0]) + (r_new_u[1] * old_v[1])) + (r_new_u[2] * old_v[2]);
  local u2 = ((r_new_v[0] * old_u[0]) + (r_new_v[1] * old_u[1])) + (r_new_v[2] * old_u[2]);
  local v2 = ((r_new_v[0] * old_v[0]) + (r_new_v[1] * old_v[1])) + (r_new_v[2] * old_v[2]);
  local new_ku = (((old_ku * u1) * u1) + (old_kuv * ((2 * u1) * v1))) + ((old_kv * v1) * v1);
  local new_kuv = (((old_ku * u1) * u2) + (old_kuv * ((u1 * v2) + (u2 * v1)))) + ((old_kv * v1) * v2);
  local new_kv = (((old_ku * u2) * u2) + (old_kuv * ((2 * u2) * v2))) + ((old_kv * v2) * v2);
  local this1 = ({length = 3});
  local this1 = this1;
  this1[0] = new_ku;
  this1[1] = new_kuv;
  this1[2] = new_kv;
  do return this1 end;
end
__apparentridges_Mesh.diagonalizeCurv = function(old_u,old_v,ku,kuv,kv,new_norm,pd1,pd2,k1k2) 
  local this1 = ({length = 3});
  local this1 = this1;
  this1[0] = 0;
  this1[1] = 0;
  this1[2] = 0;
  local r_old_u = this1;
  local this1 = ({length = 3});
  local this1 = this1;
  this1[0] = 0;
  this1[1] = 0;
  this1[2] = 0;
  local r_old_v = this1;
  __apparentridges_Mesh.rotCoordSys(old_u, old_v, new_norm, r_old_u, r_old_v);
  local c = 1;
  local s = 0;
  local tt = 0;
  if (kuv ~= 0.0) then 
    local h = (0.5 * (kv - ku)) / kuv;
    tt = (function() 
      local _hx_1
      if (h < 0.0) then 
      _hx_1 = 1.0 / (h - _G.math.sqrt(1.0 + (h * h))); else 
      _hx_1 = 1.0 / (h + _G.math.sqrt(1.0 + (h * h))); end
      return _hx_1
    end )();
    c = 1.0 / _G.math.sqrt(1.0 + (tt * tt));
    s = tt * c;
  end;
  local k1 = ku - (tt * kuv);
  local k2 = kv + (tt * kuv);
  if (_G.math.abs(k1) >= _G.math.abs(k2)) then 
    k1k2[0] = k1;
    k1k2[1] = k2;
    local this1 = ({length = 3});
    local this1 = this1;
    this1[0] = r_old_u[0] * c;
    this1[1] = r_old_u[1] * c;
    this1[2] = r_old_u[2] * c;
    local this1 = this1;
    local this2 = ({length = 3});
    local this2 = this2;
    this2[0] = r_old_v[0] * s;
    this2[1] = r_old_v[1] * s;
    this2[2] = r_old_v[2] * s;
    local rhs = this2;
    local this2 = ({length = 3});
    local this2 = this2;
    this2[0] = this1[0] - rhs[0];
    this2[1] = this1[1] - rhs[1];
    this2[2] = this1[2] - rhs[2];
    local v = this2;
    pd1[0] = v[0];
    pd1[1] = v[1];
    pd1[2] = v[2];
  else
    k1k2[0] = k2;
    k1k2[1] = k1;
    local this1 = ({length = 3});
    local this1 = this1;
    this1[0] = r_old_u[0] * s;
    this1[1] = r_old_u[1] * s;
    this1[2] = r_old_u[2] * s;
    local this1 = this1;
    local this2 = ({length = 3});
    local this2 = this2;
    this2[0] = r_old_v[0] * c;
    this2[1] = r_old_v[1] * c;
    this2[2] = r_old_v[2] * c;
    local rhs = this2;
    local this2 = ({length = 3});
    local this2 = this2;
    this2[0] = this1[0] + rhs[0];
    this2[1] = this1[1] + rhs[1];
    this2[2] = this1[2] + rhs[2];
    local v = this2;
    pd1[0] = v[0];
    pd1[1] = v[1];
    pd1[2] = v[2];
  end;
  local this1 = ({length = 3});
  local this1 = this1;
  this1[0] = (new_norm[1] * pd1[2]) - (new_norm[2] * pd1[1]);
  this1[1] = (new_norm[2] * pd1[0]) - (new_norm[0] * pd1[2]);
  this1[2] = (new_norm[0] * pd1[1]) - (new_norm[1] * pd1[0]);
  local v = this1;
  pd2[0] = v[0];
  pd2[1] = v[1];
  pd2[2] = v[2];
end
__apparentridges_Mesh.prototype = _hx_e();
__apparentridges_Mesh.prototype.precompute = function(self,doBVH,verb) 
  if (verb == nil) then 
    verb = false;
  end;
  if (doBVH == nil) then 
    doBVH = true;
  end;
  if (verb) then 
    __haxe_Log.trace("computing normals...", _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="apparentridges/ApparentRidges.hx",lineNumber=337,className="apparentridges.Mesh",methodName="precompute"}));
  end;
  self:computeNormals();
  if (verb) then 
    __haxe_Log.trace("computing point areas...", _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="apparentridges/ApparentRidges.hx",lineNumber=339,className="apparentridges.Mesh",methodName="precompute"}));
  end;
  self:computePointAreas();
  if (verb) then 
    __haxe_Log.trace("computing adjacent faces...", _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="apparentridges/ApparentRidges.hx",lineNumber=341,className="apparentridges.Mesh",methodName="precompute"}));
  end;
  self:computeAdjacentFaces();
  if (verb) then 
    __haxe_Log.trace("computing curvatures...", _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="apparentridges/ApparentRidges.hx",lineNumber=343,className="apparentridges.Mesh",methodName="precompute"}));
  end;
  self:computeCurvatures();
  if (verb) then 
    __haxe_Log.trace("computing bounding sphere...", _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="apparentridges/ApparentRidges.hx",lineNumber=345,className="apparentridges.Mesh",methodName="precompute"}));
  end;
  self:computeBSphere();
  if (verb) then 
    __haxe_Log.trace("computing feature size...", _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="apparentridges/ApparentRidges.hx",lineNumber=347,className="apparentridges.Mesh",methodName="precompute"}));
  end;
  self:computeFeatureSize();
  if (verb) then 
    __haxe_Log.trace("computing bounding volume hierarchy...", _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="apparentridges/ApparentRidges.hx",lineNumber=349,className="apparentridges.Mesh",methodName="precompute"}));
  end;
  if (doBVH) then 
    self:computeBVH();
  else
    self:computeBVHTrivial();
  end;
  if (verb) then 
    __haxe_Log.trace("pre-computation finished.", _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="apparentridges/ApparentRidges.hx",lineNumber=351,className="apparentridges.Mesh",methodName="precompute"}));
  end;
end
__apparentridges_Mesh.prototype.computeNormals = function(self) 
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = self.vertices.length;
  while (_g1 < _g2) do 
    _g1 = _g1 + 1;
    local i = _g1 - 1;
    local this1 = ({length = 3});
    local this1 = this1;
    this1[0] = 0;
    this1[1] = 0;
    this1[2] = 0;
    _g:push(this1);
  end;
  self.normals = _g;
  local _g = 0;
  local _g1 = self.faces;
  while (_g < _g1.length) do 
    local f = _g1[_g];
    _g = _g + 1;
    local p0 = self.vertices[f[0]];
    local p1 = self.vertices[f[1]];
    local p2 = self.vertices[f[2]];
    local this1 = ({length = 3});
    local this1 = this1;
    this1[0] = p0[0] - p1[0];
    this1[1] = p0[1] - p1[1];
    this1[2] = p0[2] - p1[2];
    local a = this1;
    local this1 = ({length = 3});
    local this1 = this1;
    this1[0] = p1[0] - p2[0];
    this1[1] = p1[1] - p2[1];
    this1[2] = p1[2] - p2[2];
    local b = this1;
    local this1 = ({length = 3});
    local this1 = this1;
    this1[0] = (a[1] * b[2]) - (a[2] * b[1]);
    this1[1] = (a[2] * b[0]) - (a[0] * b[2]);
    this1[2] = (a[0] * b[1]) - (a[1] * b[0]);
    local fn = this1;
    local tmp = self.normals;
    local f1 = f[0];
    local this1 = self.normals[f[0]];
    local this2 = ({length = 3});
    local this2 = this2;
    this2[0] = this1[0] + fn[0];
    this2[1] = this1[1] + fn[1];
    this2[2] = this1[2] + fn[2];
    tmp[f1] = this2;
    local tmp = self.normals;
    local f1 = f[1];
    local this1 = self.normals[f[1]];
    local this2 = ({length = 3});
    local this2 = this2;
    this2[0] = this1[0] + fn[0];
    this2[1] = this1[1] + fn[1];
    this2[2] = this1[2] + fn[2];
    tmp[f1] = this2;
    local tmp = self.normals;
    local f1 = f[2];
    local this1 = self.normals[f[2]];
    local this2 = ({length = 3});
    local this2 = this2;
    this2[0] = this1[0] + fn[0];
    this2[1] = this1[1] + fn[1];
    this2[2] = this1[2] + fn[2];
    tmp[f1] = this2;
  end;
  local _g = 0;
  local _g1 = self.normals;
  while (_g < _g1.length) do 
    local n = _g1[_g];
    _g = _g + 1;
    local l = _G.math.sqrt(((n[0] * n[0]) + (n[1] * n[1])) + (n[2] * n[2]));
    if (l > 0) then 
      l = 1 / l;
      local _g = n;
      _g[0] = _g[0] * l;
      local _g = n;
      _g[1] = _g[1] * l;
      local _g = n;
      _g[2] = _g[2] * l;
    else
      n[0] = 0;
      n[1] = 0;
      n[2] = 1;
    end;
  end;
end
__apparentridges_Mesh.prototype.computeBSphere = function(self) 
  local _gthis = self;
  self.bsphere = __apparentridges_BSphere.new();
  local farthestVertexAlong = function(dir) 
    local nv = _gthis.vertices.length;
    local far = 0;
    local v1 = _gthis.vertices[0];
    local far_dot = ((v1[0] * dir[0]) + (v1[1] * dir[1])) + (v1[2] * dir[2]);
    local _g = 1;
    local _g1 = nv;
    while (_g < _g1) do 
      _g = _g + 1;
      local i = _g - 1;
      local v1 = _gthis.vertices[i];
      local my_dot = ((v1[0] * dir[0]) + (v1[1] * dir[1])) + (v1[2] * dir[2]);
      if (my_dot > far_dot) then 
        far = i;
        far_dot = my_dot;
      end;
    end;
    do return far end;
  end;
  local this1 = ({length = 3});
  local this1 = this1;
  this1[0] = 0;
  this1[1] = 0;
  this1[2] = 0;
  local best_min = this1;
  local this1 = ({length = 3});
  local this1 = this1;
  this1[0] = 0;
  this1[1] = 0;
  this1[2] = 0;
  local best_max = this1;
  local this1 = ({length = 3});
  local this1 = this1;
  this1[0] = 1;
  this1[1] = 0;
  this1[2] = 0;
  local this2 = ({length = 3});
  local this2 = this2;
  this2[0] = 0;
  this2[1] = 1;
  this2[2] = 0;
  local this3 = ({length = 3});
  local this3 = this3;
  this3[0] = 0;
  this3[1] = 0;
  this3[2] = 1;
  local this4 = ({length = 3});
  local this4 = this4;
  this4[0] = 1;
  this4[1] = 1;
  this4[2] = 1;
  local this5 = ({length = 3});
  local this5 = this5;
  this5[0] = 1;
  this5[1] = -1;
  this5[2] = 1;
  local this6 = ({length = 3});
  local this6 = this6;
  this6[0] = 1;
  this6[1] = -1;
  this6[2] = -1;
  local this7 = ({length = 3});
  local this7 = this7;
  this7[0] = 1;
  this7[1] = 1;
  this7[2] = 1;
  local dirs = _hx_tab_array({[0]=this1, this2, this3, this4, this5, this6, this7}, 7);
  local _g = 0;
  while (_g < dirs.length) do 
    local d = dirs[_g];
    _g = _g + 1;
    local p1 = self.vertices;
    local this1 = ({length = 3});
    local this1 = this1;
    this1[0] = d[0] * -1.0;
    this1[1] = d[1] * -1.0;
    this1[2] = d[2] * -1.0;
    local p1 = p1[farthestVertexAlong(this1)];
    local p2 = self.vertices[farthestVertexAlong(d)];
    local x = p1[0] - p2[0];
    local x1 = p1[1] - p2[1];
    local x2 = p1[2] - p2[2];
    local x3 = best_min[0] - best_max[0];
    local x4 = best_min[1] - best_max[1];
    local x5 = best_min[2] - best_max[2];
    if ((((x * x) + (x1 * x1)) + (x2 * x2)) > (((x3 * x3) + (x4 * x4)) + (x5 * x5))) then 
      best_min = p1;
      best_max = p2;
    end;
  end;
  local this1 = ({length = 3});
  local this1 = this1;
  this1[0] = best_min[0] + best_max[0];
  this1[1] = best_min[1] + best_max[1];
  this1[2] = best_min[2] + best_max[2];
  local this1 = this1;
  local this2 = ({length = 3});
  local this2 = this2;
  this2[0] = this1[0] * 0.5;
  this2[1] = this1[1] * 0.5;
  this2[2] = this1[2] * 0.5;
  self.bsphere.o = this2;
  local x = best_min[0] - best_max[0];
  local x1 = best_min[1] - best_max[1];
  local x2 = best_min[2] - best_max[2];
  local tmp = _G.math.sqrt(((x * x) + (x1 * x1)) + (x2 * x2));
  self.bsphere.r = tmp * 0.5;
  local x = self.bsphere.r;
  local r2 = x * x;
  local _g = 0;
  local _g1 = self.vertices.length;
  local _hx_continue_1 = false;
  while (_g < _g1) do repeat 
    _g = _g + 1;
    local i = _g - 1;
    local v1 = self.vertices[i];
    local v2 = self.bsphere.o;
    local x = v1[0] - v2[0];
    local x1 = v1[1] - v2[1];
    local x2 = v1[2] - v2[2];
    local d2 = ((x * x) + (x1 * x1)) + (x2 * x2);
    if (d2 <= r2) then 
      break;
    end;
    local d = _G.math.sqrt(d2);
    self.bsphere.r = 0.5 * (self.bsphere.r + d);
    local x = self.bsphere.r;
    r2 = x * x;
    local this1 = self.bsphere.o;
    local rhs = self.vertices[i];
    local this2 = ({length = 3});
    local this2 = this2;
    this2[0] = this1[0] - rhs[0];
    this2[1] = this1[1] - rhs[1];
    this2[2] = this1[2] - rhs[2];
    self.bsphere.o = this2;
    local this1 = self.bsphere.o;
    local rhs = self.bsphere.r * (1.0 / d);
    local this2 = ({length = 3});
    local this2 = this2;
    this2[0] = this1[0] * rhs;
    this2[1] = this1[1] * rhs;
    this2[2] = this1[2] * rhs;
    self.bsphere.o = this2;
    local this1 = self.bsphere.o;
    local rhs = self.vertices[i];
    local this2 = ({length = 3});
    local this2 = this2;
    this2[0] = this1[0] + rhs[0];
    this2[1] = this1[1] + rhs[1];
    this2[2] = this1[2] + rhs[2];
    self.bsphere.o = this2;until true
    if _hx_continue_1 then 
    _hx_continue_1 = false;
    break;
    end;
    
  end;
end
__apparentridges_Mesh.prototype.computeFeatureSize = function(self) 
  local nv = self.curv1.length;
  local nsamp = (function() 
    local _hx_1
    if (nv > 500) then 
    _hx_1 = 500; else 
    _hx_1 = nv; end
    return _hx_1
  end )();
  local samples = _hx_tab_array({}, 0);
  local s = 79;
  local p = 103;
  local q = 211;
  local m = p * q;
  local _g = 0;
  local _g1 = nsamp;
  while (_g < _g1) do 
    _g = _g + 1;
    local i = _g - 1;
    local ind = Std.int(nv * (s / m));
    s = _G.math.fmod(s * s, m);
    samples:push(_G.math.abs(self.curv1[ind]));
    samples:push(_G.math.abs(self.curv2[ind]));
  end;
  local frac = 0.1;
  local mult = 0.01;
  local max_feat_size = 0.05 * self.bsphere.r;
  local which = Std.int(frac * samples.length);
  samples:sort(function(a,b) 
    if (a < b) then 
      do return -1 end;
    else
      if (a > b) then 
        do return 1 end;
      else
        do return 0 end;
      end;
    end;
  end);
  self.featureSize = Math.min(mult / samples[which], max_feat_size);
end
__apparentridges_Mesh.prototype.computeAdjacentFaces = function(self) 
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = self.vertices.length;
  while (_g1 < _g2) do 
    _g1 = _g1 + 1;
    local i = _g1 - 1;
    _g:push(Array.new());
  end;
  self.adjacentFaces = _g;
  local _g = 0;
  local _g1 = self.faces.length;
  while (_g < _g1) do 
    _g = _g + 1;
    local i = _g - 1;
    self.adjacentFaces[self.faces[i][0]]:push(i);
    self.adjacentFaces[self.faces[i][1]]:push(i);
    self.adjacentFaces[self.faces[i][2]]:push(i);
  end;
end
__apparentridges_Mesh.prototype.getFaceEdges = function(self,f) 
  local this1 = ({length = 3});
  local e = this1;
  local this1 = self.vertices[f[2]];
  local rhs = self.vertices[f[1]];
  local this2 = ({length = 3});
  local this2 = this2;
  this2[0] = this1[0] - rhs[0];
  this2[1] = this1[1] - rhs[1];
  this2[2] = this1[2] - rhs[2];
  e[0] = this2;
  local this1 = self.vertices[f[0]];
  local rhs = self.vertices[f[2]];
  local this2 = ({length = 3});
  local this2 = this2;
  this2[0] = this1[0] - rhs[0];
  this2[1] = this1[1] - rhs[1];
  this2[2] = this1[2] - rhs[2];
  e[1] = this2;
  local this1 = self.vertices[f[1]];
  local rhs = self.vertices[f[0]];
  local this2 = ({length = 3});
  local this2 = this2;
  this2[0] = this1[0] - rhs[0];
  this2[1] = this1[1] - rhs[1];
  this2[2] = this1[2] - rhs[2];
  e[2] = this2;
  do return e end
end
__apparentridges_Mesh.prototype.computePointAreas = function(self) 
  local nf = self.faces.length;
  local nv = self.vertices.length;
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = nv;
  while (_g1 < _g2) do 
    _g1 = _g1 + 1;
    local i = _g1 - 1;
    _g:push(0);
  end;
  self.pointAreas = _g;
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = nf;
  while (_g1 < _g2) do 
    _g1 = _g1 + 1;
    local i = _g1 - 1;
    local this1 = ({length = 3});
    local this1 = this1;
    this1[0] = 0;
    this1[1] = 0;
    this1[2] = 0;
    _g:push(this1);
  end;
  self.cornerAreas = _g;
  local _g = 0;
  local _g1 = nf;
  while (_g < _g1) do 
    _g = _g + 1;
    local i = _g - 1;
    local e = self:getFaceEdges(self.faces[i]);
    local v1 = e[0];
    local v2 = e[1];
    local this1 = ({length = 3});
    local this1 = this1;
    this1[0] = (v1[1] * v2[2]) - (v1[2] * v2[1]);
    this1[1] = (v1[2] * v2[0]) - (v1[0] * v2[2]);
    this1[2] = (v1[0] * v2[1]) - (v1[1] * v2[0]);
    local this1 = this1;
    local area = 0.5 * _G.math.sqrt(((this1[0] * this1[0]) + (this1[1] * this1[1])) + (this1[2] * this1[2]));
    local this1 = e[0];
    local l2_0 = ((this1[0] * this1[0]) + (this1[1] * this1[1])) + (this1[2] * this1[2]);
    local this1 = e[1];
    local l2_1 = ((this1[0] * this1[0]) + (this1[1] * this1[1])) + (this1[2] * this1[2]);
    local this1 = e[2];
    local l2_2 = ((this1[0] * this1[0]) + (this1[1] * this1[1])) + (this1[2] * this1[2]);
    local bcw_0 = l2_0 * ((l2_1 + l2_2) - l2_0);
    local bcw_1 = l2_1 * ((l2_2 + l2_0) - l2_1);
    local bcw_2 = l2_2 * ((l2_0 + l2_1) - l2_2);
    if (bcw_0 <= 0) then 
      local v1 = e[0];
      local v2 = e[2];
      local v = ((-0.25 * l2_2) * area) / (((v1[0] * v2[0]) + (v1[1] * v2[1])) + (v1[2] * v2[2]));
      self.cornerAreas[i][1] = v;
      local v1 = e[0];
      local v2 = e[1];
      local v = ((-0.25 * l2_1) * area) / (((v1[0] * v2[0]) + (v1[1] * v2[1])) + (v1[2] * v2[2]));
      self.cornerAreas[i][2] = v;
      local v = (area - self.cornerAreas[i][1]) - self.cornerAreas[i][2];
      self.cornerAreas[i][0] = v;
    else
      if (bcw_1 <= 0.0) then 
        local v1 = e[1];
        local v2 = e[0];
        local v = ((-0.25 * l2_0) * area) / (((v1[0] * v2[0]) + (v1[1] * v2[1])) + (v1[2] * v2[2]));
        self.cornerAreas[i][2] = v;
        local v1 = e[1];
        local v2 = e[2];
        local v = ((-0.25 * l2_2) * area) / (((v1[0] * v2[0]) + (v1[1] * v2[1])) + (v1[2] * v2[2]));
        self.cornerAreas[i][0] = v;
        local v = (area - self.cornerAreas[i][2]) - self.cornerAreas[i][0];
        self.cornerAreas[i][1] = v;
      else
        if (bcw_2 <= 0.0) then 
          local v1 = e[2];
          local v2 = e[1];
          local v = ((-0.25 * l2_1) * area) / (((v1[0] * v2[0]) + (v1[1] * v2[1])) + (v1[2] * v2[2]));
          self.cornerAreas[i][0] = v;
          local v1 = e[2];
          local v2 = e[0];
          local v = ((-0.25 * l2_0) * area) / (((v1[0] * v2[0]) + (v1[1] * v2[1])) + (v1[2] * v2[2]));
          self.cornerAreas[i][1] = v;
          local v = (area - self.cornerAreas[i][0]) - self.cornerAreas[i][1];
          self.cornerAreas[i][2] = v;
        else
          local scale = (0.5 * area) / ((bcw_0 + bcw_1) + bcw_2);
          local v = scale * (bcw_1 + bcw_2);
          self.cornerAreas[i][0] = v;
          local v = scale * (bcw_2 + bcw_0);
          self.cornerAreas[i][1] = v;
          local v = scale * (bcw_0 + bcw_1);
          self.cornerAreas[i][2] = v;
        end;
      end;
    end;
    local tmp = self.pointAreas;
    local tmp1 = self.faces[i][0];
    tmp[tmp1] = tmp[tmp1] + self.cornerAreas[i][0];
    local tmp = self.pointAreas;
    local tmp1 = self.faces[i][1];
    tmp[tmp1] = tmp[tmp1] + self.cornerAreas[i][1];
    local tmp = self.pointAreas;
    local tmp1 = self.faces[i][2];
    tmp[tmp1] = tmp[tmp1] + self.cornerAreas[i][2];
  end;
end
__apparentridges_Mesh.prototype.computeCurvatures = function(self) 
  local nv = self.vertices.length;
  local nf = self.faces.length;
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = nv;
  while (_g1 < _g2) do 
    _g1 = _g1 + 1;
    local i = _g1 - 1;
    _g:push(0);
  end;
  self.curv1 = _g;
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = nv;
  while (_g1 < _g2) do 
    _g1 = _g1 + 1;
    local i = _g1 - 1;
    _g:push(0);
  end;
  self.curv2 = _g;
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = nv;
  while (_g1 < _g2) do 
    _g1 = _g1 + 1;
    local i = _g1 - 1;
    local this1 = ({length = 3});
    local this1 = this1;
    this1[0] = 0;
    this1[1] = 0;
    this1[2] = 0;
    _g:push(this1);
  end;
  self.pdir1 = _g;
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = nv;
  while (_g1 < _g2) do 
    _g1 = _g1 + 1;
    local i = _g1 - 1;
    local this1 = ({length = 3});
    local this1 = this1;
    this1[0] = 0;
    this1[1] = 0;
    this1[2] = 0;
    _g:push(this1);
  end;
  self.pdir2 = _g;
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = nv;
  while (_g1 < _g2) do 
    _g1 = _g1 + 1;
    local i = _g1 - 1;
    _g:push(0);
  end;
  local curv12 = _g;
  local _g = 0;
  local _g1 = nf;
  while (_g < _g1) do 
    _g = _g + 1;
    local i = _g - 1;
    local tmp = self.pdir1;
    local tmp1 = self.faces[i][0];
    local this1 = self.vertices[self.faces[i][1]];
    local rhs = self.vertices[self.faces[i][0]];
    local this2 = ({length = 3});
    local this2 = this2;
    this2[0] = this1[0] - rhs[0];
    this2[1] = this1[1] - rhs[1];
    this2[2] = this1[2] - rhs[2];
    tmp[tmp1] = this2;
    local tmp = self.pdir1;
    local tmp1 = self.faces[i][1];
    local this1 = self.vertices[self.faces[i][2]];
    local rhs = self.vertices[self.faces[i][1]];
    local this2 = ({length = 3});
    local this2 = this2;
    this2[0] = this1[0] - rhs[0];
    this2[1] = this1[1] - rhs[1];
    this2[2] = this1[2] - rhs[2];
    tmp[tmp1] = this2;
    local tmp = self.pdir1;
    local tmp1 = self.faces[i][2];
    local this1 = self.vertices[self.faces[i][0]];
    local rhs = self.vertices[self.faces[i][2]];
    local this2 = ({length = 3});
    local this2 = this2;
    this2[0] = this1[0] - rhs[0];
    this2[1] = this1[1] - rhs[1];
    this2[2] = this1[2] - rhs[2];
    tmp[tmp1] = this2;
  end;
  local _g = 0;
  local _g1 = nv;
  while (_g < _g1) do 
    _g = _g + 1;
    local i = _g - 1;
    local tmp = self.pdir1;
    local v1 = self.pdir1[i];
    local v2 = self.normals[i];
    local this1 = ({length = 3});
    local this1 = this1;
    this1[0] = (v1[1] * v2[2]) - (v1[2] * v2[1]);
    this1[1] = (v1[2] * v2[0]) - (v1[0] * v2[2]);
    this1[2] = (v1[0] * v2[1]) - (v1[1] * v2[0]);
    tmp[i] = this1;
    local this1 = self.pdir1[i];
    local l = _G.math.sqrt(((this1[0] * this1[0]) + (this1[1] * this1[1])) + (this1[2] * this1[2]));
    if (l > 0) then 
      l = 1 / l;
      local _g = this1;
      _g[0] = _g[0] * l;
      local _g = this1;
      _g[1] = _g[1] * l;
      local _g = this1;
      _g[2] = _g[2] * l;
    else
      this1[0] = 0;
      this1[1] = 0;
      this1[2] = 1;
    end;
    local tmp = self.pdir2;
    local v1 = self.normals[i];
    local v2 = self.pdir1[i];
    local this1 = ({length = 3});
    local this1 = this1;
    this1[0] = (v1[1] * v2[2]) - (v1[2] * v2[1]);
    this1[1] = (v1[2] * v2[0]) - (v1[0] * v2[2]);
    this1[2] = (v1[0] * v2[1]) - (v1[1] * v2[0]);
    tmp[i] = this1;
  end;
  local _g = 0;
  local _g1 = nf;
  local _hx_continue_1 = false;
  while (_g < _g1) do repeat 
    _g = _g + 1;
    local i = _g - 1;
    local f = self.faces[i];
    local e = self:getFaceEdges(f);
    local this1 = e[0];
    local this2 = ({length = 3});
    local this2 = this2;
    this2[0] = this1[0];
    this2[1] = this1[1];
    this2[2] = this1[2];
    local t = this2;
    local l = _G.math.sqrt(((t[0] * t[0]) + (t[1] * t[1])) + (t[2] * t[2]));
    if (l > 0) then 
      l = 1 / l;
      local _g = t;
      _g[0] = _g[0] * l;
      local _g = t;
      _g[1] = _g[1] * l;
      local _g = t;
      _g[2] = _g[2] * l;
    else
      t[0] = 0;
      t[1] = 0;
      t[2] = 1;
    end;
    local v1 = e[0];
    local v2 = e[1];
    local this1 = ({length = 3});
    local this1 = this1;
    this1[0] = (v1[1] * v2[2]) - (v1[2] * v2[1]);
    this1[1] = (v1[2] * v2[0]) - (v1[0] * v2[2]);
    this1[2] = (v1[0] * v2[1]) - (v1[1] * v2[0]);
    local n = this1;
    local this1 = ({length = 3});
    local this1 = this1;
    this1[0] = (n[1] * t[2]) - (n[2] * t[1]);
    this1[1] = (n[2] * t[0]) - (n[0] * t[2]);
    this1[2] = (n[0] * t[1]) - (n[1] * t[0]);
    local b = this1;
    local l = _G.math.sqrt(((b[0] * b[0]) + (b[1] * b[1])) + (b[2] * b[2]));
    if (l > 0) then 
      l = 1 / l;
      local _g = b;
      _g[0] = _g[0] * l;
      local _g = b;
      _g[1] = _g[1] * l;
      local _g = b;
      _g[2] = _g[2] * l;
    else
      b[0] = 0;
      b[1] = 0;
      b[2] = 1;
    end;
    local m = _hx_tab_array({[0]=0, 0, 0}, 3);
    local w = _hx_tab_array({[0]=_hx_tab_array({[0]=0, 0, 0}, 3), _hx_tab_array({[0]=0, 0, 0}, 3), _hx_tab_array({[0]=0, 0, 0}, 3)}, 3);
    local _g = 0;
    while (_g < 3) do 
      _g = _g + 1;
      local j = _g - 1;
      local v1 = e[j];
      local u = ((v1[0] * t[0]) + (v1[1] * t[1])) + (v1[2] * t[2]);
      local v1 = e[j];
      local v = ((v1[0] * b[0]) + (v1[1] * b[1])) + (v1[2] * b[2]);
      local w1 = w[0];
      local tmp = 0;
      w1[tmp] = w1[tmp] + (u * u);
      local w1 = w[0];
      local tmp = 1;
      w1[tmp] = w1[tmp] + (u * v);
      local w = w[2];
      local tmp = 2;
      w[tmp] = w[tmp] + (v * v);
      local this1 = self.normals[f[(function() 
        local _hx_1
        if (j > 0) then 
        _hx_1 = j - 1; else 
        _hx_1 = j + 2; end
        return _hx_1
      end )()]];
      local rhs = self.normals[f[(function() 
        local _hx_2
        if (j < 2) then 
        _hx_2 = j + 1; else 
        _hx_2 = j - 2; end
        return _hx_2
      end )()]];
      local this2 = ({length = 3});
      local this2 = this2;
      this2[0] = this1[0] - rhs[0];
      this2[1] = this1[1] - rhs[1];
      this2[2] = this1[2] - rhs[2];
      local dn = this2;
      local dnu = ((dn[0] * t[0]) + (dn[1] * t[1])) + (dn[2] * t[2]);
      local dnv = ((dn[0] * b[0]) + (dn[1] * b[1])) + (dn[2] * b[2]);
      local m1 = m;
      local tmp = 0;
      m1[tmp] = m1[tmp] + (dnu * u);
      local m1 = m;
      local tmp = 1;
      m1[tmp] = m1[tmp] + ((dnu * v) + (dnv * u));
      local m = m;
      local tmp = 2;
      m[tmp] = m[tmp] + (dnv * v);
    end;
    w[1][1] = w[0][0] + w[2][2];
    w[1][2] = w[0][1];
    local diag = _hx_tab_array({[0]=0, 0, 0}, 3);
    if (not __apparentridges_Util.ldltdc(w, diag)) then 
      break;
    end;
    __apparentridges_Util.ldltsl(w, diag, m, m);
    local vj = f[0];
    local ccc = __apparentridges_Mesh.projCurv(t, b, m[0], m[1], m[2], self.pdir1[vj], self.pdir2[vj]);
    local c1 = ccc[0];
    local c12 = ccc[1];
    local c2 = ccc[2];
    local wt = self.cornerAreas[i][0] / self.pointAreas[vj];
    local tmp = self.curv1;
    local vj1 = vj;
    tmp[vj1] = tmp[vj1] + (wt * c1);
    local curv121 = curv12;
    local vj1 = vj;
    curv121[vj1] = curv121[vj1] + (wt * c12);
    local tmp = self.curv2;
    local vj = vj;
    tmp[vj] = tmp[vj] + (wt * c2);
    local vj = f[1];
    local ccc = __apparentridges_Mesh.projCurv(t, b, m[0], m[1], m[2], self.pdir1[vj], self.pdir2[vj]);
    local c1 = ccc[0];
    local c12 = ccc[1];
    local c2 = ccc[2];
    local wt = self.cornerAreas[i][1] / self.pointAreas[vj];
    local tmp = self.curv1;
    local vj1 = vj;
    tmp[vj1] = tmp[vj1] + (wt * c1);
    local curv121 = curv12;
    local vj1 = vj;
    curv121[vj1] = curv121[vj1] + (wt * c12);
    local tmp = self.curv2;
    local vj = vj;
    tmp[vj] = tmp[vj] + (wt * c2);
    local vj = f[2];
    local ccc = __apparentridges_Mesh.projCurv(t, b, m[0], m[1], m[2], self.pdir1[vj], self.pdir2[vj]);
    local c1 = ccc[0];
    local c12 = ccc[1];
    local c2 = ccc[2];
    local wt = self.cornerAreas[i][2] / self.pointAreas[vj];
    local tmp = self.curv1;
    local vj1 = vj;
    tmp[vj1] = tmp[vj1] + (wt * c1);
    local curv12 = curv12;
    local vj1 = vj;
    curv12[vj1] = curv12[vj1] + (wt * c12);
    local tmp = self.curv2;
    local vj = vj;
    tmp[vj] = tmp[vj] + (wt * c2);until true
    if _hx_continue_1 then 
    _hx_continue_1 = false;
    break;
    end;
    
  end;
  local _g = 0;
  local _g1 = nv;
  while (_g < _g1) do 
    _g = _g + 1;
    local i = _g - 1;
    local this1 = ({length = 3});
    local this1 = this1;
    this1[0] = 0;
    this1[1] = 0;
    this1[2] = 0;
    local c1c2 = this1;
    __apparentridges_Mesh.diagonalizeCurv(self.pdir1[i], self.pdir2[i], self.curv1[i], curv12[i], self.curv2[i], self.normals[i], self.pdir1[i], self.pdir2[i], c1c2);
    self.curv1[i] = c1c2[0];
    self.curv2[i] = c1c2[1];
  end;
end
__apparentridges_Mesh.prototype.computeVertViewDepCurv = function(self,i,ndotv,u2,uv,v2) 
  local sectheta_minus1 = (1.0 / _G.math.abs(ndotv)) - 1.0;
  local Q11 = self.curv1[i] * (1.0 + (sectheta_minus1 * u2));
  local Q12 = self.curv1[i] * (sectheta_minus1 * uv);
  local Q21 = self.curv2[i] * (sectheta_minus1 * uv);
  local Q22 = self.curv2[i] * (1.0 + (sectheta_minus1 * v2));
  local QTQ1 = (Q11 * Q11) + (Q21 * Q21);
  local QTQ12 = (Q11 * Q12) + (Q21 * Q22);
  local QTQ2 = (Q12 * Q12) + (Q22 * Q22);
  do return __apparentridges_Util.largestEig2x2(QTQ1, QTQ12, QTQ2) end
end
__apparentridges_Mesh.prototype.computeVertDt1q1 = function(self,i,ndotv,t1q1) 
  local v0 = self.vertices[i];
  local this_viewdep_curv = t1q1[i][2];
  local this1 = self.pdir1[i];
  local rhs = t1q1[i][0];
  local this2 = ({length = 3});
  local this2 = this2;
  this2[0] = this1[0] * rhs;
  this2[1] = this1[1] * rhs;
  this2[2] = this1[2] * rhs;
  local this1 = this2;
  local this2 = self.pdir2[i];
  local rhs = t1q1[i][1];
  local this3 = ({length = 3});
  local this3 = this3;
  this3[0] = this2[0] * rhs;
  this3[1] = this2[1] * rhs;
  this3[2] = this2[2] * rhs;
  local rhs = this3;
  local this2 = ({length = 3});
  local this2 = this2;
  this2[0] = this1[0] + rhs[0];
  this2[1] = this1[1] + rhs[1];
  this2[2] = this1[2] + rhs[2];
  local world_t1 = this2;
  local v1 = self.normals[i];
  local this1 = ({length = 3});
  local this1 = this1;
  this1[0] = (v1[1] * world_t1[2]) - (v1[2] * world_t1[1]);
  this1[1] = (v1[2] * world_t1[0]) - (v1[0] * world_t1[2]);
  this1[2] = (v1[0] * world_t1[1]) - (v1[1] * world_t1[0]);
  local world_t2 = this1;
  local v0_dot_t2 = ((v0[0] * world_t2[0]) + (v0[1] * world_t2[1])) + (v0[2] * world_t2[2]);
  local Dt1q1 = 0.0;
  local n = 0;
  local naf = self.adjacentFaces[i].length;
  local _g = 0;
  local _g1 = naf;
  local _hx_continue_1 = false;
  while (_g < _g1) do repeat 
    _g = _g + 1;
    local j = _g - 1;
    local f = self.adjacentFaces[i][j];
    local this1 = self.faces[f];
    local ind = (function() 
      local _hx_1
      if (this1[0] == i) then 
      _hx_1 = 0; elseif (this1[1] == i) then 
      _hx_1 = 1; elseif (this1[2] == i) then 
      _hx_1 = 2; else 
      _hx_1 = -1; end
      return _hx_1
    end )();
    local i1 = self.faces[f][(function() 
      local _hx_2
      if (ind < 2) then 
      _hx_2 = ind + 1; else 
      _hx_2 = ind - 2; end
      return _hx_2
    end )()];
    local i2 = self.faces[f][(function() 
      local _hx_3
      if (ind > 0) then 
      _hx_3 = ind - 1; else 
      _hx_3 = ind + 2; end
      return _hx_3
    end )()];
    local v1 = self.vertices[i1];
    local v2 = self.vertices[i2];
    local v1_dot_t2 = ((v1[0] * world_t2[0]) + (v1[1] * world_t2[1])) + (v1[2] * world_t2[2]);
    local v2_dot_t2 = ((v2[0] * world_t2[0]) + (v2[1] * world_t2[1])) + (v2[2] * world_t2[2]);
    local w1 = (v2_dot_t2 - v0_dot_t2) / (v2_dot_t2 - v1_dot_t2);
    if ((w1 < 0.0) or (w1 >= 1.0)) then 
      break;
    end;
    local w2 = 1.0 - w1;
    local this1 = ({length = 3});
    local this1 = this1;
    this1[0] = v1[0] * w1;
    this1[1] = v1[1] * w1;
    this1[2] = v1[2] * w1;
    local this1 = this1;
    local this2 = ({length = 3});
    local this2 = this2;
    this2[0] = v2[0] * w2;
    this2[1] = v2[1] * w2;
    this2[2] = v2[2] * w2;
    local rhs = this2;
    local this2 = ({length = 3});
    local this2 = this2;
    this2[0] = this1[0] + rhs[0];
    this2[1] = this1[1] + rhs[1];
    this2[2] = this1[2] + rhs[2];
    local p = this2;
    local interp_viewdep_curv = (w1 * t1q1[i1][2]) + (w2 * t1q1[i2][2]);
    local this1 = ({length = 3});
    local this1 = this1;
    this1[0] = p[0] - v0[0];
    this1[1] = p[1] - v0[1];
    this1[2] = p[2] - v0[2];
    local v1 = this1;
    local proj_dist = ((v1[0] * world_t1[0]) + (v1[1] * world_t1[1])) + (v1[2] * world_t1[2]);
    proj_dist = proj_dist * _G.math.abs(ndotv);
    Dt1q1 = Dt1q1 + ((interp_viewdep_curv - this_viewdep_curv) / proj_dist);
    n = n + 1;
    if (n == 2) then 
      Dt1q1 = Dt1q1 * 0.5;
      do return Dt1q1 end;
    end;until true
    if _hx_continue_1 then 
    _hx_continue_1 = false;
    break;
    end;
    
  end;
  do return Dt1q1 end
end
__apparentridges_Mesh.prototype.segmentApparentRidge = function(self,v0,v1,v2,emax0,emax1,emax2,kmax0,kmax1,kmax2,tmax0,tmax1,tmax2,thresh,to_center,do_test) 
  local w10 = _G.math.abs(emax0) / (_G.math.abs(emax0) + _G.math.abs(emax1));
  local w01 = 1.0 - w10;
  local this1 = self.vertices[v0];
  local this2 = ({length = 3});
  local this2 = this2;
  this2[0] = this1[0] * w01;
  this2[1] = this1[1] * w01;
  this2[2] = this1[2] * w01;
  local this1 = this2;
  local this2 = self.vertices[v1];
  local this3 = ({length = 3});
  local this3 = this3;
  this3[0] = this2[0] * w10;
  this3[1] = this2[1] * w10;
  this3[2] = this2[2] * w10;
  local rhs = this3;
  local this2 = ({length = 3});
  local this2 = this2;
  this2[0] = this1[0] + rhs[0];
  this2[1] = this1[1] + rhs[1];
  this2[2] = this1[2] + rhs[2];
  local p01 = this2;
  local k01 = _G.math.abs((w01 * kmax0) + (w10 * kmax1));
  local p12;
  local k12;
  if (to_center) then 
    local this1 = self.vertices[v0];
    local rhs = self.vertices[v1];
    local this2 = ({length = 3});
    local this2 = this2;
    this2[0] = this1[0] + rhs[0];
    this2[1] = this1[1] + rhs[1];
    this2[2] = this1[2] + rhs[2];
    local this1 = this2;
    local rhs = self.vertices[v2];
    local this2 = ({length = 3});
    local this2 = this2;
    this2[0] = this1[0] + rhs[0];
    this2[1] = this1[1] + rhs[1];
    this2[2] = this1[2] + rhs[2];
    local this1 = this2;
    local this2 = ({length = 3});
    local this2 = this2;
    this2[0] = this1[0] * 0.333333333333333315;
    this2[1] = this1[1] * 0.333333333333333315;
    this2[2] = this1[2] * 0.333333333333333315;
    p12 = this2;
    k12 = _G.math.abs((kmax0 + kmax1) + kmax2) / 3.0;
  else
    local w21 = _G.math.abs(emax1) / (_G.math.abs(emax1) + _G.math.abs(emax2));
    local w12 = 1.0 - w21;
    local this1 = self.vertices[v1];
    local this2 = ({length = 3});
    local this2 = this2;
    this2[0] = this1[0] * w12;
    this2[1] = this1[1] * w12;
    this2[2] = this1[2] * w12;
    local this1 = this2;
    local this2 = self.vertices[v2];
    local this3 = ({length = 3});
    local this3 = this3;
    this3[0] = this2[0] * w21;
    this3[1] = this2[1] * w21;
    this3[2] = this2[2] * w21;
    local rhs = this3;
    local this2 = ({length = 3});
    local this2 = this2;
    this2[0] = this1[0] + rhs[0];
    this2[1] = this1[1] + rhs[1];
    this2[2] = this1[2] + rhs[2];
    p12 = this2;
    k12 = _G.math.abs((w12 * kmax1) + (w21 * kmax2));
  end;
  k01 = k01 - thresh;
  if (k01 < 0.0) then 
    k01 = 0.0;
  end;
  k12 = k12 - thresh;
  if (k12 < 0.0) then 
    k12 = 0.0;
  end;
  if ((k01 == 0.0) and (k12 == 0.0)) then 
    do return nil end;
  end;
  if (do_test) then 
    local v0 = self.vertices[v0];
    local v1 = self.vertices[v1];
    local v2 = self.vertices[v2];
    local this1 = ({length = 3});
    local this1 = this1;
    this1[0] = v1[0] - v0[0];
    this1[1] = v1[1] - v0[1];
    this1[2] = v1[2] - v0[2];
    local v1 = this1;
    local this1 = ({length = 3});
    local this1 = this1;
    this1[0] = v2[0] - v0[0];
    this1[1] = v2[1] - v0[1];
    this1[2] = v2[2] - v0[2];
    local v2 = this1;
    local this1 = ({length = 3});
    local this1 = this1;
    this1[0] = (v1[1] * v2[2]) - (v1[2] * v2[1]);
    this1[1] = (v1[2] * v2[0]) - (v1[0] * v2[2]);
    this1[2] = (v1[0] * v2[1]) - (v1[1] * v2[0]);
    local this1 = this1;
    local this2 = ({length = 3});
    local this2 = this2;
    this2[0] = this1[0] * 0.5;
    this2[1] = this1[1] * 0.5;
    this2[2] = this1[2] * 0.5;
    local v1 = this2;
    local this1 = ({length = 3});
    local this1 = this1;
    this1[0] = p01[0] - p12[0];
    this1[1] = p01[1] - p12[1];
    this1[2] = p01[2] - p12[2];
    local v2 = this1;
    local this1 = ({length = 3});
    local this1 = this1;
    this1[0] = (v1[1] * v2[2]) - (v1[2] * v2[1]);
    this1[1] = (v1[2] * v2[0]) - (v1[0] * v2[2]);
    this1[2] = (v1[0] * v2[1]) - (v1[1] * v2[0]);
    local perp = this1;
    if ((((((tmax0[0] * perp[0]) + (tmax0[1] * perp[1])) + (tmax0[2] * perp[2])) <= 0.0) or ((((tmax1[0] * perp[0]) + (tmax1[1] * perp[1])) + (tmax1[2] * perp[2])) >= 0.0)) or ((((tmax2[0] * perp[0]) + (tmax2[1] * perp[1])) + (tmax2[2] * perp[2])) <= 0.0)) then 
      do return nil end;
    end;
  end;
  k01 = k01 / (k01 + thresh);
  k12 = k12 / (k12 + thresh);
  do return __apparentridges_Ridge.new(p01, k01, p12, k12) end
end
__apparentridges_Mesh.prototype.facesApparentRidges = function(self,ndotv,t1q1,Dt1q1,do_bfcull,do_test,thresh) 
  local ridges = _hx_tab_array({}, 0);
  local _g = 0;
  local _g1 = self.faces;
  local _hx_continue_1 = false;
  while (_g < _g1.length) do repeat 
    local f = _g1[_g];
    _g = _g + 1;
    local v0 = f[0];
    local v1 = f[1];
    local v2 = f[2];
    if (((do_bfcull and (ndotv[v0] <= 0)) and (ndotv[v1] <= 0)) and (ndotv[v2] <= 0)) then 
      break;
    end;
    local kmax0 = t1q1[v0][2];
    local kmax1 = t1q1[v1][2];
    local kmax2 = t1q1[v2][2];
    if (((kmax0 <= thresh) and (kmax1 <= thresh)) and (kmax2 <= thresh)) then 
      break;
    end;
    local emax0 = Dt1q1[v0];
    local emax1 = Dt1q1[v1];
    local emax2 = Dt1q1[v2];
    local this1 = self.pdir1[v0];
    local rhs = t1q1[v0][0];
    local this2 = ({length = 3});
    local this2 = this2;
    this2[0] = this1[0] * rhs;
    this2[1] = this1[1] * rhs;
    this2[2] = this1[2] * rhs;
    local this1 = this2;
    local this2 = self.pdir2[v0];
    local rhs = t1q1[v0][1];
    local this3 = ({length = 3});
    local this3 = this3;
    this3[0] = this2[0] * rhs;
    this3[1] = this2[1] * rhs;
    this3[2] = this2[2] * rhs;
    local rhs = this3;
    local this2 = ({length = 3});
    local this2 = this2;
    this2[0] = this1[0] + rhs[0];
    this2[1] = this1[1] + rhs[1];
    this2[2] = this1[2] + rhs[2];
    local world_t1_0 = this2;
    local this1 = self.pdir1[v1];
    local rhs = t1q1[v1][0];
    local this2 = ({length = 3});
    local this2 = this2;
    this2[0] = this1[0] * rhs;
    this2[1] = this1[1] * rhs;
    this2[2] = this1[2] * rhs;
    local this1 = this2;
    local this2 = self.pdir2[v1];
    local rhs = t1q1[v1][1];
    local this3 = ({length = 3});
    local this3 = this3;
    this3[0] = this2[0] * rhs;
    this3[1] = this2[1] * rhs;
    this3[2] = this2[2] * rhs;
    local rhs = this3;
    local this2 = ({length = 3});
    local this2 = this2;
    this2[0] = this1[0] + rhs[0];
    this2[1] = this1[1] + rhs[1];
    this2[2] = this1[2] + rhs[2];
    local world_t1_1 = this2;
    local this1 = self.pdir1[v2];
    local rhs = t1q1[v2][0];
    local this2 = ({length = 3});
    local this2 = this2;
    this2[0] = this1[0] * rhs;
    this2[1] = this1[1] * rhs;
    this2[2] = this1[2] * rhs;
    local this1 = this2;
    local this2 = self.pdir2[v2];
    local rhs = t1q1[v2][1];
    local this3 = ({length = 3});
    local this3 = this3;
    this3[0] = this2[0] * rhs;
    this3[1] = this2[1] * rhs;
    this3[2] = this2[2] * rhs;
    local rhs = this3;
    local this2 = ({length = 3});
    local this2 = this2;
    this2[0] = this1[0] + rhs[0];
    this2[1] = this1[1] + rhs[1];
    this2[2] = this1[2] + rhs[2];
    local world_t1_2 = this2;
    local rhs = Dt1q1[v0];
    local this1 = ({length = 3});
    local this1 = this1;
    this1[0] = world_t1_0[0] * rhs;
    this1[1] = world_t1_0[1] * rhs;
    this1[2] = world_t1_0[2] * rhs;
    local tmax0 = this1;
    local rhs = Dt1q1[v1];
    local this1 = ({length = 3});
    local this1 = this1;
    this1[0] = world_t1_1[0] * rhs;
    this1[1] = world_t1_1[1] * rhs;
    this1[2] = world_t1_1[2] * rhs;
    local tmax1 = this1;
    local rhs = Dt1q1[v2];
    local this1 = ({length = 3});
    local this1 = this1;
    this1[0] = world_t1_2[0] * rhs;
    this1[1] = world_t1_2[1] * rhs;
    this1[2] = world_t1_2[2] * rhs;
    local tmax2 = this1;
    local z01 = (((tmax0[0] * tmax1[0]) + (tmax0[1] * tmax1[1])) + (tmax0[2] * tmax1[2])) <= 0.0;
    local z12 = (((tmax1[0] * tmax2[0]) + (tmax1[1] * tmax2[1])) + (tmax1[2] * tmax2[2])) <= 0.0;
    local z20 = (((tmax2[0] * tmax0[0]) + (tmax2[1] * tmax0[1])) + (tmax2[2] * tmax0[2])) <= 0.0;
    if ((((function() 
      local _hx_1
      if (z01) then 
      _hx_1 = 1; else 
      _hx_1 = 0; end
      return _hx_1
    end )() + (function() 
      local _hx_2
      if (z12) then 
      _hx_2 = 1; else 
      _hx_2 = 0; end
      return _hx_2
    end )()) + (function() 
      local _hx_3
      if (z20) then 
      _hx_3 = 1; else 
      _hx_3 = 0; end
      return _hx_3
    end )()) < 2) then 
      break;
    end;
    if (not z01) then 
      local r = self:segmentApparentRidge(v1, v2, v0, emax1, emax2, emax0, kmax1, kmax2, kmax0, tmax1, tmax2, tmax0, thresh, false, do_test);
      if (r ~= nil) then 
        ridges:push(r);
      end;
    else
      if (not z12) then 
        local r = self:segmentApparentRidge(v2, v0, v1, emax2, emax0, emax1, kmax2, kmax0, kmax1, tmax2, tmax0, tmax1, thresh, false, do_test);
        if (r ~= nil) then 
          ridges:push(r);
        end;
      else
        if (not z20) then 
          local r = self:segmentApparentRidge(v0, v1, v2, emax0, emax1, emax2, kmax0, kmax1, kmax2, tmax0, tmax1, tmax2, thresh, false, do_test);
          if (r ~= nil) then 
            ridges:push(r);
          end;
        else
          local r0 = self:segmentApparentRidge(v1, v2, v0, emax1, emax2, emax0, kmax1, kmax2, kmax0, tmax1, tmax2, tmax0, thresh, true, do_test);
          local r1 = self:segmentApparentRidge(v2, v0, v1, emax2, emax0, emax1, kmax2, kmax0, kmax1, tmax2, tmax0, tmax1, thresh, true, do_test);
          local r2 = self:segmentApparentRidge(v0, v1, v2, emax0, emax1, emax2, kmax0, kmax1, kmax2, tmax0, tmax1, tmax2, thresh, true, do_test);
          if (r0 ~= nil) then 
            ridges:push(r0);
          end;
          if (r1 ~= nil) then 
            ridges:push(r1);
          end;
          if (r2 ~= nil) then 
            ridges:push(r2);
          end;
        end;
      end;
    end;until true
    if _hx_continue_1 then 
    _hx_continue_1 = false;
    break;
    end;
    
  end;
  do return ridges end
end
__apparentridges_Mesh.prototype.apparentRidges = function(self,eye,thresh) 
  local nv = self.vertices.length;
  local _g = 0;
  local _g1 = nv;
  while (_g < _g1) do 
    _g = _g + 1;
    local i = _g - 1;
    local rhs = self.vertices[i];
    local this1 = ({length = 3});
    local this1 = this1;
    this1[0] = eye[0] - rhs[0];
    this1[1] = eye[1] - rhs[1];
    this1[2] = eye[2] - rhs[2];
    local viewdir = this1;
    local rlv = 1.0 / _G.math.sqrt(((viewdir[0] * viewdir[0]) + (viewdir[1] * viewdir[1])) + (viewdir[2] * viewdir[2]));
    local this1 = ({length = 3});
    local this1 = this1;
    this1[0] = viewdir[0] * rlv;
    this1[1] = viewdir[1] * rlv;
    this1[2] = viewdir[2] * rlv;
    viewdir = this1;
    local v2 = self.normals[i];
    self.ndotv[i] = ((viewdir[0] * v2[0]) + (viewdir[1] * v2[1])) + (viewdir[2] * v2[2]);
    local v2 = self.pdir1[i];
    local u = ((viewdir[0] * v2[0]) + (viewdir[1] * v2[1])) + (viewdir[2] * v2[2]);
    local u2 = u * u;
    local v2 = self.pdir2[i];
    local v = ((viewdir[0] * v2[0]) + (viewdir[1] * v2[1])) + (viewdir[2] * v2[2]);
    local v2 = v * v;
    local csc2theta = 1.0 / (u2 + v2);
    self.t1q1[i] = self:computeVertViewDepCurv(i, self.ndotv[i], u2 * csc2theta, (u * v) * csc2theta, v2 * csc2theta);
  end;
  local _g = 0;
  local _g1 = nv;
  while (_g < _g1) do 
    _g = _g + 1;
    local i = _g - 1;
    self.Dt1q1[i] = self:computeVertDt1q1(i, self.ndotv[i], self.t1q1);
  end;
  local x = self.featureSize;
  do return self:facesApparentRidges(self.ndotv, self.t1q1, self.Dt1q1, false, true, thresh / (x * x)) end
end
__apparentridges_Mesh.prototype.computeBVHTrivial = function(self) 
  self.bvh = __apparentridges_BVHTree.new(self, self.faces.length);
  self.bvh:build();
end
__apparentridges_Mesh.prototype.computeBVH = function(self) 
  self.bvh = __apparentridges_BVHTree.new(self);
  self.bvh:build();
end
__apparentridges_Mesh.prototype.visible = function(self,eye,p,tolerance) 
  if (tolerance == nil) then 
    tolerance = 2;
  end;
  local epsilon = (self.bsphere.r / _G.math.sqrt(self.faces.length)) * tolerance;
  local r_tmin;
  local r_tmax;
  local r_o;
  local r_d;
  local this1 = ({length = 3});
  local this1 = this1;
  this1[0] = p[0] - eye[0];
  this1[1] = p[1] - eye[1];
  this1[2] = p[2] - eye[2];
  local x = this1;
  local this1 = ({length = 3});
  local this1 = this1;
  this1[0] = x[0];
  this1[1] = x[1];
  this1[2] = x[2];
  r_d = this1;
  local this1 = r_d;
  local l = _G.math.sqrt(((this1[0] * this1[0]) + (this1[1] * this1[1])) + (this1[2] * this1[2]));
  if (l > 0) then 
    l = 1 / l;
    local _g = this1;
    _g[0] = _g[0] * l;
    local _g = this1;
    _g[1] = _g[1] * l;
    local _g = this1;
    _g[2] = _g[2] * l;
  else
    this1[0] = 0;
    this1[1] = 0;
    this1[2] = 1;
  end;
  r_o = eye;
  r_tmin = 0;
  r_tmax = _G.math.sqrt(((x[0] * x[0]) + (x[1] * x[1])) + (x[2] * x[2])) - epsilon;
  local bvh = self.bvh;
  local hitNode = nil;
  hitNode = function(node) 
    if ((node.left == nil) and (node.right == nil)) then 
      local tmin = _G.math.huge;
      local closest = nil;
      local _g = node.begin;
      local _g1 = node["end"];
      while (_g < _g1) do 
        _g = _g + 1;
        local i = _g - 1;
        local p0 = bvh.mesh.vertices[bvh.faces[i][0]];
        local p1 = bvh.mesh.vertices[bvh.faces[i][1]];
        local p2 = bvh.mesh.vertices[bvh.faces[i][2]];
        local this1 = ({length = 3});
        local this1 = this1;
        this1[0] = p1[0] - p0[0];
        this1[1] = p1[1] - p0[1];
        this1[2] = p1[2] - p0[2];
        local e1 = this1;
        local this1 = ({length = 3});
        local this1 = this1;
        this1[0] = p2[0] - p0[0];
        this1[1] = p2[1] - p0[1];
        this1[2] = p2[2] - p0[2];
        local e2 = this1;
        local this1 = r_o;
        local this2 = ({length = 3});
        local this2 = this2;
        this2[0] = this1[0] - p0[0];
        this2[1] = this1[1] - p0[1];
        this2[2] = this1[2] - p0[2];
        local s = this2;
        local this1 = r_d;
        local this2 = ({length = 3});
        local this2 = this2;
        this2[0] = this1[0] * -1.0;
        this2[1] = this1[1] * -1.0;
        this2[2] = this1[2] * -1.0;
        local _d = this2;
        local this1 = ({length = 3});
        local this1 = this1;
        this1[0] = (e1[1] * e2[2]) - (e1[2] * e2[1]);
        this1[1] = (e1[2] * e2[0]) - (e1[0] * e2[2]);
        this1[2] = (e1[0] * e2[1]) - (e1[1] * e2[0]);
        local v1 = this1;
        local denom = ((v1[0] * _d[0]) + (v1[1] * _d[1])) + (v1[2] * _d[2]);
        local h;
        if (denom == 0) then 
          h = nil;
        else
          local this1 = ({length = 3});
          local this1 = this1;
          this1[0] = (s[1] * e2[2]) - (s[2] * e2[1]);
          this1[1] = (s[2] * e2[0]) - (s[0] * e2[2]);
          this1[2] = (s[0] * e2[1]) - (s[1] * e2[0]);
          local v1 = this1;
          local _x = ((v1[0] * _d[0]) + (v1[1] * _d[1])) + (v1[2] * _d[2]);
          local this1 = ({length = 3});
          local this1 = this1;
          this1[0] = (e1[1] * s[2]) - (e1[2] * s[1]);
          this1[1] = (e1[2] * s[0]) - (e1[0] * s[2]);
          this1[2] = (e1[0] * s[1]) - (e1[1] * s[0]);
          local v1 = this1;
          local _y = ((v1[0] * _d[0]) + (v1[1] * _d[1])) + (v1[2] * _d[2]);
          local this1 = ({length = 3});
          local this1 = this1;
          this1[0] = (e1[1] * e2[2]) - (e1[2] * e2[1]);
          this1[1] = (e1[2] * e2[0]) - (e1[0] * e2[2]);
          this1[2] = (e1[0] * e2[1]) - (e1[1] * e2[0]);
          local v1 = this1;
          local _z = ((v1[0] * s[0]) + (v1[1] * s[1])) + (v1[2] * s[2]);
          local this1 = ({length = 3});
          local this1 = this1;
          this1[0] = _x;
          this1[1] = _y;
          this1[2] = _z;
          local this1 = this1;
          local rhs = 1 / denom;
          local this2 = ({length = 3});
          local this2 = this2;
          this2[0] = this1[0] * rhs;
          this2[1] = this1[1] * rhs;
          this2[2] = this1[2] * rhs;
          local uvt = this2;
          local u = uvt[0];
          local v = uvt[1];
          local t = uvt[2];
          if (((((u < 0) or (v < 0)) or (((1 - u) - v) < 0)) or (t < r_tmin)) or (t > r_tmax)) then 
            h = nil;
          else
            local h1 = __apparentridges_RayHit.new(t);
            h1.u = u;
            h1.v = v;
            h = h1;
          end;
        end;
        if (h ~= nil) then 
          h.face = bvh.faces[i];
          if (tmin > h.t) then 
            tmin = h.t;
            closest = h;
          end;
        end;
      end;
      do return closest end;
    end;
    local bb = node.left.bbox;
    local tx1 = (bb.min[0] - r_o[0]) / r_d[0];
    local tx2 = (bb.max[0] - r_o[0]) / r_d[0];
    local ty1 = (bb.min[1] - r_o[1]) / r_d[1];
    local ty2 = (bb.max[1] - r_o[1]) / r_d[1];
    local tz1 = (bb.min[2] - r_o[2]) / r_d[2];
    local tz2 = (bb.max[2] - r_o[2]) / r_d[2];
    local t1 = Math.max(Math.max(Math.min(tx1, tx2), Math.min(ty1, ty2)), Math.min(tz1, tz2));
    local t2 = Math.min(Math.min(Math.max(tx1, tx2), Math.max(ty1, ty2)), Math.max(tz1, tz2));
    local hitL;
    if ((t2 - t1) < 0) then 
      hitL = nil;
    else
      if ((t1 > r_tmax) or (t2 < r_tmin)) then 
        hitL = nil;
      else
        local h = __apparentridges_RayHit.new(t1);
        h.t2 = t2;
        hitL = h;
      end;
    end;
    local bb = node.right.bbox;
    local tx1 = (bb.min[0] - r_o[0]) / r_d[0];
    local tx2 = (bb.max[0] - r_o[0]) / r_d[0];
    local ty1 = (bb.min[1] - r_o[1]) / r_d[1];
    local ty2 = (bb.max[1] - r_o[1]) / r_d[1];
    local tz1 = (bb.min[2] - r_o[2]) / r_d[2];
    local tz2 = (bb.max[2] - r_o[2]) / r_d[2];
    local t1 = Math.max(Math.max(Math.min(tx1, tx2), Math.min(ty1, ty2)), Math.min(tz1, tz2));
    local t2 = Math.min(Math.min(Math.max(tx1, tx2), Math.max(ty1, ty2)), Math.max(tz1, tz2));
    local hitR;
    if ((t2 - t1) < 0) then 
      hitR = nil;
    else
      if ((t1 > r_tmax) or (t2 < r_tmin)) then 
        hitR = nil;
      else
        local h = __apparentridges_RayHit.new(t1);
        h.t2 = t2;
        hitR = h;
      end;
    end;
    if ((hitL ~= nil) and (hitR == nil)) then 
      do return hitNode(node.left) end;
    else
      if ((hitL == nil) and (hitR ~= nil)) then 
        do return hitNode(node.right) end;
      else
        if ((hitL == nil) and (hitR == nil)) then 
          do return nil end;
        end;
      end;
    end;
    local first;
    local second;
    if (hitL.t < hitR.t) then 
      first = node.left;
      second = node.right;
    else
      first = node.right;
      second = node.left;
    end;
    local h = hitNode(first);
    if ((h == nil) or (h.t >= Math.max(hitL.t, hitR.t))) then 
      local h2 = hitNode(second);
      if (h2 ~= nil) then 
        if ((h == nil) or (h2.t < h.t)) then 
          do return h2 end;
        end;
      end;
    end;
    do return h end;
  end;
  local h = hitNode(bvh.root);
  do return h == nil end
end

__apparentridges_Mesh.prototype.__class__ =  __apparentridges_Mesh

__apparentridges_Ray.new = function() 
  local self = _hx_new(__apparentridges_Ray.prototype)
  __apparentridges_Ray.super(self)
  return self
end
__apparentridges_Ray.super = function(self) 
end
_hx_exports["apparentridges"]["Ray"] = __apparentridges_Ray
__apparentridges_Ray.__name__ = true
__apparentridges_Ray.prototype = _hx_e();
__apparentridges_Ray.prototype.hitBBox = function(self,bb) 
  local tx1 = (bb.min[0] - self.o[0]) / self.d[0];
  local tx2 = (bb.max[0] - self.o[0]) / self.d[0];
  local ty1 = (bb.min[1] - self.o[1]) / self.d[1];
  local ty2 = (bb.max[1] - self.o[1]) / self.d[1];
  local tz1 = (bb.min[2] - self.o[2]) / self.d[2];
  local tz2 = (bb.max[2] - self.o[2]) / self.d[2];
  local t1 = Math.max(Math.max(Math.min(tx1, tx2), Math.min(ty1, ty2)), Math.min(tz1, tz2));
  local t2 = Math.min(Math.min(Math.max(tx1, tx2), Math.max(ty1, ty2)), Math.max(tz1, tz2));
  if ((t2 - t1) < 0) then 
    do return nil end;
  end;
  if ((t1 > self.tmax) or (t2 < self.tmin)) then 
    do return nil end;
  end;
  local h = __apparentridges_RayHit.new(t1);
  h.t2 = t2;
  do return h end
end
__apparentridges_Ray.prototype.hitTriangle = function(self,p0,p1,p2) 
  local this1 = ({length = 3});
  local this1 = this1;
  this1[0] = p1[0] - p0[0];
  this1[1] = p1[1] - p0[1];
  this1[2] = p1[2] - p0[2];
  local e1 = this1;
  local this1 = ({length = 3});
  local this1 = this1;
  this1[0] = p2[0] - p0[0];
  this1[1] = p2[1] - p0[1];
  this1[2] = p2[2] - p0[2];
  local e2 = this1;
  local this1 = self.o;
  local this2 = ({length = 3});
  local this2 = this2;
  this2[0] = this1[0] - p0[0];
  this2[1] = this1[1] - p0[1];
  this2[2] = this1[2] - p0[2];
  local s = this2;
  local this1 = self.d;
  local this2 = ({length = 3});
  local this2 = this2;
  this2[0] = this1[0] * -1.0;
  this2[1] = this1[1] * -1.0;
  this2[2] = this1[2] * -1.0;
  local _d = this2;
  local this1 = ({length = 3});
  local this1 = this1;
  this1[0] = (e1[1] * e2[2]) - (e1[2] * e2[1]);
  this1[1] = (e1[2] * e2[0]) - (e1[0] * e2[2]);
  this1[2] = (e1[0] * e2[1]) - (e1[1] * e2[0]);
  local v1 = this1;
  local denom = ((v1[0] * _d[0]) + (v1[1] * _d[1])) + (v1[2] * _d[2]);
  if (denom == 0) then 
    do return nil end;
  end;
  local this1 = ({length = 3});
  local this1 = this1;
  this1[0] = (s[1] * e2[2]) - (s[2] * e2[1]);
  this1[1] = (s[2] * e2[0]) - (s[0] * e2[2]);
  this1[2] = (s[0] * e2[1]) - (s[1] * e2[0]);
  local v1 = this1;
  local _x = ((v1[0] * _d[0]) + (v1[1] * _d[1])) + (v1[2] * _d[2]);
  local this1 = ({length = 3});
  local this1 = this1;
  this1[0] = (e1[1] * s[2]) - (e1[2] * s[1]);
  this1[1] = (e1[2] * s[0]) - (e1[0] * s[2]);
  this1[2] = (e1[0] * s[1]) - (e1[1] * s[0]);
  local v1 = this1;
  local _y = ((v1[0] * _d[0]) + (v1[1] * _d[1])) + (v1[2] * _d[2]);
  local this1 = ({length = 3});
  local this1 = this1;
  this1[0] = (e1[1] * e2[2]) - (e1[2] * e2[1]);
  this1[1] = (e1[2] * e2[0]) - (e1[0] * e2[2]);
  this1[2] = (e1[0] * e2[1]) - (e1[1] * e2[0]);
  local v1 = this1;
  local _z = ((v1[0] * s[0]) + (v1[1] * s[1])) + (v1[2] * s[2]);
  local this1 = ({length = 3});
  local this1 = this1;
  this1[0] = _x;
  this1[1] = _y;
  this1[2] = _z;
  local this1 = this1;
  local rhs = 1 / denom;
  local this2 = ({length = 3});
  local this2 = this2;
  this2[0] = this1[0] * rhs;
  this2[1] = this1[1] * rhs;
  this2[2] = this1[2] * rhs;
  local uvt = this2;
  local u = uvt[0];
  local v = uvt[1];
  local t = uvt[2];
  if (((((u < 0) or (v < 0)) or (((1 - u) - v) < 0)) or (t < self.tmin)) or (t > self.tmax)) then 
    do return nil end;
  end;
  local h = __apparentridges_RayHit.new(t);
  h.u = u;
  h.v = v;
  do return h end
end
__apparentridges_Ray.prototype.hitBVH = function(self,bvh) 
  local _gthis = self;
  local hitNode = nil;
  hitNode = function(node) 
    if ((node.left == nil) and (node.right == nil)) then 
      local tmin = _G.math.huge;
      local closest = nil;
      local _g = node.begin;
      local _g1 = node["end"];
      while (_g < _g1) do 
        _g = _g + 1;
        local i = _g - 1;
        local p0 = bvh.mesh.vertices[bvh.faces[i][0]];
        local p1 = bvh.mesh.vertices[bvh.faces[i][1]];
        local p2 = bvh.mesh.vertices[bvh.faces[i][2]];
        local this1 = ({length = 3});
        local this1 = this1;
        this1[0] = p1[0] - p0[0];
        this1[1] = p1[1] - p0[1];
        this1[2] = p1[2] - p0[2];
        local e1 = this1;
        local this1 = ({length = 3});
        local this1 = this1;
        this1[0] = p2[0] - p0[0];
        this1[1] = p2[1] - p0[1];
        this1[2] = p2[2] - p0[2];
        local e2 = this1;
        local this1 = _gthis.o;
        local this2 = ({length = 3});
        local this2 = this2;
        this2[0] = this1[0] - p0[0];
        this2[1] = this1[1] - p0[1];
        this2[2] = this1[2] - p0[2];
        local s = this2;
        local this1 = _gthis.d;
        local this2 = ({length = 3});
        local this2 = this2;
        this2[0] = this1[0] * -1.0;
        this2[1] = this1[1] * -1.0;
        this2[2] = this1[2] * -1.0;
        local _d = this2;
        local this1 = ({length = 3});
        local this1 = this1;
        this1[0] = (e1[1] * e2[2]) - (e1[2] * e2[1]);
        this1[1] = (e1[2] * e2[0]) - (e1[0] * e2[2]);
        this1[2] = (e1[0] * e2[1]) - (e1[1] * e2[0]);
        local v1 = this1;
        local denom = ((v1[0] * _d[0]) + (v1[1] * _d[1])) + (v1[2] * _d[2]);
        local h;
        if (denom == 0) then 
          h = nil;
        else
          local this1 = ({length = 3});
          local this1 = this1;
          this1[0] = (s[1] * e2[2]) - (s[2] * e2[1]);
          this1[1] = (s[2] * e2[0]) - (s[0] * e2[2]);
          this1[2] = (s[0] * e2[1]) - (s[1] * e2[0]);
          local v1 = this1;
          local _x = ((v1[0] * _d[0]) + (v1[1] * _d[1])) + (v1[2] * _d[2]);
          local this1 = ({length = 3});
          local this1 = this1;
          this1[0] = (e1[1] * s[2]) - (e1[2] * s[1]);
          this1[1] = (e1[2] * s[0]) - (e1[0] * s[2]);
          this1[2] = (e1[0] * s[1]) - (e1[1] * s[0]);
          local v1 = this1;
          local _y = ((v1[0] * _d[0]) + (v1[1] * _d[1])) + (v1[2] * _d[2]);
          local this1 = ({length = 3});
          local this1 = this1;
          this1[0] = (e1[1] * e2[2]) - (e1[2] * e2[1]);
          this1[1] = (e1[2] * e2[0]) - (e1[0] * e2[2]);
          this1[2] = (e1[0] * e2[1]) - (e1[1] * e2[0]);
          local v1 = this1;
          local _z = ((v1[0] * s[0]) + (v1[1] * s[1])) + (v1[2] * s[2]);
          local this1 = ({length = 3});
          local this1 = this1;
          this1[0] = _x;
          this1[1] = _y;
          this1[2] = _z;
          local this1 = this1;
          local rhs = 1 / denom;
          local this2 = ({length = 3});
          local this2 = this2;
          this2[0] = this1[0] * rhs;
          this2[1] = this1[1] * rhs;
          this2[2] = this1[2] * rhs;
          local uvt = this2;
          local u = uvt[0];
          local v = uvt[1];
          local t = uvt[2];
          if (((((u < 0) or (v < 0)) or (((1 - u) - v) < 0)) or (t < _gthis.tmin)) or (t > _gthis.tmax)) then 
            h = nil;
          else
            local h1 = __apparentridges_RayHit.new(t);
            h1.u = u;
            h1.v = v;
            h = h1;
          end;
        end;
        if (h ~= nil) then 
          h.face = bvh.faces[i];
          if (tmin > h.t) then 
            tmin = h.t;
            closest = h;
          end;
        end;
      end;
      do return closest end;
    end;
    local bb = node.left.bbox;
    local tx1 = (bb.min[0] - _gthis.o[0]) / _gthis.d[0];
    local tx2 = (bb.max[0] - _gthis.o[0]) / _gthis.d[0];
    local ty1 = (bb.min[1] - _gthis.o[1]) / _gthis.d[1];
    local ty2 = (bb.max[1] - _gthis.o[1]) / _gthis.d[1];
    local tz1 = (bb.min[2] - _gthis.o[2]) / _gthis.d[2];
    local tz2 = (bb.max[2] - _gthis.o[2]) / _gthis.d[2];
    local t1 = Math.max(Math.max(Math.min(tx1, tx2), Math.min(ty1, ty2)), Math.min(tz1, tz2));
    local t2 = Math.min(Math.min(Math.max(tx1, tx2), Math.max(ty1, ty2)), Math.max(tz1, tz2));
    local hitL;
    if ((t2 - t1) < 0) then 
      hitL = nil;
    else
      if ((t1 > _gthis.tmax) or (t2 < _gthis.tmin)) then 
        hitL = nil;
      else
        local h = __apparentridges_RayHit.new(t1);
        h.t2 = t2;
        hitL = h;
      end;
    end;
    local bb = node.right.bbox;
    local tx1 = (bb.min[0] - _gthis.o[0]) / _gthis.d[0];
    local tx2 = (bb.max[0] - _gthis.o[0]) / _gthis.d[0];
    local ty1 = (bb.min[1] - _gthis.o[1]) / _gthis.d[1];
    local ty2 = (bb.max[1] - _gthis.o[1]) / _gthis.d[1];
    local tz1 = (bb.min[2] - _gthis.o[2]) / _gthis.d[2];
    local tz2 = (bb.max[2] - _gthis.o[2]) / _gthis.d[2];
    local t1 = Math.max(Math.max(Math.min(tx1, tx2), Math.min(ty1, ty2)), Math.min(tz1, tz2));
    local t2 = Math.min(Math.min(Math.max(tx1, tx2), Math.max(ty1, ty2)), Math.max(tz1, tz2));
    local hitR;
    if ((t2 - t1) < 0) then 
      hitR = nil;
    else
      if ((t1 > _gthis.tmax) or (t2 < _gthis.tmin)) then 
        hitR = nil;
      else
        local h = __apparentridges_RayHit.new(t1);
        h.t2 = t2;
        hitR = h;
      end;
    end;
    if ((hitL ~= nil) and (hitR == nil)) then 
      do return hitNode(node.left) end;
    else
      if ((hitL == nil) and (hitR ~= nil)) then 
        do return hitNode(node.right) end;
      else
        if ((hitL == nil) and (hitR == nil)) then 
          do return nil end;
        end;
      end;
    end;
    local first;
    local second;
    if (hitL.t < hitR.t) then 
      first = node.left;
      second = node.right;
    else
      first = node.right;
      second = node.left;
    end;
    local h = hitNode(first);
    if ((h == nil) or (h.t >= Math.max(hitL.t, hitR.t))) then 
      local h2 = hitNode(second);
      if (h2 ~= nil) then 
        if ((h == nil) or (h2.t < h.t)) then 
          do return h2 end;
        end;
      end;
    end;
    do return h end;
  end;
  do return hitNode(bvh.root) end
end

__apparentridges_Ray.prototype.__class__ =  __apparentridges_Ray

__apparentridges_RayHit.new = function(_t) 
  local self = _hx_new(__apparentridges_RayHit.prototype)
  __apparentridges_RayHit.super(self,_t)
  return self
end
__apparentridges_RayHit.super = function(self,_t) 
  self.t = _t;
end
_hx_exports["apparentridges"]["RayHit"] = __apparentridges_RayHit
__apparentridges_RayHit.__name__ = true
__apparentridges_RayHit.prototype = _hx_e();

__apparentridges_RayHit.prototype.__class__ =  __apparentridges_RayHit

__apparentridges_BBox.new = function() 
  local self = _hx_new(__apparentridges_BBox.prototype)
  __apparentridges_BBox.super(self)
  return self
end
__apparentridges_BBox.super = function(self) 
  local this1 = ({length = 3});
  local this1 = this1;
  this1[0] = _G.math.huge;
  this1[1] = _G.math.huge;
  this1[2] = _G.math.huge;
  self.min = this1;
  local this1 = ({length = 3});
  local this1 = this1;
  this1[0] = -_G.math.huge;
  this1[1] = -_G.math.huge;
  this1[2] = -_G.math.huge;
  self.max = this1;
end
_hx_exports["apparentridges"]["BBox"] = __apparentridges_BBox
__apparentridges_BBox.__name__ = true
__apparentridges_BBox.prototype = _hx_e();
__apparentridges_BBox.prototype.centroid = function(self) 
  local this1 = self.min;
  local rhs = self.max;
  local this2 = ({length = 3});
  local this2 = this2;
  this2[0] = this1[0] + rhs[0];
  this2[1] = this1[1] + rhs[1];
  this2[2] = this1[2] + rhs[2];
  local this1 = this2;
  local this2 = ({length = 3});
  local this2 = this2;
  this2[0] = this1[0] * 0.5;
  this2[1] = this1[1] * 0.5;
  this2[2] = this1[2] * 0.5;
  do return this2 end
end
__apparentridges_BBox.prototype.add = function(self,p) 
  self.min[0] = Math.min(self.min[0], p[0]);
  self.min[1] = Math.min(self.min[1], p[1]);
  self.min[2] = Math.min(self.min[2], p[2]);
  self.max[0] = Math.max(self.max[0], p[0]);
  self.max[1] = Math.max(self.max[1], p[1]);
  self.max[2] = Math.max(self.max[2], p[2]);
end
__apparentridges_BBox.prototype.merge = function(self,bb) 
  self.min[0] = Math.min(self.min[0], bb.min[0]);
  self.min[1] = Math.min(self.min[1], bb.min[1]);
  self.min[2] = Math.min(self.min[2], bb.min[2]);
  self.max[0] = Math.max(self.max[0], bb.max[0]);
  self.max[1] = Math.max(self.max[1], bb.max[1]);
  self.max[2] = Math.max(self.max[2], bb.max[2]);
end
__apparentridges_BBox.prototype.surfaceArea = function(self) 
  local this1 = self.max;
  local rhs = self.min;
  local this2 = ({length = 3});
  local this2 = this2;
  this2[0] = this1[0] - rhs[0];
  this2[1] = this1[1] - rhs[1];
  this2[2] = this1[2] - rhs[2];
  local extent = this2;
  local x = Math.max(extent[0], 0);
  local y = Math.max(extent[1], 0);
  local z = Math.max(extent[2], 0);
  do return 2 * (((x * z) + (x * y)) + (y * z)) end
end

__apparentridges_BBox.prototype.__class__ =  __apparentridges_BBox

__apparentridges_BVHNode.new = function(box,i0,i1) 
  local self = _hx_new(__apparentridges_BVHNode.prototype)
  __apparentridges_BVHNode.super(self,box,i0,i1)
  return self
end
__apparentridges_BVHNode.super = function(self,box,i0,i1) 
  self.bbox = box;
  self.begin = i0;
  self["end"] = i1;
  self.left = nil;
  self.right = nil;
end
_hx_exports["apparentridges"]["BVHNode"] = __apparentridges_BVHNode
__apparentridges_BVHNode.__name__ = true
__apparentridges_BVHNode.prototype = _hx_e();
__apparentridges_BVHNode.prototype.isLeaf = function(self) 
  if (self.left == nil) then 
    do return self.right == nil end;
  else
    do return false end;
  end;
end

__apparentridges_BVHNode.prototype.__class__ =  __apparentridges_BVHNode

__apparentridges_BVHTree.new = function(_mesh,_maxLeafSize,_bucketCount) 
  local self = _hx_new(__apparentridges_BVHTree.prototype)
  __apparentridges_BVHTree.super(self,_mesh,_maxLeafSize,_bucketCount)
  return self
end
__apparentridges_BVHTree.super = function(self,_mesh,_maxLeafSize,_bucketCount) 
  if (_bucketCount == nil) then 
    _bucketCount = 8;
  end;
  if (_maxLeafSize == nil) then 
    _maxLeafSize = 4;
  end;
  self.maxLeafSize = _maxLeafSize;
  self.bucketCount = _bucketCount;
  self.faces = _mesh.faces:slice(0);
  self.mesh = _mesh;
end
_hx_exports["apparentridges"]["BVHTree"] = __apparentridges_BVHTree
__apparentridges_BVHTree.__name__ = true
__apparentridges_BVHTree.prototype = _hx_e();
__apparentridges_BVHTree.prototype.build = function(self) 
  local _gthis = self;
  local bboxAddFace = function(bbox,f) 
    local p = _gthis.mesh.vertices[f[0]];
    bbox.min[0] = Math.min(bbox.min[0], p[0]);
    bbox.min[1] = Math.min(bbox.min[1], p[1]);
    bbox.min[2] = Math.min(bbox.min[2], p[2]);
    bbox.max[0] = Math.max(bbox.max[0], p[0]);
    bbox.max[1] = Math.max(bbox.max[1], p[1]);
    bbox.max[2] = Math.max(bbox.max[2], p[2]);
    local p = _gthis.mesh.vertices[f[1]];
    bbox.min[0] = Math.min(bbox.min[0], p[0]);
    bbox.min[1] = Math.min(bbox.min[1], p[1]);
    bbox.min[2] = Math.min(bbox.min[2], p[2]);
    bbox.max[0] = Math.max(bbox.max[0], p[0]);
    bbox.max[1] = Math.max(bbox.max[1], p[1]);
    bbox.max[2] = Math.max(bbox.max[2], p[2]);
    local p = _gthis.mesh.vertices[f[2]];
    bbox.min[0] = Math.min(bbox.min[0], p[0]);
    bbox.min[1] = Math.min(bbox.min[1], p[1]);
    bbox.min[2] = Math.min(bbox.min[2], p[2]);
    bbox.max[0] = Math.max(bbox.max[0], p[0]);
    bbox.max[1] = Math.max(bbox.max[1], p[1]);
    bbox.max[2] = Math.max(bbox.max[2], p[2]);
  end;
  local buildRange = nil;
  buildRange = function(i0,i1) 
    local bbox = __apparentridges_BBox.new();
    local _g = i0;
    local _g1 = i1;
    while (_g < _g1) do 
      _g = _g + 1;
      local i = _g - 1;
      bboxAddFace(bbox, _gthis.faces[i]);
    end;
    local node = __apparentridges_BVHNode.new(bbox, i0, i1);
    if ((i1 - i0) <= _gthis.maxLeafSize) then 
      do return node end;
    end;
    local parts = _hx_tab_array({}, 0);
    local _g = 0;
    while (_g < 3) do 
      _g = _g + 1;
      local ax = _g - 1;
      local buckets = _hx_tab_array({}, 0);
      local lo = bbox.min[ax];
      local hi = bbox.max[ax];
      local _g = 0;
      local _g1 = _gthis.bucketCount;
      while (_g < _g1) do 
        _g = _g + 1;
        local i = _g - 1;
        local b = __apparentridges_BVHBucket.new();
        b.min = lo + ((i / _gthis.bucketCount) * (hi - lo));
        b.max = b.min + ((hi - lo) / _gthis.bucketCount);
        buckets:push(b);
      end;
      local _g = i0;
      local _g1 = i1;
      while (_g < _g1) do 
        _g = _g + 1;
        local i = _g - 1;
        local bb = __apparentridges_BBox.new();
        bboxAddFace(bb, _gthis.faces[i]);
        local this1 = bb.min;
        local rhs = bb.max;
        local this2 = ({length = 3});
        local this2 = this2;
        this2[0] = this1[0] + rhs[0];
        this2[1] = this1[1] + rhs[1];
        this2[2] = this1[2] + rhs[2];
        local this1 = this2;
        local this2 = ({length = 3});
        local this2 = this2;
        this2[0] = this1[0] * 0.5;
        this2[1] = this1[1] * 0.5;
        this2[2] = this1[2] * 0.5;
        local c = this2;
        local _g = 0;
        local _g1 = _gthis.bucketCount;
        while (_g < _g1) do 
          _g = _g + 1;
          local j = _g - 1;
          if ((buckets[j].min <= c[ax]) and (c[ax] <= buckets[j].max)) then 
            buckets[j].count = buckets[j].count + 1;
            local _this = buckets[j].bbox;
            _this.min[0] = Math.min(_this.min[0], bb.min[0]);
            _this.min[1] = Math.min(_this.min[1], bb.min[1]);
            _this.min[2] = Math.min(_this.min[2], bb.min[2]);
            _this.max[0] = Math.max(_this.max[0], bb.max[0]);
            _this.max[1] = Math.max(_this.max[1], bb.max[1]);
            _this.max[2] = Math.max(_this.max[2], bb.max[2]);
            local buckets1 = buckets[j].area;
            local this1 = bb.max;
            local rhs = bb.min;
            local this2 = ({length = 3});
            local this2 = this2;
            this2[0] = this1[0] - rhs[0];
            this2[1] = this1[1] - rhs[1];
            this2[2] = this1[2] - rhs[2];
            local extent = this2;
            local x = Math.max(extent[0], 0);
            local y = Math.max(extent[1], 0);
            local z = Math.max(extent[2], 0);
            buckets[j].area = buckets1 + (2 * (((x * z) + (x * y)) + (y * z)));
            break;
          end;
        end;
      end;
      local _g = 0;
      local _g1 = _gthis.bucketCount;
      while (_g < _g1) do 
        _g = _g + 1;
        local i = _g - 1;
        local part = __apparentridges_BVHPartition.new();
        part.planeIndex = i;
        part.axis = ax;
        local _g = 0;
        local _g1 = i;
        while (_g < _g1) do 
          _g = _g + 1;
          local j = _g - 1;
          local part1 = part;
          part1.leftCount = part1.leftCount + buckets[j].count;
          local part1 = part;
          part1.leftArea = part1.leftArea + buckets[j].area;
          local _this = part.leftBBox;
          local bb = buckets[j].bbox;
          _this.min[0] = Math.min(_this.min[0], bb.min[0]);
          _this.min[1] = Math.min(_this.min[1], bb.min[1]);
          _this.min[2] = Math.min(_this.min[2], bb.min[2]);
          _this.max[0] = Math.max(_this.max[0], bb.max[0]);
          _this.max[1] = Math.max(_this.max[1], bb.max[1]);
          _this.max[2] = Math.max(_this.max[2], bb.max[2]);
        end;
        local _g = i;
        local _g1 = _gthis.bucketCount;
        while (_g < _g1) do 
          _g = _g + 1;
          local j = _g - 1;
          local part1 = part;
          part1.rightCount = part1.rightCount + buckets[j].count;
          local part1 = part;
          part1.rightArea = part1.rightArea + buckets[j].area;
          local _this = part.rightBBox;
          local bb = buckets[j].bbox;
          _this.min[0] = Math.min(_this.min[0], bb.min[0]);
          _this.min[1] = Math.min(_this.min[1], bb.min[1]);
          _this.min[2] = Math.min(_this.min[2], bb.min[2]);
          _this.max[0] = Math.max(_this.max[0], bb.max[0]);
          _this.max[1] = Math.max(_this.max[1], bb.max[1]);
          _this.max[2] = Math.max(_this.max[2], bb.max[2]);
        end;
        if ((part.leftCount > 0) and (part.rightCount > 0)) then 
          local _this = part.leftBBox;
          local this1 = _this.max;
          local rhs = _this.min;
          local this2 = ({length = 3});
          local this2 = this2;
          this2[0] = this1[0] - rhs[0];
          this2[1] = this1[1] - rhs[1];
          this2[2] = this1[2] - rhs[2];
          local extent = this2;
          local x = Math.max(extent[0], 0);
          local y = Math.max(extent[1], 0);
          local z = Math.max(extent[2], 0);
          local buildRange = (2 * (((x * z) + (x * y)) + (y * z))) / part.leftCount;
          local _this = part.rightBBox;
          local this1 = _this.max;
          local rhs = _this.min;
          local this2 = ({length = 3});
          local this2 = this2;
          this2[0] = this1[0] - rhs[0];
          this2[1] = this1[1] - rhs[1];
          this2[2] = this1[2] - rhs[2];
          local extent = this2;
          local x = Math.max(extent[0], 0);
          local y = Math.max(extent[1], 0);
          local z = Math.max(extent[2], 0);
          part.SAH = buildRange + ((2 * (((x * z) + (x * y)) + (y * z))) / part.rightCount);
          parts:push(part);
        end;
      end;
    end;
    if (parts.length == 0) then 
      do return node end;
    end;
    local minSAH = _G.math.huge;
    local minPart = nil;
    local _g = 0;
    while (_g < parts.length) do 
      local p = parts[_g];
      _g = _g + 1;
      if (p.SAH < minSAH) then 
        minSAH = p.SAH;
        minPart = p;
      end;
    end;
    local comp = function(f0,f1) 
      local bb0 = __apparentridges_BBox.new();
      local bb1 = __apparentridges_BBox.new();
      bboxAddFace(bb0, f0);
      bboxAddFace(bb1, f1);
      local this1 = bb0.min;
      local rhs = bb0.max;
      local this2 = ({length = 3});
      local this2 = this2;
      this2[0] = this1[0] + rhs[0];
      this2[1] = this1[1] + rhs[1];
      this2[2] = this1[2] + rhs[2];
      local this1 = this2;
      local this2 = ({length = 3});
      local this2 = this2;
      this2[0] = this1[0] * 0.5;
      this2[1] = this1[1] * 0.5;
      this2[2] = this1[2] * 0.5;
      local v = this2[minPart.axis];
      local this1 = bb1.min;
      local rhs = bb1.max;
      local this2 = ({length = 3});
      local this2 = this2;
      this2[0] = this1[0] + rhs[0];
      this2[1] = this1[1] + rhs[1];
      this2[2] = this1[2] + rhs[2];
      local this1 = this2;
      local this2 = ({length = 3});
      local this2 = this2;
      this2[0] = this1[0] * 0.5;
      this2[1] = this1[1] * 0.5;
      this2[2] = this1[2] * 0.5;
      local v = v - this2[minPart.axis];
      if (v < 0) then 
        do return -1 end;
      end;
      if (v > 0) then 
        do return 1 end;
      end;
      do return 0 end;
    end;
    local sorted = _gthis.faces:slice(i0, i1);
    sorted:sort(comp);
    local _g = i0;
    local _g1 = i1;
    while (_g < _g1) do 
      _g = _g + 1;
      local i = _g - 1;
      _gthis.faces[i] = sorted[i - i0];
    end;
    local m = i0 + minPart.leftCount;
    node.left = buildRange(i0, m);
    node.right = buildRange(m, i1);
    do return node end;
  end;
  self.root = buildRange(0, self.faces.length);
end

__apparentridges_BVHTree.prototype.__class__ =  __apparentridges_BVHTree

__apparentridges_BVHBucket.new = function() 
  local self = _hx_new(__apparentridges_BVHBucket.prototype)
  __apparentridges_BVHBucket.super(self)
  return self
end
__apparentridges_BVHBucket.super = function(self) 
  self.bbox = __apparentridges_BBox.new();
  self.area = 0;
  self.count = 0;
end
__apparentridges_BVHBucket.__name__ = true
__apparentridges_BVHBucket.prototype = _hx_e();

__apparentridges_BVHBucket.prototype.__class__ =  __apparentridges_BVHBucket

__apparentridges_BVHPartition.new = function() 
  local self = _hx_new(__apparentridges_BVHPartition.prototype)
  __apparentridges_BVHPartition.super(self)
  return self
end
__apparentridges_BVHPartition.super = function(self) 
  self.SAH = 0;
  self.rightArea = 0;
  self.leftArea = 0;
  self.rightCount = 0;
  self.leftCount = 0;
  self.leftBBox = __apparentridges_BBox.new();
  self.rightBBox = __apparentridges_BBox.new();
end
__apparentridges_BVHPartition.__name__ = true
__apparentridges_BVHPartition.prototype = _hx_e();

__apparentridges_BVHPartition.prototype.__class__ =  __apparentridges_BVHPartition

__apparentridges_OBJParser.new = {}
_hx_exports["apparentridges"]["OBJParser"] = __apparentridges_OBJParser
__apparentridges_OBJParser.__name__ = true
__apparentridges_OBJParser.fromFile = function(path) 
  do return __apparentridges_OBJParser.fromString(__sys_io_File.getContent(path)) end;
end
__apparentridges_OBJParser.fromString = function(str) 
  local mesh = __apparentridges_Mesh.new();
  mesh.vertices = _hx_tab_array({}, 0);
  mesh.faces = _hx_tab_array({}, 0);
  local idx = 1;
  local ret = _hx_tab_array({}, 0);
  while (idx ~= nil) do 
    local newidx = 0;
    if (#"\n" > 0) then 
      newidx = _G.string.find(str, "\n", idx, true);
    else
      if (idx >= #str) then 
        newidx = nil;
      else
        newidx = idx + 1;
      end;
    end;
    if (newidx ~= nil) then 
      local match = _G.string.sub(str, idx, newidx - 1);
      ret:push(match);
      idx = newidx + #"\n";
    else
      ret:push(_G.string.sub(str, idx, #str));
      idx = nil;
    end;
  end;
  local lines = ret;
  local _g = 0;
  local _g1 = lines.length;
  local _hx_continue_1 = false;
  while (_g < _g1) do repeat 
    _g = _g + 1;
    local i = _g - 1;
    lines[i] = StringTools.trim(lines[i]);
    if (_G.string.sub(lines[i], 1, 1) == "#") then 
      break;
    end;
    if (#lines[i] <= 2) then 
      break;
    end;
    local _this = lines[i];
    local idx = 1;
    local ret = _hx_tab_array({}, 0);
    while (idx ~= nil) do 
      local newidx = 0;
      if (#" " > 0) then 
        newidx = _G.string.find(_this, " ", idx, true);
      else
        if (idx >= #_this) then 
          newidx = nil;
        else
          newidx = idx + 1;
        end;
      end;
      if (newidx ~= nil) then 
        local match = _G.string.sub(_this, idx, newidx - 1);
        ret:push(match);
        idx = newidx + #" ";
      else
        ret:push(_G.string.sub(_this, idx, #_this));
        idx = nil;
      end;
    end;
    local tok = ret;
    local cmd = tok[0];
    if (cmd == "v") then 
      local _x = Std.parseFloat(tok[1]);
      local _y = Std.parseFloat(tok[2]);
      local _z = Std.parseFloat(tok[3]);
      local this1 = ({length = 3});
      local this1 = this1;
      this1[0] = _x;
      this1[1] = _y;
      this1[2] = _z;
      local v = this1;
      mesh.vertices:push(v);
    else
      if (cmd == "f") then 
        local _this = tok[1];
        local idx = 1;
        local ret = _hx_tab_array({}, 0);
        while (idx ~= nil) do 
          local newidx = 0;
          if (#"/" > 0) then 
            newidx = _G.string.find(_this, "/", idx, true);
          else
            if (idx >= #_this) then 
              newidx = nil;
            else
              newidx = idx + 1;
            end;
          end;
          if (newidx ~= nil) then 
            local match = _G.string.sub(_this, idx, newidx - 1);
            ret:push(match);
            idx = newidx + #"/";
          else
            ret:push(_G.string.sub(_this, idx, #_this));
            idx = nil;
          end;
        end;
        local a = Std.parseInt(ret[0]);
        local _this = tok[2];
        local idx = 1;
        local ret = _hx_tab_array({}, 0);
        while (idx ~= nil) do 
          local newidx = 0;
          if (#"/" > 0) then 
            newidx = _G.string.find(_this, "/", idx, true);
          else
            if (idx >= #_this) then 
              newidx = nil;
            else
              newidx = idx + 1;
            end;
          end;
          if (newidx ~= nil) then 
            local match = _G.string.sub(_this, idx, newidx - 1);
            ret:push(match);
            idx = newidx + #"/";
          else
            ret:push(_G.string.sub(_this, idx, #_this));
            idx = nil;
          end;
        end;
        local b = Std.parseInt(ret[0]);
        local _this = tok[3];
        local idx = 1;
        local ret = _hx_tab_array({}, 0);
        while (idx ~= nil) do 
          local newidx = 0;
          if (#"/" > 0) then 
            newidx = _G.string.find(_this, "/", idx, true);
          else
            if (idx >= #_this) then 
              newidx = nil;
            else
              newidx = idx + 1;
            end;
          end;
          if (newidx ~= nil) then 
            local match = _G.string.sub(_this, idx, newidx - 1);
            ret:push(match);
            idx = newidx + #"/";
          else
            ret:push(_G.string.sub(_this, idx, #_this));
            idx = nil;
          end;
        end;
        local c = Std.parseInt(ret[0]);
        local nv = mesh.vertices.length;
        local mesh = mesh.faces;
        local this1 = ({length = 3});
        local this1 = this1;
        this1[0] = (function() 
          local _hx_1
          if (a < 0) then 
          _hx_1 = nv + a; else 
          _hx_1 = a - 1; end
          return _hx_1
        end )();
        this1[1] = (function() 
          local _hx_2
          if (b < 0) then 
          _hx_2 = nv + b; else 
          _hx_2 = b - 1; end
          return _hx_2
        end )();
        this1[2] = (function() 
          local _hx_3
          if (c < 0) then 
          _hx_3 = nv + c; else 
          _hx_3 = c - 1; end
          return _hx_3
        end )();
        mesh:push(this1);
      end;
    end;until true
    if _hx_continue_1 then 
    _hx_continue_1 = false;
    break;
    end;
    
  end;
  do return mesh end;
end

__apparentridges_Line.new = function(_x1,_y1,_x2,_y2) 
  local self = _hx_new(__apparentridges_Line.prototype)
  __apparentridges_Line.super(self,_x1,_y1,_x2,_y2)
  return self
end
__apparentridges_Line.super = function(self,_x1,_y1,_x2,_y2) 
  self.opacity2 = 1;
  self.opacity1 = 1;
  self.x1 = _x1;
  self.y1 = _y1;
  self.x2 = _x2;
  self.y2 = _y2;
end
_hx_exports["apparentridges"]["Line"] = __apparentridges_Line
__apparentridges_Line.__name__ = true
__apparentridges_Line.prototype = _hx_e();
__apparentridges_Line.prototype.setOpacity = function(self,o1,o2) 
  self.opacity1 = o1;
  self.opacity2 = o2;
end
__apparentridges_Line.prototype.flip = function(self) 
  local tmp = self.x1;
  self.x1 = self.x2;
  self.x2 = tmp;
  tmp = self.y1;
  self.y1 = self.y2;
  self.y2 = tmp;
  tmp = self.opacity1;
  self.opacity1 = self.opacity2;
  self.opacity2 = tmp;
end

__apparentridges_Line.prototype.__class__ =  __apparentridges_Line

__apparentridges__ApparentRidges_Polyline_Impl_.new = {}
_hx_exports["apparentridges"]["_ApparentRidges"]["Polyline_Impl_"] = __apparentridges__ApparentRidges_Polyline_Impl_
__apparentridges__ApparentRidges_Polyline_Impl_.__name__ = true
__apparentridges__ApparentRidges_Polyline_Impl_._new = function() 
  local this1 = _hx_tab_array({}, 0);
  do return this1 end;
end
__apparentridges__ApparentRidges_Polyline_Impl_.get_length = function(this1) 
  do return this1.length end;
end
__apparentridges__ApparentRidges_Polyline_Impl_.set_length = function(this1,v) 
  do return this1.length end;
end
__apparentridges__ApparentRidges_Polyline_Impl_.startY = function(this1) 
  do return Std.int(_G.math.floor(this1[0][1] + 0.5)) end;
end
__apparentridges__ApparentRidges_Polyline_Impl_.endY = function(this1) 
  do return Std.int(_G.math.floor(this1[this1.length - 1][1] + 0.5)) end;
end
__apparentridges__ApparentRidges_Polyline_Impl_.startX = function(this1) 
  do return this1[0][0] end;
end
__apparentridges__ApparentRidges_Polyline_Impl_.endX = function(this1) 
  do return this1[this1.length - 1][0] end;
end
__apparentridges__ApparentRidges_Polyline_Impl_.get = function(this1,i) 
  do return this1[i] end;
end
__apparentridges__ApparentRidges_Polyline_Impl_.set = function(this1,i,v) 
  this1[i] = v;
  do return v end;
end
__apparentridges__ApparentRidges_Polyline_Impl_.push = function(this1,v) 
  this1:push(v);
  do return this1.length end;
end
__apparentridges__ApparentRidges_Polyline_Impl_.unshift = function(this1,v) 
  this1:unshift(v);
end

__apparentridges_Render.new = function(_mesh,w,h) 
  local self = _hx_new(__apparentridges_Render.prototype)
  __apparentridges_Render.super(self,_mesh,w,h)
  return self
end
__apparentridges_Render.super = function(self,_mesh,w,h) 
  self.didPrecompute = false;
  self.verbose = true;
  self.focal = 1000;
  self.mesh = _mesh;
  self.lines = _hx_tab_array({}, 0);
  self.width = w;
  self.height = h;
end
_hx_exports["apparentridges"]["Render"] = __apparentridges_Render
__apparentridges_Render.__name__ = true
__apparentridges_Render.prototype = _hx_e();
__apparentridges_Render.prototype.clear = function(self) 
  if (self.lines ~= nil) then 
    self.lines:splice(0, self.lines.length);
  end;
  if (self.polylines ~= nil) then 
    self.polylines:splice(0, self.polylines.length);
  end;
end
__apparentridges_Render.prototype.setFocal = function(self,f) 
  self.focal = f;
end
__apparentridges_Render.prototype.setVerbose = function(self,v) 
  self.verbose = v > 0;
end
__apparentridges_Render.prototype.transform = function(self,mat4x4) 
  local _g = 0;
  local _g1 = self.mesh.vertices.length;
  while (_g < _g1) do 
    _g = _g + 1;
    local i = _g - 1;
    local tmp = self.mesh.vertices;
    local v = self.mesh.vertices[i];
    local this1 = ({length = 3});
    local this1 = this1;
    this1[0] = ((((mat4x4[0] * v[0]) + (mat4x4[1] * v[1])) + (mat4x4[2] * v[2])) + mat4x4[3]) / ((((mat4x4[12] * v[0]) + (mat4x4[13] * v[1])) + (mat4x4[14] * v[2])) + mat4x4[15]);
    this1[1] = ((((mat4x4[4] * v[0]) + (mat4x4[5] * v[1])) + (mat4x4[6] * v[2])) + mat4x4[7]) / ((((mat4x4[12] * v[0]) + (mat4x4[13] * v[1])) + (mat4x4[14] * v[2])) + mat4x4[15]);
    this1[2] = ((((mat4x4[8] * v[0]) + (mat4x4[9] * v[1])) + (mat4x4[10] * v[2])) + mat4x4[11]) / ((((mat4x4[12] * v[0]) + (mat4x4[13] * v[1])) + (mat4x4[14] * v[2])) + mat4x4[15]);
    tmp[i] = this1;
  end;
end
__apparentridges_Render.prototype.scaleRotateTranslate = function(self,sx,sy,sz,rx,ry,rz,dx,dy,dz) 
  local scl = _hx_tab_array({[0]=sx, 0, 0, 0, 0, sy, 0, 0, 0, 0, sz, 0, 0, 0, 0, 1}, 16);
  local rotx_0 = 1;
  local rotx_1 = 0;
  local rotx_2 = 0;
  local rotx_3 = 0;
  local rotx_4 = 0;
  local rotx_5 = _G.math.cos(rx);
  local rotx_6 = -_G.math.sin(rx);
  local rotx_7 = 0;
  local rotx_8 = 0;
  local rotx_9 = _G.math.sin(rx);
  local rotx_10 = _G.math.cos(rx);
  local rotx_11 = 0;
  local rotx_12 = 0;
  local rotx_13 = 0;
  local rotx_14 = 0;
  local rotx_15 = 1;
  local roty_0 = _G.math.cos(ry);
  local roty_1 = 0;
  local roty_2 = _G.math.sin(ry);
  local roty_3 = 0;
  local roty_4 = 0;
  local roty_5 = 1;
  local roty_6 = 0;
  local roty_7 = 0;
  local roty_8 = -_G.math.sin(ry);
  local roty_9 = 0;
  local roty_10 = _G.math.cos(ry);
  local roty_11 = 0;
  local roty_12 = 0;
  local roty_13 = 0;
  local roty_14 = 0;
  local roty_15 = 1;
  local rotz_0 = _G.math.cos(rz);
  local rotz_1 = -_G.math.sin(rz);
  local rotz_2 = 0;
  local rotz_3 = 0;
  local rotz_4 = _G.math.sin(rz);
  local rotz_5 = _G.math.cos(rz);
  local rotz_6 = 0;
  local rotz_7 = 0;
  local rotz_8 = 0;
  local rotz_9 = 0;
  local rotz_10 = 1;
  local rotz_11 = 0;
  local rotz_12 = 0;
  local rotz_13 = 0;
  local rotz_14 = 0;
  local rotz_15 = 1;
  local trsl_0 = 1;
  local trsl_1 = 0;
  local trsl_2 = 0;
  local trsl_3 = dx;
  local trsl_4 = 0;
  local trsl_5 = 1;
  local trsl_6 = 0;
  local trsl_7 = dy;
  local trsl_8 = 0;
  local trsl_9 = 0;
  local trsl_10 = 1;
  local trsl_11 = dz;
  local trsl_12 = 0;
  local trsl_13 = 0;
  local trsl_14 = 0;
  local trsl_15 = 1;
  self:transform(scl);
  local B_0 = (((roty_0 * rotx_0) + (roty_1 * rotx_4)) + (roty_2 * rotx_8)) + (roty_3 * rotx_12);
  local B_1 = (((roty_0 * rotx_1) + (roty_1 * rotx_5)) + (roty_2 * rotx_9)) + (roty_3 * rotx_13);
  local B_2 = (((roty_0 * rotx_2) + (roty_1 * rotx_6)) + (roty_2 * rotx_10)) + (roty_3 * rotx_14);
  local B_3 = (((roty_0 * rotx_3) + (roty_1 * rotx_7)) + (roty_2 * rotx_11)) + (roty_3 * rotx_15);
  local B_4 = (((roty_4 * rotx_0) + (roty_5 * rotx_4)) + (roty_6 * rotx_8)) + (roty_7 * rotx_12);
  local B_5 = (((roty_4 * rotx_1) + (roty_5 * rotx_5)) + (roty_6 * rotx_9)) + (roty_7 * rotx_13);
  local B_6 = (((roty_4 * rotx_2) + (roty_5 * rotx_6)) + (roty_6 * rotx_10)) + (roty_7 * rotx_14);
  local B_7 = (((roty_4 * rotx_3) + (roty_5 * rotx_7)) + (roty_6 * rotx_11)) + (roty_7 * rotx_15);
  local B_8 = (((roty_8 * rotx_0) + (roty_9 * rotx_4)) + (roty_10 * rotx_8)) + (roty_11 * rotx_12);
  local B_9 = (((roty_8 * rotx_1) + (roty_9 * rotx_5)) + (roty_10 * rotx_9)) + (roty_11 * rotx_13);
  local B_10 = (((roty_8 * rotx_2) + (roty_9 * rotx_6)) + (roty_10 * rotx_10)) + (roty_11 * rotx_14);
  local B_11 = (((roty_8 * rotx_3) + (roty_9 * rotx_7)) + (roty_10 * rotx_11)) + (roty_11 * rotx_15);
  local B_12 = (((roty_12 * rotx_0) + (roty_13 * rotx_4)) + (roty_14 * rotx_8)) + (roty_15 * rotx_12);
  local B_13 = (((roty_12 * rotx_1) + (roty_13 * rotx_5)) + (roty_14 * rotx_9)) + (roty_15 * rotx_13);
  local B_14 = (((roty_12 * rotx_2) + (roty_13 * rotx_6)) + (roty_14 * rotx_10)) + (roty_15 * rotx_14);
  local B_15 = (((roty_12 * rotx_3) + (roty_13 * rotx_7)) + (roty_14 * rotx_11)) + (roty_15 * rotx_15);
  local B_01 = (((rotz_0 * B_0) + (rotz_1 * B_4)) + (rotz_2 * B_8)) + (rotz_3 * B_12);
  local B_16 = (((rotz_0 * B_1) + (rotz_1 * B_5)) + (rotz_2 * B_9)) + (rotz_3 * B_13);
  local B_21 = (((rotz_0 * B_2) + (rotz_1 * B_6)) + (rotz_2 * B_10)) + (rotz_3 * B_14);
  local B_31 = (((rotz_0 * B_3) + (rotz_1 * B_7)) + (rotz_2 * B_11)) + (rotz_3 * B_15);
  local B_41 = (((rotz_4 * B_0) + (rotz_5 * B_4)) + (rotz_6 * B_8)) + (rotz_7 * B_12);
  local B_51 = (((rotz_4 * B_1) + (rotz_5 * B_5)) + (rotz_6 * B_9)) + (rotz_7 * B_13);
  local B_61 = (((rotz_4 * B_2) + (rotz_5 * B_6)) + (rotz_6 * B_10)) + (rotz_7 * B_14);
  local B_71 = (((rotz_4 * B_3) + (rotz_5 * B_7)) + (rotz_6 * B_11)) + (rotz_7 * B_15);
  local B_81 = (((rotz_8 * B_0) + (rotz_9 * B_4)) + (rotz_10 * B_8)) + (rotz_11 * B_12);
  local B_91 = (((rotz_8 * B_1) + (rotz_9 * B_5)) + (rotz_10 * B_9)) + (rotz_11 * B_13);
  local B_101 = (((rotz_8 * B_2) + (rotz_9 * B_6)) + (rotz_10 * B_10)) + (rotz_11 * B_14);
  local B_111 = (((rotz_8 * B_3) + (rotz_9 * B_7)) + (rotz_10 * B_11)) + (rotz_11 * B_15);
  local B_12 = (((rotz_12 * B_0) + (rotz_13 * B_4)) + (rotz_14 * B_8)) + (rotz_15 * B_12);
  local B_13 = (((rotz_12 * B_1) + (rotz_13 * B_5)) + (rotz_14 * B_9)) + (rotz_15 * B_13);
  local B_14 = (((rotz_12 * B_2) + (rotz_13 * B_6)) + (rotz_14 * B_10)) + (rotz_15 * B_14);
  local B_15 = (((rotz_12 * B_3) + (rotz_13 * B_7)) + (rotz_14 * B_11)) + (rotz_15 * B_15);
  self:transform(_hx_tab_array({[0]=(((trsl_0 * B_01) + (trsl_1 * B_41)) + (trsl_2 * B_81)) + (trsl_3 * B_12), (((trsl_0 * B_16) + (trsl_1 * B_51)) + (trsl_2 * B_91)) + (trsl_3 * B_13), (((trsl_0 * B_21) + (trsl_1 * B_61)) + (trsl_2 * B_101)) + (trsl_3 * B_14), (((trsl_0 * B_31) + (trsl_1 * B_71)) + (trsl_2 * B_111)) + (trsl_3 * B_15), (((trsl_4 * B_01) + (trsl_5 * B_41)) + (trsl_6 * B_81)) + (trsl_7 * B_12), (((trsl_4 * B_16) + (trsl_5 * B_51)) + (trsl_6 * B_91)) + (trsl_7 * B_13), (((trsl_4 * B_21) + (trsl_5 * B_61)) + (trsl_6 * B_101)) + (trsl_7 * B_14), (((trsl_4 * B_31) + (trsl_5 * B_71)) + (trsl_6 * B_111)) + (trsl_7 * B_15), (((trsl_8 * B_01) + (trsl_9 * B_41)) + (trsl_10 * B_81)) + (trsl_11 * B_12), (((trsl_8 * B_16) + (trsl_9 * B_51)) + (trsl_10 * B_91)) + (trsl_11 * B_13), (((trsl_8 * B_21) + (trsl_9 * B_61)) + (trsl_10 * B_101)) + (trsl_11 * B_14), (((trsl_8 * B_31) + (trsl_9 * B_71)) + (trsl_10 * B_111)) + (trsl_11 * B_15), (((trsl_12 * B_01) + (trsl_13 * B_41)) + (trsl_14 * B_81)) + (trsl_15 * B_12), (((trsl_12 * B_16) + (trsl_13 * B_51)) + (trsl_14 * B_91)) + (trsl_15 * B_13), (((trsl_12 * B_21) + (trsl_13 * B_61)) + (trsl_14 * B_101)) + (trsl_15 * B_14), (((trsl_12 * B_31) + (trsl_13 * B_71)) + (trsl_14 * B_111)) + (trsl_15 * B_15)}, 16));
end
__apparentridges_Render.prototype.autoPlace = function(self,zFactor,fFactor) 
  if (fFactor == nil) then 
    fFactor = 1.25;
  end;
  if (zFactor == nil) then 
    zFactor = 1.5;
  end;
  self.mesh:computeBSphere();
  self:transform(_hx_tab_array({[0]=1, 0, 0, -self.mesh.bsphere.o[0], 0, 1, 0, -self.mesh.bsphere.o[1], 0, 0, 1, -self.mesh.bsphere.o[2], 0, 0, 0, 1}, 16));
  local a = self.width;
  local b = self.height;
  local r = (function() 
    local _hx_1
    if (a > b) then 
    _hx_1 = b; else 
    _hx_1 = a; end
    return _hx_1
  end )() / 2;
  self:transform(_hx_tab_array({[0]=r / self.mesh.bsphere.r, 0, 0, 0, 0, r / self.mesh.bsphere.r, 0, 0, 0, 0, r / self.mesh.bsphere.r, 0, 0, 0, 0, 1}, 16));
  self:transform(_hx_tab_array({[0]=1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, r * zFactor, 0, 0, 0, 1}, 16));
  self:setFocal(r * fFactor);
end
__apparentridges_Render.prototype.vertices = function(self) 
  local _x = self.width / 2;
  local _y = self.height / 2;
  local this1 = ({length = 3});
  local this1 = this1;
  this1[0] = _x;
  this1[1] = _y;
  this1[2] = 0;
  local offs = this1;
  local this1 = ({length = 3});
  local this1 = this1;
  this1[0] = -1;
  this1[1] = -1;
  this1[2] = 1;
  local yflip = this1;
  local _g = 0;
  local _g1 = self.mesh.vertices.length;
  while (_g < _g1) do 
    _g = _g + 1;
    local i = _g - 1;
    local v = self.mesh.vertices[i];
    local f = self.focal;
    local this1 = ({length = 3});
    local this1 = this1;
    this1[0] = (f * v[0]) / v[2];
    this1[1] = (f * v[1]) / v[2];
    this1[2] = 0;
    local this1 = this1;
    local this2 = ({length = 3});
    local this2 = this2;
    this2[0] = this1[0] * yflip[0];
    this2[1] = this1[1] * yflip[1];
    this2[2] = this1[2] * yflip[2];
    local this1 = this2;
    local this2 = ({length = 3});
    local this2 = this2;
    this2[0] = this1[0] + offs[0];
    this2[1] = this1[1] + offs[1];
    this2[2] = this1[2] + offs[2];
    local p = this2;
    self.lines:push(__apparentridges_Line.new(p[0] - 1, p[1] - 1, p[0] + 1, p[1] + 1));
    self.lines:push(__apparentridges_Line.new(p[0] + 1, p[1] - 1, p[0] - 1, p[1] + 1));
  end;
end
__apparentridges_Render.prototype.edges = function(self) 
  local _x = self.width / 2;
  local _y = self.height / 2;
  local this1 = ({length = 3});
  local this1 = this1;
  this1[0] = _x;
  this1[1] = _y;
  this1[2] = 0;
  local offs = this1;
  local this1 = ({length = 3});
  local this1 = this1;
  this1[0] = -1;
  this1[1] = -1;
  this1[2] = 1;
  local yflip = this1;
  local _g = 0;
  local _g1 = self.mesh.faces.length;
  while (_g < _g1) do 
    _g = _g + 1;
    local i = _g - 1;
    local f = self.mesh.faces[i];
    local f1 = self.focal;
    local v = self.mesh.vertices[f[0]];
    local this1 = ({length = 3});
    local this1 = this1;
    this1[0] = (f1 * v[0]) / v[2];
    this1[1] = (f1 * v[1]) / v[2];
    this1[2] = 0;
    local this1 = this1;
    local this2 = ({length = 3});
    local this2 = this2;
    this2[0] = this1[0] * yflip[0];
    this2[1] = this1[1] * yflip[1];
    this2[2] = this1[2] * yflip[2];
    local this1 = this2;
    local this2 = ({length = 3});
    local this2 = this2;
    this2[0] = this1[0] + offs[0];
    this2[1] = this1[1] + offs[1];
    this2[2] = this1[2] + offs[2];
    local p0 = this2;
    local f1 = self.focal;
    local v = self.mesh.vertices[f[1]];
    local this1 = ({length = 3});
    local this1 = this1;
    this1[0] = (f1 * v[0]) / v[2];
    this1[1] = (f1 * v[1]) / v[2];
    this1[2] = 0;
    local this1 = this1;
    local this2 = ({length = 3});
    local this2 = this2;
    this2[0] = this1[0] * yflip[0];
    this2[1] = this1[1] * yflip[1];
    this2[2] = this1[2] * yflip[2];
    local this1 = this2;
    local this2 = ({length = 3});
    local this2 = this2;
    this2[0] = this1[0] + offs[0];
    this2[1] = this1[1] + offs[1];
    this2[2] = this1[2] + offs[2];
    local p1 = this2;
    local f1 = self.focal;
    local v = self.mesh.vertices[f[2]];
    local this1 = ({length = 3});
    local this1 = this1;
    this1[0] = (f1 * v[0]) / v[2];
    this1[1] = (f1 * v[1]) / v[2];
    this1[2] = 0;
    local this1 = this1;
    local this2 = ({length = 3});
    local this2 = this2;
    this2[0] = this1[0] * yflip[0];
    this2[1] = this1[1] * yflip[1];
    this2[2] = this1[2] * yflip[2];
    local this1 = this2;
    local this2 = ({length = 3});
    local this2 = this2;
    this2[0] = this1[0] + offs[0];
    this2[1] = this1[1] + offs[1];
    this2[2] = this1[2] + offs[2];
    local p2 = this2;
    self.lines:push(__apparentridges_Line.new(p0[0], p0[1], p1[0], p1[1]));
    self.lines:push(__apparentridges_Line.new(p1[0], p1[1], p2[0], p2[1]));
    self.lines:push(__apparentridges_Line.new(p2[0], p2[1], p0[0], p0[1]));
  end;
end
__apparentridges_Render.prototype.apparentRidges = function(self,thresh,cull) 
  if (cull == nil) then 
    cull = 2;
  end;
  if (not self.didPrecompute) then 
    if (self.verbose) then 
      __haxe_Log.trace("precomputing mesh properties...", _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="apparentridges/ApparentRidges.hx",lineNumber=1537,className="apparentridges.Render",methodName="apparentRidges"}));
    end;
    self.mesh:precompute(cull >= 0, self.verbose);
    self.didPrecompute = true;
  end;
  local _x = self.width / 2;
  local _y = self.height / 2;
  local this1 = ({length = 3});
  local this1 = this1;
  this1[0] = _x;
  this1[1] = _y;
  this1[2] = 0;
  local offs = this1;
  local this1 = ({length = 3});
  local this1 = this1;
  this1[0] = -1;
  this1[1] = -1;
  this1[2] = 1;
  local yflip = this1;
  local this1 = ({length = 3});
  local this1 = this1;
  this1[0] = 0;
  this1[1] = 0;
  this1[2] = 0;
  local eye = this1;
  if (self.verbose) then 
    __haxe_Log.trace("generating apparent ridges...", _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="apparentridges/ApparentRidges.hx",lineNumber=1545,className="apparentridges.Render",methodName="apparentRidges"}));
  end;
  local ridges = self.mesh:apparentRidges(eye, thresh);
  if (self.verbose) then 
    __haxe_Log.trace("projecting apparent ridges onto 2D plane...", _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="apparentridges/ApparentRidges.hx",lineNumber=1547,className="apparentridges.Render",methodName="apparentRidges"}));
  end;
  local _g = 0;
  local _g1 = ridges.length;
  local _hx_continue_1 = false;
  while (_g < _g1) do repeat 
    _g = _g + 1;
    local i = _g - 1;
    if (cull >= 0) then 
      if (not self.mesh:visible(eye, ridges[i].A, cull) and not self.mesh:visible(eye, ridges[i].B, cull)) then 
        break;
      end;
    end;
    local f = self.focal;
    local v = ridges[i].A;
    local this1 = ({length = 3});
    local this1 = this1;
    this1[0] = (f * v[0]) / v[2];
    this1[1] = (f * v[1]) / v[2];
    this1[2] = 0;
    local this1 = this1;
    local this2 = ({length = 3});
    local this2 = this2;
    this2[0] = this1[0] * yflip[0];
    this2[1] = this1[1] * yflip[1];
    this2[2] = this1[2] * yflip[2];
    local this1 = this2;
    local this2 = ({length = 3});
    local this2 = this2;
    this2[0] = this1[0] + offs[0];
    this2[1] = this1[1] + offs[1];
    this2[2] = this1[2] + offs[2];
    local p0 = this2;
    local f = self.focal;
    local v = ridges[i].B;
    local this1 = ({length = 3});
    local this1 = this1;
    this1[0] = (f * v[0]) / v[2];
    this1[1] = (f * v[1]) / v[2];
    this1[2] = 0;
    local this1 = this1;
    local this2 = ({length = 3});
    local this2 = this2;
    this2[0] = this1[0] * yflip[0];
    this2[1] = this1[1] * yflip[1];
    this2[2] = this1[2] * yflip[2];
    local this1 = this2;
    local this2 = ({length = 3});
    local this2 = this2;
    this2[0] = this1[0] + offs[0];
    this2[1] = this1[1] + offs[1];
    this2[2] = this1[2] + offs[2];
    local p1 = this2;
    local l = __apparentridges_Line.new(p0[0], p0[1], p1[0], p1[1]);
    l.opacity1 = ridges[i].strengthA;
    l.opacity2 = ridges[i].strengthB;
    self.lines:push(l);until true
    if _hx_continue_1 then 
    _hx_continue_1 = false;
    break;
    end;
    
  end;
  if (self.verbose) then 
    __haxe_Log.trace("apparent ridges computation finished.", _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="apparentridges/ApparentRidges.hx",lineNumber=1561,className="apparentridges.Render",methodName="apparentRidges"}));
  end;
end
__apparentridges_Render.prototype.buildPolylines = function(self,epsilon) 
  if (epsilon == nil) then 
    epsilon = 1;
  end;
  local _gthis = self;
  if (self.verbose) then 
    __haxe_Log.trace("building polylines from ridge segments...", _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="apparentridges/ApparentRidges.hx",lineNumber=1565,className="apparentridges.Render",methodName="buildPolylines"}));
  end;
  self.polylines = _hx_tab_array({}, 0);
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = self.lines;
  while (_g1 < _g2.length) do 
    local i = _g2[_g1];
    _g1 = _g1 + 1;
    if (not ((((i.y1 < 0) or (i.y1 > (_gthis.height - 1))) or (i.y2 < 0)) or (i.y2 > (_gthis.height - 1)))) then 
      _g:push(i);
    end;
  end;
  self.lines = _g;
  local _g = 0;
  local _g1 = self.lines.length;
  while (_g < _g1) do 
    _g = _g + 1;
    local i = _g - 1;
    local y1 = self.lines[i].y1;
    local y2 = self.lines[i].y2;
    if (y1 > y2) then 
      self.lines[i]:flip();
    else
      if (y1 == y2) then 
        if (self.lines[i].x1 > self.lines[i].x2) then 
          self.lines[i]:flip();
        end;
      end;
    end;
  end;
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = self.height;
  while (_g1 < _g2) do 
    _g1 = _g1 + 1;
    local i = _g1 - 1;
    _g:push(_hx_tab_array({}, 0));
  end;
  local rows = _g;
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = self.height;
  while (_g1 < _g2) do 
    _g1 = _g1 + 1;
    local i = _g1 - 1;
    _g:push(_hx_tab_array({}, 0));
  end;
  local ends = _g;
  local singleton = function(a) 
    local this1 = _hx_tab_array({}, 0);
    local p = this1;
    local _x = a.x1;
    local _y = a.y1;
    local _z = a.opacity1;
    local this1 = ({length = 3});
    local this1 = this1;
    this1[0] = _x;
    this1[1] = _y;
    this1[2] = _z;
    p:push(this1);
    local _x = a.x2;
    local _y = a.y2;
    local _z = a.opacity2;
    local this1 = ({length = 3});
    local this1 = this1;
    this1[0] = _x;
    this1[1] = _y;
    this1[2] = _z;
    p:push(this1);
    do return p end;
  end;
  local _g = 0;
  local _g1 = self.lines.length;
  while (_g < _g1) do 
    _g = _g + 1;
    local i = _g - 1;
    local p = singleton(self.lines[i]);
    rows[Std.int(_G.math.floor(self.lines[i].y1 + 0.5))]:push(p);
    ends[Std.int(_G.math.floor(self.lines[i].y2 + 0.5))]:push(p);
  end;
  local _g = 0;
  local _g1 = rows.length;
  while (_g < _g1) do 
    _g = _g + 1;
    local i = _g - 1;
    local nj = rows[i].length;
    local _g = 0;
    local _g1 = nj;
    local _hx_continue_2 = false;
    while (_g < _g1) do repeat 
      _g = _g + 1;
      local _j = _g - 1;
      local j = (nj - _j) - 1;
      if (rows[i][j] == nil) then 
        break;
      end;
      local nk = ends[i].length;
      local _g = 0;
      local _g1 = nk;
      local _hx_continue_3 = false;
      while (_g < _g1) do repeat 
        _g = _g + 1;
        local _k = _g - 1;
        local k = (nk - _k) - 1;
        if (ends[i][k] == nil) then 
          break;
        end;
        if (rows[i][j] == ends[i][k]) then 
          break;
        end;
        local this1 = rows[i][j];
        local r = Std.int(_G.math.floor(this1[this1.length - 1][1] + 0.5));
        local this1 = ends[i][k];
        local d = _G.math.abs(rows[i][j][0][0] - this1[this1.length - 1][0]);
        if (d <= epsilon) then 
          if (d < 1) then 
            ends[i][k][ends[i][k].length - 1][2] = (ends[i][k][ends[i][k].length - 1][2] + rows[i][j][0][2]) / 2;
          end;
          local _g = (function() 
            local _hx_1
            if (d < 1) then 
            _hx_1 = 1; else 
            _hx_1 = 0; end
            return _hx_1
          end )();
          local _g1 = rows[i][j].length;
          while (_g < _g1) do 
            _g = _g + 1;
            local t = _g - 1;
            local this1 = ends[i][k];
            this1:push(rows[i][j][t]);
          end;
          ends[r]:remove(rows[i][j]);
          ends[r]:push(ends[i][k]);
          ends[i][k] = nil;
          _hx_continue_3 = true;break;
        end;until true
        if _hx_continue_3 then 
        _hx_continue_3 = false;
        break;
        end;
        
      end;until true
      if _hx_continue_2 then 
      _hx_continue_2 = false;
      break;
      end;
      
    end;
  end;
  local _g = 0;
  local _g1 = ends.length;
  while (_g < _g1) do 
    _g = _g + 1;
    local i = _g - 1;
    local _g = 0;
    local _g1 = ends[i].length;
    while (_g < _g1) do 
      _g = _g + 1;
      local j = _g - 1;
      if (ends[i][j] ~= nil) then 
        self.polylines:push(ends[i][j]);
      end;
    end;
  end;
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = self.polylines;
  while (_g1 < _g2.length) do 
    local i = _g2[_g1];
    _g1 = _g1 + 1;
    local tmp;
    if (i.length > 2) then 
      tmp = true;
    else
      if (i.length < 2) then 
        tmp = false;
      else
        local v1 = i[0];
        local v2 = i[1];
        local x = v1[0] - v2[0];
        local x1 = v1[1] - v2[1];
        local x2 = v1[2] - v2[2];
        tmp = (function() 
          local _hx_2
          if (_G.math.sqrt(((x * x) + (x1 * x1)) + (x2 * x2)) < epsilon) then 
          _hx_2 = false; else 
          _hx_2 = true; end
          return _hx_2
        end )();
      end;
    end;
    if (tmp) then 
      _g:push(i);
    end;
  end;
  self.polylines = _g;
  if (self.verbose) then 
    __haxe_Log.trace("polylines built.", _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="apparentridges/ApparentRidges.hx",lineNumber=1656,className="apparentridges.Render",methodName="buildPolylines"}));
  end;
end

__apparentridges_Render.prototype.__class__ =  __apparentridges_Render

__apparentridges_PixelMap.new = {}
_hx_exports["apparentridges"]["PixelMap"] = __apparentridges_PixelMap
__apparentridges_PixelMap.__name__ = true
__apparentridges_PixelMap.raycast = function(render,fun) 
  local min = _G.math.huge;
  local max = -_G.math.huge;
  local width = render.width;
  local height = render.height;
  local hw = Std.int(width / 2);
  local hh = Std.int(height / 2);
  local _g = -hh;
  local _g1 = height - hh;
  while (_g < _g1) do 
    _g = _g + 1;
    local y = _g - 1;
    local _g = -hw;
    local _g1 = width - hw;
    while (_g < _g1) do 
      _g = _g + 1;
      local x = _g - 1;
      local r_tmin = _hx_tab_array({}, 0);
      local r_tmax = _hx_tab_array({}, 0);
      local r_o = _hx_tab_array({}, 0);
      local r_d = _hx_tab_array({}, 0);
      local r_o1 = r_o;
      local this1 = ({length = 3});
      local this1 = this1;
      this1[0] = 0;
      this1[1] = 0;
      this1[2] = 0;
      r_o1[0] = this1;
      local r_d1 = r_d;
      local _z = render.focal;
      local this1 = ({length = 3});
      local this1 = this1;
      this1[0] = -x;
      this1[1] = -y;
      this1[2] = _z;
      r_d1[0] = this1;
      r_tmax[0] = _G.math.huge;
      r_tmin[0] = 0;
      local this1 = r_d[0];
      local l = _G.math.sqrt(((this1[0] * this1[0]) + (this1[1] * this1[1])) + (this1[2] * this1[2]));
      if (l > 0) then 
        l = 1 / l;
        local _g = this1;
        _g[0] = _g[0] * l;
        local _g = this1;
        _g[1] = _g[1] * l;
        local _g = this1;
        _g[2] = _g[2] * l;
      else
        this1[0] = 0;
        this1[1] = 0;
        this1[2] = 1;
      end;
      local bvh = _hx_tab_array({[0]=render.mesh.bvh}, 1);
      local hitNode = _hx_tab_array({[0]=nil}, 1);
      hitNode[0] = (function(r_tmax,r_tmin,r_d,r_o,hitNode,bvh) 
        do return function(node) 
          if ((node.left == nil) and (node.right == nil)) then 
            local tmin = _G.math.huge;
            local closest = nil;
            local _g = node.begin;
            local _g1 = node["end"];
            while (_g < _g1) do 
              _g = _g + 1;
              local i = _g - 1;
              local p0 = bvh[0].mesh.vertices[bvh[0].faces[i][0]];
              local p1 = bvh[0].mesh.vertices[bvh[0].faces[i][1]];
              local p2 = bvh[0].mesh.vertices[bvh[0].faces[i][2]];
              local this1 = ({length = 3});
              local this1 = this1;
              this1[0] = p1[0] - p0[0];
              this1[1] = p1[1] - p0[1];
              this1[2] = p1[2] - p0[2];
              local e1 = this1;
              local this1 = ({length = 3});
              local this1 = this1;
              this1[0] = p2[0] - p0[0];
              this1[1] = p2[1] - p0[1];
              this1[2] = p2[2] - p0[2];
              local e2 = this1;
              local this1 = r_o[0];
              local this2 = ({length = 3});
              local this2 = this2;
              this2[0] = this1[0] - p0[0];
              this2[1] = this1[1] - p0[1];
              this2[2] = this1[2] - p0[2];
              local s = this2;
              local this1 = r_d[0];
              local this2 = ({length = 3});
              local this2 = this2;
              this2[0] = this1[0] * -1.0;
              this2[1] = this1[1] * -1.0;
              this2[2] = this1[2] * -1.0;
              local _d = this2;
              local this1 = ({length = 3});
              local this1 = this1;
              this1[0] = (e1[1] * e2[2]) - (e1[2] * e2[1]);
              this1[1] = (e1[2] * e2[0]) - (e1[0] * e2[2]);
              this1[2] = (e1[0] * e2[1]) - (e1[1] * e2[0]);
              local v1 = this1;
              local denom = ((v1[0] * _d[0]) + (v1[1] * _d[1])) + (v1[2] * _d[2]);
              local h;
              if (denom == 0) then 
                h = nil;
              else
                local this1 = ({length = 3});
                local this1 = this1;
                this1[0] = (s[1] * e2[2]) - (s[2] * e2[1]);
                this1[1] = (s[2] * e2[0]) - (s[0] * e2[2]);
                this1[2] = (s[0] * e2[1]) - (s[1] * e2[0]);
                local v1 = this1;
                local _x = ((v1[0] * _d[0]) + (v1[1] * _d[1])) + (v1[2] * _d[2]);
                local this1 = ({length = 3});
                local this1 = this1;
                this1[0] = (e1[1] * s[2]) - (e1[2] * s[1]);
                this1[1] = (e1[2] * s[0]) - (e1[0] * s[2]);
                this1[2] = (e1[0] * s[1]) - (e1[1] * s[0]);
                local v1 = this1;
                local _y = ((v1[0] * _d[0]) + (v1[1] * _d[1])) + (v1[2] * _d[2]);
                local this1 = ({length = 3});
                local this1 = this1;
                this1[0] = (e1[1] * e2[2]) - (e1[2] * e2[1]);
                this1[1] = (e1[2] * e2[0]) - (e1[0] * e2[2]);
                this1[2] = (e1[0] * e2[1]) - (e1[1] * e2[0]);
                local v1 = this1;
                local _z = ((v1[0] * s[0]) + (v1[1] * s[1])) + (v1[2] * s[2]);
                local this1 = ({length = 3});
                local this1 = this1;
                this1[0] = _x;
                this1[1] = _y;
                this1[2] = _z;
                local this1 = this1;
                local rhs = 1 / denom;
                local this2 = ({length = 3});
                local this2 = this2;
                this2[0] = this1[0] * rhs;
                this2[1] = this1[1] * rhs;
                this2[2] = this1[2] * rhs;
                local uvt = this2;
                local u = uvt[0];
                local v = uvt[1];
                local t = uvt[2];
                if (((((u < 0) or (v < 0)) or (((1 - u) - v) < 0)) or (t < r_tmin[0])) or (t > r_tmax[0])) then 
                  h = nil;
                else
                  local h1 = __apparentridges_RayHit.new(t);
                  h1.u = u;
                  h1.v = v;
                  h = h1;
                end;
              end;
              if (h ~= nil) then 
                h.face = bvh[0].faces[i];
                if (tmin > h.t) then 
                  tmin = h.t;
                  closest = h;
                end;
              end;
            end;
            do return closest end;
          end;
          local bb = node.left.bbox;
          local tx1 = (bb.min[0] - r_o[0][0]) / r_d[0][0];
          local tx2 = (bb.max[0] - r_o[0][0]) / r_d[0][0];
          local ty1 = (bb.min[1] - r_o[0][1]) / r_d[0][1];
          local ty2 = (bb.max[1] - r_o[0][1]) / r_d[0][1];
          local tz1 = (bb.min[2] - r_o[0][2]) / r_d[0][2];
          local tz2 = (bb.max[2] - r_o[0][2]) / r_d[0][2];
          local t1 = Math.max(Math.max(Math.min(tx1, tx2), Math.min(ty1, ty2)), Math.min(tz1, tz2));
          local t2 = Math.min(Math.min(Math.max(tx1, tx2), Math.max(ty1, ty2)), Math.max(tz1, tz2));
          local hitL;
          if ((t2 - t1) < 0) then 
            hitL = nil;
          else
            if ((t1 > r_tmax[0]) or (t2 < r_tmin[0])) then 
              hitL = nil;
            else
              local h = __apparentridges_RayHit.new(t1);
              h.t2 = t2;
              hitL = h;
            end;
          end;
          local bb = node.right.bbox;
          local tx1 = (bb.min[0] - r_o[0][0]) / r_d[0][0];
          local tx2 = (bb.max[0] - r_o[0][0]) / r_d[0][0];
          local ty1 = (bb.min[1] - r_o[0][1]) / r_d[0][1];
          local ty2 = (bb.max[1] - r_o[0][1]) / r_d[0][1];
          local tz1 = (bb.min[2] - r_o[0][2]) / r_d[0][2];
          local tz2 = (bb.max[2] - r_o[0][2]) / r_d[0][2];
          local t1 = Math.max(Math.max(Math.min(tx1, tx2), Math.min(ty1, ty2)), Math.min(tz1, tz2));
          local t2 = Math.min(Math.min(Math.max(tx1, tx2), Math.max(ty1, ty2)), Math.max(tz1, tz2));
          local hitR;
          if ((t2 - t1) < 0) then 
            hitR = nil;
          else
            if ((t1 > r_tmax[0]) or (t2 < r_tmin[0])) then 
              hitR = nil;
            else
              local h = __apparentridges_RayHit.new(t1);
              h.t2 = t2;
              hitR = h;
            end;
          end;
          if ((hitL ~= nil) and (hitR == nil)) then 
            do return hitNode[0](node.left) end;
          else
            if ((hitL == nil) and (hitR ~= nil)) then 
              do return hitNode[0](node.right) end;
            else
              if ((hitL == nil) and (hitR == nil)) then 
                do return nil end;
              end;
            end;
          end;
          local first;
          local second;
          if (hitL.t < hitR.t) then 
            first = node.left;
            second = node.right;
          else
            first = node.right;
            second = node.left;
          end;
          local h = hitNode[0](first);
          if ((h == nil) or (h.t >= Math.max(hitL.t, hitR.t))) then 
            local h2 = hitNode[0](second);
            if (h2 ~= nil) then 
              if ((h == nil) or (h2.t < h.t)) then 
                do return h2 end;
              end;
            end;
          end;
          do return h end;
        end end;
      end)(r_tmax, r_tmin, r_d, r_o, hitNode, bvh);
      local h = hitNode[0](bvh[0].root);
      fun(h, x + hh, y + hh);
    end;
  end;
end
__apparentridges_PixelMap.depth = function(render,normalize) 
  if (normalize == nil) then 
    normalize = false;
  end;
  local length = render.width * render.height;
  local this1 = ({length = length});
  local data = this1;
  local min = _G.math.huge;
  local max = -_G.math.huge;
  __apparentridges_PixelMap.raycast(render, function(h,x,y) 
    if (h == nil) then 
      data[(y * render.width) + x] = _G.math.huge;
    else
      min = Math.min(min, h.t);
      max = Math.max(max, h.t);
      data[(y * render.width) + x] = h.t;
    end;
  end);
  if (normalize) then 
    local _g = 0;
    local _g1 = data.length;
    while (_g < _g1) do 
      _g = _g + 1;
      local i = _g - 1;
      if (data[i] ~= _G.math.huge) then 
        data[i] = 1 - ((data[i] - min) / (max - min));
      else
        data[i] = 0;
      end;
    end;
  end;
  do return data end;
end
__apparentridges_PixelMap.normal = function(render) 
  local length = (render.width * render.height) * 3;
  local this1 = ({length = length});
  local data = this1;
  __apparentridges_PixelMap.raycast(render, function(h,x,y) 
    local idx = ((y * render.width) + x) * 3;
    if (h == nil) then 
      data[idx] = 0;
      data[idx + 1] = 0;
      data[idx + 2] = 0;
    else
      local f = h.face;
      local n0 = render.mesh.normals[f[0]];
      local n1 = render.mesh.normals[f[1]];
      local n2 = render.mesh.normals[f[2]];
      local rhs = (1 - h.u) - h.v;
      local this1 = ({length = 3});
      local this1 = this1;
      this1[0] = n0[0] * rhs;
      this1[1] = n0[1] * rhs;
      this1[2] = n0[2] * rhs;
      local this1 = this1;
      local rhs = h.u;
      local this2 = ({length = 3});
      local this2 = this2;
      this2[0] = n1[0] * rhs;
      this2[1] = n1[1] * rhs;
      this2[2] = n1[2] * rhs;
      local rhs = this2;
      local this2 = ({length = 3});
      local this2 = this2;
      this2[0] = this1[0] + rhs[0];
      this2[1] = this1[1] + rhs[1];
      this2[2] = this1[2] + rhs[2];
      local this1 = this2;
      local rhs = h.v;
      local this2 = ({length = 3});
      local this2 = this2;
      this2[0] = n2[0] * rhs;
      this2[1] = n2[1] * rhs;
      this2[2] = n2[2] * rhs;
      local rhs = this2;
      local this2 = ({length = 3});
      local this2 = this2;
      this2[0] = this1[0] + rhs[0];
      this2[1] = this1[1] + rhs[1];
      this2[2] = this1[2] + rhs[2];
      local n = this2;
      data[idx] = n[0];
      data[idx + 1] = n[1];
      data[idx + 2] = n[2];
    end;
  end);
  do return data end;
end
__apparentridges_PixelMap.curvature = function(render) 
  local length = (render.width * render.height) * 2;
  local this1 = ({length = length});
  local data = this1;
  __apparentridges_PixelMap.raycast(render, function(h,x,y) 
    local idx = ((y * render.width) + x) * 2;
    if (h == nil) then 
      data[idx] = 0;
      data[idx + 1] = 0;
    else
      local f = h.face;
      local c1a = render.mesh.curv1[f[0]];
      local c1b = render.mesh.curv1[f[1]];
      local c1c = render.mesh.curv1[f[2]];
      local c2a = render.mesh.curv2[f[0]];
      local c2b = render.mesh.curv2[f[1]];
      local c2c = render.mesh.curv2[f[2]];
      local c1 = ((c1a * ((1 - h.u) - h.v)) + (c1b * h.u)) + (c1c * h.v);
      local c2 = ((c2a * ((1 - h.u) - h.v)) + (c2b * h.u)) + (c2c * h.v);
      data[idx] = c1;
      data[idx + 1] = c2;
    end;
  end);
  do return data end;
end
__apparentridges_PixelMap.lambertian = function(render,light,normalize) 
  if (normalize == nil) then 
    normalize = true;
  end;
  local length = render.width * render.height;
  local this1 = ({length = length});
  local data = this1;
  local min = _G.math.huge;
  local max = -_G.math.huge;
  __apparentridges_PixelMap.raycast(render, function(h,x,y) 
    local idx = (y * render.width) + x;
    if (h == nil) then 
      data[idx] = -_G.math.huge;
    else
      local f = h.face;
      local n0 = render.mesh.normals[f[0]];
      local n1 = render.mesh.normals[f[1]];
      local n2 = render.mesh.normals[f[2]];
      local rhs = (1 - h.u) - h.v;
      local this1 = ({length = 3});
      local this1 = this1;
      this1[0] = n0[0] * rhs;
      this1[1] = n0[1] * rhs;
      this1[2] = n0[2] * rhs;
      local this1 = this1;
      local rhs = h.u;
      local this2 = ({length = 3});
      local this2 = this2;
      this2[0] = n1[0] * rhs;
      this2[1] = n1[1] * rhs;
      this2[2] = n1[2] * rhs;
      local rhs = this2;
      local this2 = ({length = 3});
      local this2 = this2;
      this2[0] = this1[0] + rhs[0];
      this2[1] = this1[1] + rhs[1];
      this2[2] = this1[2] + rhs[2];
      local this1 = this2;
      local rhs = h.v;
      local this2 = ({length = 3});
      local this2 = this2;
      this2[0] = n2[0] * rhs;
      this2[1] = n2[1] * rhs;
      this2[2] = n2[2] * rhs;
      local rhs = this2;
      local this2 = ({length = 3});
      local this2 = this2;
      this2[0] = this1[0] + rhs[0];
      this2[1] = this1[1] + rhs[1];
      this2[2] = this1[2] + rhs[2];
      local n = this2;
      local ndotl = ((n[0] * light[0]) + (n[1] * light[1])) + (n[2] * light[2]);
      min = Math.min(min, ndotl);
      max = Math.max(max, ndotl);
      data[idx] = ndotl;
    end;
  end);
  if (normalize) then 
    local _g = 0;
    local _g1 = data.length;
    while (_g < _g1) do 
      _g = _g + 1;
      local i = _g - 1;
      if (data[i] ~= -_G.math.huge) then 
        data[i] = (data[i] - min) / (max - min);
      else
        data[i] = 0;
      end;
    end;
  end;
  do return data end;
end
__apparentridges_PixelMap.ambientOcclusion = function(render,numSamples,normalize) 
  if (normalize == nil) then 
    normalize = true;
  end;
  if (numSamples == nil) then 
    numSamples = 32;
  end;
  local length = render.width * render.height;
  local this1 = ({length = length});
  local data = this1;
  local min = _G.math.huge;
  local max = -_G.math.huge;
  __apparentridges_PixelMap.raycast(render, function(h,x,y) 
    local idx = (y * render.width) + x;
    if (h == nil) then 
      data[idx] = -_G.math.huge;
    else
      local f = h.face;
      local p0 = render.mesh.vertices[f[0]];
      local p1 = render.mesh.vertices[f[1]];
      local p2 = render.mesh.vertices[f[2]];
      local rhs = (1 - h.u) - h.v;
      local this1 = ({length = 3});
      local this1 = this1;
      this1[0] = p0[0] * rhs;
      this1[1] = p0[1] * rhs;
      this1[2] = p0[2] * rhs;
      local this1 = this1;
      local rhs = h.u;
      local this2 = ({length = 3});
      local this2 = this2;
      this2[0] = p1[0] * rhs;
      this2[1] = p1[1] * rhs;
      this2[2] = p1[2] * rhs;
      local rhs = this2;
      local this2 = ({length = 3});
      local this2 = this2;
      this2[0] = this1[0] + rhs[0];
      this2[1] = this1[1] + rhs[1];
      this2[2] = this1[2] + rhs[2];
      local this1 = this2;
      local rhs = h.v;
      local this2 = ({length = 3});
      local this2 = this2;
      this2[0] = p2[0] * rhs;
      this2[1] = p2[1] * rhs;
      this2[2] = p2[2] * rhs;
      local rhs = this2;
      local this2 = ({length = 3});
      local this2 = this2;
      this2[0] = this1[0] + rhs[0];
      this2[1] = this1[1] + rhs[1];
      this2[2] = this1[2] + rhs[2];
      local o = this2;
      local cnt = 0;
      local _g = 0;
      local _g1 = numSamples;
      while (_g < _g1) do 
        _g = _g + 1;
        local i = _g - 1;
        local Xi1 = _G.math.random();
        local Xi2 = _G.math.random();
        local theta = _G.math.acos(Xi1);
        local phi = (2 * _G.math.pi) * Xi2;
        local xs = _G.math.sin(theta) * _G.math.cos(phi);
        local ys = _G.math.sin(theta) * _G.math.sin(phi);
        local zs = _G.math.cos(theta);
        local this1 = ({length = 3});
        local this1 = this1;
        this1[0] = xs;
        this1[1] = ys;
        this1[2] = zs;
        local v = this1;
        local d = v;
        if (_G.math.random() < 0.5) then 
          d[2] = -d[2];
        end;
        local r_tmin = _hx_tab_array({}, 0);
        local r_tmax = _hx_tab_array({}, 0);
        local r_o = _hx_tab_array({}, 0);
        local r_d = _hx_tab_array({}, 0);
        r_d[0] = d;
        r_o[0] = o;
        r_tmin[0] = 0.1;
        r_tmax[0] = _G.math.huge;
        local bvh = _hx_tab_array({[0]=render.mesh.bvh}, 1);
        local hitNode = _hx_tab_array({[0]=nil}, 1);
        hitNode[0] = (function(r_tmax,r_tmin,r_d,r_o,hitNode,bvh) 
          do return function(node) 
            if ((node.left == nil) and (node.right == nil)) then 
              local tmin = _G.math.huge;
              local closest = nil;
              local _g = node.begin;
              local _g1 = node["end"];
              while (_g < _g1) do 
                _g = _g + 1;
                local i = _g - 1;
                local p0 = bvh[0].mesh.vertices[bvh[0].faces[i][0]];
                local p1 = bvh[0].mesh.vertices[bvh[0].faces[i][1]];
                local p2 = bvh[0].mesh.vertices[bvh[0].faces[i][2]];
                local this1 = ({length = 3});
                local this1 = this1;
                this1[0] = p1[0] - p0[0];
                this1[1] = p1[1] - p0[1];
                this1[2] = p1[2] - p0[2];
                local e1 = this1;
                local this1 = ({length = 3});
                local this1 = this1;
                this1[0] = p2[0] - p0[0];
                this1[1] = p2[1] - p0[1];
                this1[2] = p2[2] - p0[2];
                local e2 = this1;
                local this1 = r_o[0];
                local this2 = ({length = 3});
                local this2 = this2;
                this2[0] = this1[0] - p0[0];
                this2[1] = this1[1] - p0[1];
                this2[2] = this1[2] - p0[2];
                local s = this2;
                local this1 = r_d[0];
                local this2 = ({length = 3});
                local this2 = this2;
                this2[0] = this1[0] * -1.0;
                this2[1] = this1[1] * -1.0;
                this2[2] = this1[2] * -1.0;
                local _d = this2;
                local this1 = ({length = 3});
                local this1 = this1;
                this1[0] = (e1[1] * e2[2]) - (e1[2] * e2[1]);
                this1[1] = (e1[2] * e2[0]) - (e1[0] * e2[2]);
                this1[2] = (e1[0] * e2[1]) - (e1[1] * e2[0]);
                local v1 = this1;
                local denom = ((v1[0] * _d[0]) + (v1[1] * _d[1])) + (v1[2] * _d[2]);
                local h;
                if (denom == 0) then 
                  h = nil;
                else
                  local this1 = ({length = 3});
                  local this1 = this1;
                  this1[0] = (s[1] * e2[2]) - (s[2] * e2[1]);
                  this1[1] = (s[2] * e2[0]) - (s[0] * e2[2]);
                  this1[2] = (s[0] * e2[1]) - (s[1] * e2[0]);
                  local v1 = this1;
                  local _x = ((v1[0] * _d[0]) + (v1[1] * _d[1])) + (v1[2] * _d[2]);
                  local this1 = ({length = 3});
                  local this1 = this1;
                  this1[0] = (e1[1] * s[2]) - (e1[2] * s[1]);
                  this1[1] = (e1[2] * s[0]) - (e1[0] * s[2]);
                  this1[2] = (e1[0] * s[1]) - (e1[1] * s[0]);
                  local v1 = this1;
                  local _y = ((v1[0] * _d[0]) + (v1[1] * _d[1])) + (v1[2] * _d[2]);
                  local this1 = ({length = 3});
                  local this1 = this1;
                  this1[0] = (e1[1] * e2[2]) - (e1[2] * e2[1]);
                  this1[1] = (e1[2] * e2[0]) - (e1[0] * e2[2]);
                  this1[2] = (e1[0] * e2[1]) - (e1[1] * e2[0]);
                  local v1 = this1;
                  local _z = ((v1[0] * s[0]) + (v1[1] * s[1])) + (v1[2] * s[2]);
                  local this1 = ({length = 3});
                  local this1 = this1;
                  this1[0] = _x;
                  this1[1] = _y;
                  this1[2] = _z;
                  local this1 = this1;
                  local rhs = 1 / denom;
                  local this2 = ({length = 3});
                  local this2 = this2;
                  this2[0] = this1[0] * rhs;
                  this2[1] = this1[1] * rhs;
                  this2[2] = this1[2] * rhs;
                  local uvt = this2;
                  local u = uvt[0];
                  local v = uvt[1];
                  local t = uvt[2];
                  if (((((u < 0) or (v < 0)) or (((1 - u) - v) < 0)) or (t < r_tmin[0])) or (t > r_tmax[0])) then 
                    h = nil;
                  else
                    local h1 = __apparentridges_RayHit.new(t);
                    h1.u = u;
                    h1.v = v;
                    h = h1;
                  end;
                end;
                if (h ~= nil) then 
                  h.face = bvh[0].faces[i];
                  if (tmin > h.t) then 
                    tmin = h.t;
                    closest = h;
                  end;
                end;
              end;
              do return closest end;
            end;
            local bb = node.left.bbox;
            local tx1 = (bb.min[0] - r_o[0][0]) / r_d[0][0];
            local tx2 = (bb.max[0] - r_o[0][0]) / r_d[0][0];
            local ty1 = (bb.min[1] - r_o[0][1]) / r_d[0][1];
            local ty2 = (bb.max[1] - r_o[0][1]) / r_d[0][1];
            local tz1 = (bb.min[2] - r_o[0][2]) / r_d[0][2];
            local tz2 = (bb.max[2] - r_o[0][2]) / r_d[0][2];
            local t1 = Math.max(Math.max(Math.min(tx1, tx2), Math.min(ty1, ty2)), Math.min(tz1, tz2));
            local t2 = Math.min(Math.min(Math.max(tx1, tx2), Math.max(ty1, ty2)), Math.max(tz1, tz2));
            local hitL;
            if ((t2 - t1) < 0) then 
              hitL = nil;
            else
              if ((t1 > r_tmax[0]) or (t2 < r_tmin[0])) then 
                hitL = nil;
              else
                local h = __apparentridges_RayHit.new(t1);
                h.t2 = t2;
                hitL = h;
              end;
            end;
            local bb = node.right.bbox;
            local tx1 = (bb.min[0] - r_o[0][0]) / r_d[0][0];
            local tx2 = (bb.max[0] - r_o[0][0]) / r_d[0][0];
            local ty1 = (bb.min[1] - r_o[0][1]) / r_d[0][1];
            local ty2 = (bb.max[1] - r_o[0][1]) / r_d[0][1];
            local tz1 = (bb.min[2] - r_o[0][2]) / r_d[0][2];
            local tz2 = (bb.max[2] - r_o[0][2]) / r_d[0][2];
            local t1 = Math.max(Math.max(Math.min(tx1, tx2), Math.min(ty1, ty2)), Math.min(tz1, tz2));
            local t2 = Math.min(Math.min(Math.max(tx1, tx2), Math.max(ty1, ty2)), Math.max(tz1, tz2));
            local hitR;
            if ((t2 - t1) < 0) then 
              hitR = nil;
            else
              if ((t1 > r_tmax[0]) or (t2 < r_tmin[0])) then 
                hitR = nil;
              else
                local h = __apparentridges_RayHit.new(t1);
                h.t2 = t2;
                hitR = h;
              end;
            end;
            if ((hitL ~= nil) and (hitR == nil)) then 
              do return hitNode[0](node.left) end;
            else
              if ((hitL == nil) and (hitR ~= nil)) then 
                do return hitNode[0](node.right) end;
              else
                if ((hitL == nil) and (hitR == nil)) then 
                  do return nil end;
                end;
              end;
            end;
            local first;
            local second;
            if (hitL.t < hitR.t) then 
              first = node.left;
              second = node.right;
            else
              first = node.right;
              second = node.left;
            end;
            local h = hitNode[0](first);
            if ((h == nil) or (h.t >= Math.max(hitL.t, hitR.t))) then 
              local h2 = hitNode[0](second);
              if (h2 ~= nil) then 
                if ((h == nil) or (h2.t < h.t)) then 
                  do return h2 end;
                end;
              end;
            end;
            do return h end;
          end end;
        end)(r_tmax, r_tmin, r_d, r_o, hitNode, bvh);
        local h = hitNode[0](bvh[0].root);
        if (h ~= nil) then 
          cnt = cnt + 1;
        end;
      end;
      local v = 1 - (cnt / numSamples);
      min = Math.min(min, v);
      max = Math.max(max, v);
      data[idx] = v;
    end;
  end);
  if (normalize) then 
    local _g = 0;
    local _g1 = data.length;
    while (_g < _g1) do 
      _g = _g + 1;
      local i = _g - 1;
      if (data[i] ~= -_G.math.huge) then 
        data[i] = (data[i] - min) / (max - min);
      else
        data[i] = 0;
      end;
    end;
  end;
  do return data end;
end
__apparentridges_PixelMap.toPPMString = function(data,w,h,min,max) 
  local chan = Std.int(data.length / (w * h));
  local out_b = ({});
  local out_length = 0;
  local str = Std.string(Std.string(Std.string(Std.string(Std.string("P3\n") .. Std.string(w)) .. Std.string(" ")) .. Std.string(h)) .. Std.string("\n255\n"));
  _G.table.insert(out_b, str);
  out_length = out_length + #str;
  local _g = 0;
  local _g1 = Std.int(data.length / chan);
  while (_g < _g1) do 
    _g = _g + 1;
    local i = _g - 1;
    local u = Std.int(Math.min(Math.max(((data[i * chan] - min) / (max - min)) * 255, 0), 255));
    local v = (function() 
      local _hx_1
      if (chan == 1) then 
      _hx_1 = u; else 
      _hx_1 = Std.int(Math.min(Math.max(((data[(i * chan) + 1] - min) / (max - min)) * 255, 0), 255)); end
      return _hx_1
    end )();
    local w = (function() 
      local _hx_2
      if (chan == 1) then 
      _hx_2 = u; elseif (chan == 2) then 
      _hx_2 = 128; else 
      _hx_2 = Std.int(Math.min(Math.max(((data[(i * chan) + 2] - min) / (max - min)) * 255, 0), 255)); end
      return _hx_2
    end )();
    local str = Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string("") .. Std.string(u)) .. Std.string(" ")) .. Std.string(v)) .. Std.string(" ")) .. Std.string(w)) .. Std.string(" "));
    _G.table.insert(out_b, str);
    out_length = out_length + #str;
  end;
  do return _G.table.concat(out_b) end;
end

__apparentridges_SVGWriter.new = {}
_hx_exports["apparentridges"]["SVGWriter"] = __apparentridges_SVGWriter
__apparentridges_SVGWriter.__name__ = true
__apparentridges_SVGWriter.rd = function(x) 
  do return _G.math.floor((x * 100) + 0.5) / 100 end;
end
__apparentridges_SVGWriter.lines = function(render,useOpacity) 
  if (useOpacity == nil) then 
    useOpacity = true;
  end;
  local w = render.width;
  local h = render.height;
  local out_b = ({});
  local out_length = 0;
  local str = Std.string(Std.string(Std.string(Std.string(Std.string("<svg version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" width=\"") .. Std.string(w)) .. Std.string("\" height=\"")) .. Std.string(h)) .. Std.string("\">\n"));
  _G.table.insert(out_b, str);
  out_length = out_length + #str;
  local _g = 0;
  local _g1 = render.lines.length;
  while (_g < _g1) do 
    _g = _g + 1;
    local i = _g - 1;
    local x1 = _G.math.floor((render.lines[i].x1 * 100) + 0.5) / 100;
    local y1 = _G.math.floor((render.lines[i].y1 * 100) + 0.5) / 100;
    local x2 = _G.math.floor((render.lines[i].x2 * 100) + 0.5) / 100;
    local y2 = _G.math.floor((render.lines[i].y2 * 100) + 0.5) / 100;
    local o = (function() 
      local _hx_1
      if (useOpacity) then 
      _hx_1 = (render.lines[i].opacity1 + render.lines[i].opacity2) / 2; else 
      _hx_1 = 1; end
      return _hx_1
    end )();
    local oi = Std.int(255 - (o * 255));
    local str = Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string("  <line x1=\"") .. Std.string(x1)) .. Std.string("\" y1=\"")) .. Std.string(y1)) .. Std.string("\" x2=\"")) .. Std.string(x2)) .. Std.string("\" y2=\"")) .. Std.string(y2)) .. Std.string("\" fill=\"none\" stroke=\"rgb(")) .. Std.string(oi)) .. Std.string(",")) .. Std.string(oi)) .. Std.string(",")) .. Std.string(oi)) .. Std.string(")\" stroke-width=\"1\" stroke-linecap=\"round\"/>\n"));
    _G.table.insert(out_b, str);
    out_length = out_length + #str;
  end;
  local str = "</svg>\n";
  _G.table.insert(out_b, str);
  out_length = out_length + #str;
  do return _G.table.concat(out_b) end;
end
__apparentridges_SVGWriter.polylines = function(render,colorful) 
  if (colorful == nil) then 
    colorful = false;
  end;
  local w = render.width;
  local h = render.height;
  local out_b = ({});
  local out_length = 0;
  local str = Std.string(Std.string(Std.string(Std.string(Std.string("<svg version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" width=\"") .. Std.string(w)) .. Std.string("\" height=\"")) .. Std.string(h)) .. Std.string("\">\n"));
  _G.table.insert(out_b, str);
  out_length = out_length + #str;
  local color = "black";
  local _g = 0;
  local _g1 = render.polylines.length;
  while (_g < _g1) do 
    _g = _g + 1;
    local i = _g - 1;
    local str = "  <polyline points=\"";
    _G.table.insert(out_b, str);
    out_length = out_length + #str;
    local _g = 0;
    local _g1 = render.polylines[i].length;
    while (_g < _g1) do 
      _g = _g + 1;
      local j = _g - 1;
      local p = render.polylines[i][j];
      local str = Std.string(Std.string(Std.string(Std.string(Std.string("") .. Std.string(_G.math.floor((p[0] * 100) + 0.5) / 100)) .. Std.string(",")) .. Std.string(_G.math.floor((p[1] * 100) + 0.5) / 100)) .. Std.string(" "));
      _G.table.insert(out_b, str);
      out_length = out_length + #str;
    end;
    if (colorful) then 
      color = Std.string(Std.string(Std.string(Std.string(Std.string(Std.string("rgb(") .. Std.string(Std.int(_G.math.random() * 128))) .. Std.string(",")) .. Std.string(Std.int(_G.math.random() * 128))) .. Std.string(",")) .. Std.string(Std.int(_G.math.random() * 128))) .. Std.string(")");
    end;
    local str = Std.string(Std.string(Std.string("\" fill=\"none\" stroke=\"") .. Std.string(color)) .. Std.string("\" stroke-width=\"1\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/>\n"));
    _G.table.insert(out_b, str);
    out_length = out_length + #str;
  end;
  local str = "</svg>\n";
  _G.table.insert(out_b, str);
  out_length = out_length + #str;
  do return _G.table.concat(out_b) end;
end
__apparentridges_SVGWriter.gradients = function(render,acc) 
  if (acc == nil) then 
    acc = 1;
  end;
  local w = render.width;
  local h = render.height;
  local out_b = ({});
  local out_length = 0;
  local str = Std.string(Std.string(Std.string(Std.string(Std.string("<svg version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" width=\"") .. Std.string(w)) .. Std.string("\" height=\"")) .. Std.string(h)) .. Std.string("\">\n"));
  _G.table.insert(out_b, str);
  out_length = out_length + #str;
  local gid = 0;
  local _g = 0;
  local _g1 = render.polylines.length;
  while (_g < _g1) do 
    _g = _g + 1;
    local i = _g - 1;
    local _g = 0;
    local _g1 = render.polylines[i].length;
    while (_g < _g1) do 
      _g = _g + 1;
      local j = _g - 1;
      local p = render.polylines[i][j];
      local oi = Std.int(255 - (p[2] * 255));
      local str = Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string("  <circle cx=\"") .. Std.string(_G.math.floor((p[0] * 100) + 0.5) / 100)) .. Std.string("\" cy=\"")) .. Std.string(_G.math.floor((p[1] * 100) + 0.5) / 100)) .. Std.string("\" r=\"0.5\" stroke=\"none\" fill=\"rgb(")) .. Std.string(oi)) .. Std.string(",")) .. Std.string(oi)) .. Std.string(",")) .. Std.string(oi)) .. Std.string(")\"/>\n"));
      _G.table.insert(out_b, str);
      out_length = out_length + #str;
    end;
  end;
  local _g = 0;
  local _g1 = render.polylines.length;
  while (_g < _g1) do 
    _g = _g + 1;
    local i = _g - 1;
    local str = "  <g fill=\"none\" stroke-width=\"1\">\n";
    _G.table.insert(out_b, str);
    out_length = out_length + #str;
    local _g = 0;
    local _g1 = render.polylines[i].length - 1;
    while (_g < _g1) do 
      _g = _g + 1;
      local j = _g - 1;
      local p = render.polylines[i][j];
      local q = render.polylines[i][j + 1];
      local d = Std.int((_G.math.abs(p[2] - q[2]) * 10) * acc) + 1;
      local _g = 0;
      local _g1 = d;
      while (_g < _g1) do 
        _g = _g + 1;
        local k = _g - 1;
        local t = (k / d) - 0.01;
        local s = ((k + 1) / d) + 0.01;
        local rhs = 1 - t;
        local this1 = ({length = 3});
        local this1 = this1;
        this1[0] = p[0] * rhs;
        this1[1] = p[1] * rhs;
        this1[2] = p[2] * rhs;
        local this1 = this1;
        local this2 = ({length = 3});
        local this2 = this2;
        this2[0] = q[0] * t;
        this2[1] = q[1] * t;
        this2[2] = q[2] * t;
        local rhs = this2;
        local this2 = ({length = 3});
        local this2 = this2;
        this2[0] = this1[0] + rhs[0];
        this2[1] = this1[1] + rhs[1];
        this2[2] = this1[2] + rhs[2];
        local a = this2;
        local rhs = 1 - s;
        local this1 = ({length = 3});
        local this1 = this1;
        this1[0] = p[0] * rhs;
        this1[1] = p[1] * rhs;
        this1[2] = p[2] * rhs;
        local this1 = this1;
        local this2 = ({length = 3});
        local this2 = this2;
        this2[0] = q[0] * s;
        this2[1] = q[1] * s;
        this2[2] = q[2] * s;
        local rhs = this2;
        local this2 = ({length = 3});
        local this2 = this2;
        this2[0] = this1[0] + rhs[0];
        this2[1] = this1[1] + rhs[1];
        this2[2] = this1[2] + rhs[2];
        local b = this2;
        local o = (a[2] + b[2]) / 2;
        local oi = Std.int(255 - (o * 255));
        local str = Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string("    <line x1=\"") .. Std.string(_G.math.floor((a[0] * 100) + 0.5) / 100)) .. Std.string("\" y1=\"")) .. Std.string(_G.math.floor((a[1] * 100) + 0.5) / 100)) .. Std.string("\" x2=\"")) .. Std.string(_G.math.floor((b[0] * 100) + 0.5) / 100)) .. Std.string("\" y2=\"")) .. Std.string(_G.math.floor((b[1] * 100) + 0.5) / 100)) .. Std.string("\" stroke=\"rgb(")) .. Std.string(oi)) .. Std.string(",")) .. Std.string(oi)) .. Std.string(",")) .. Std.string(oi)) .. Std.string(")\"/>\n"));
        _G.table.insert(out_b, str);
        out_length = out_length + #str;
      end;
      gid = gid + 1;
    end;
    local str = "  </g>\n";
    _G.table.insert(out_b, str);
    out_length = out_length + #str;
  end;
  local str = "</svg>\n";
  _G.table.insert(out_b, str);
  out_length = out_length + #str;
  do return _G.table.concat(out_b) end;
end

__haxe_Exception.new = function(message,previous,native) 
  local self = _hx_new(__haxe_Exception.prototype)
  __haxe_Exception.super(self,message,previous,native)
  return self
end
__haxe_Exception.super = function(self,message,previous,native) 
  self.__skipStack = 0;
  self.__exceptionMessage = message;
  self.__previousException = previous;
  if (native ~= nil) then 
    self.__nativeException = native;
    self.__nativeStack = __haxe_NativeStackTrace.exceptionStack();
  else
    self.__nativeException = self;
    self.__nativeStack = __haxe_NativeStackTrace.callStack();
    self.__skipStack = 1;
  end;
end
__haxe_Exception.__name__ = true
__haxe_Exception.thrown = function(value) 
  if (__lua_Boot.__instanceof(value, __haxe_Exception)) then 
    do return value:get_native() end;
  else
    local e = __haxe_ValueException.new(value);
    e.__skipStack = e.__skipStack + 1;
    do return e end;
  end;
end
__haxe_Exception.prototype = _hx_e();
__haxe_Exception.prototype.get_native = function(self) 
  do return self.__nativeException end
end

__haxe_Exception.prototype.__class__ =  __haxe_Exception

__haxe_Log.new = {}
__haxe_Log.__name__ = true
__haxe_Log.formatOutput = function(v,infos) 
  local str = Std.string(v);
  if (infos == nil) then 
    do return str end;
  end;
  local pstr = Std.string(Std.string(infos.fileName) .. Std.string(":")) .. Std.string(infos.lineNumber);
  if (infos.customParams ~= nil) then 
    local _g = 0;
    local _g1 = infos.customParams;
    while (_g < _g1.length) do 
      local v = _g1[_g];
      _g = _g + 1;
      str = Std.string(str) .. Std.string((Std.string(", ") .. Std.string(Std.string(v))));
    end;
  end;
  do return Std.string(Std.string(pstr) .. Std.string(": ")) .. Std.string(str) end;
end
__haxe_Log.trace = function(v,infos) 
  local str = __haxe_Log.formatOutput(v, infos);
  _hx_print(str);
end

__haxe_NativeStackTrace.new = {}
__haxe_NativeStackTrace.__name__ = true
__haxe_NativeStackTrace.saveStack = function(exception) 
end
__haxe_NativeStackTrace.callStack = function() 
  local _g = debug.traceback();
  if (_g == nil) then 
    do return _hx_tab_array({}, 0) end;
  else
    local s = _g;
    local idx = 1;
    local ret = _hx_tab_array({}, 0);
    while (idx ~= nil) do 
      local newidx = 0;
      if (#"\n" > 0) then 
        newidx = _G.string.find(s, "\n", idx, true);
      else
        if (idx >= #s) then 
          newidx = nil;
        else
          newidx = idx + 1;
        end;
      end;
      if (newidx ~= nil) then 
        local match = _G.string.sub(s, idx, newidx - 1);
        ret:push(match);
        idx = newidx + #"\n";
      else
        ret:push(_G.string.sub(s, idx, #s));
        idx = nil;
      end;
    end;
    do return ret:slice(3) end;
  end;
end
__haxe_NativeStackTrace.exceptionStack = function() 
  do return _hx_tab_array({}, 0) end;
end

__haxe_ValueException.new = function(value,previous,native) 
  local self = _hx_new(__haxe_ValueException.prototype)
  __haxe_ValueException.super(self,value,previous,native)
  return self
end
__haxe_ValueException.super = function(self,value,previous,native) 
  __haxe_Exception.super(self,Std.string(value),previous,native);
  self.value = value;
end
__haxe_ValueException.__name__ = true
__haxe_ValueException.prototype = _hx_e();

__haxe_ValueException.prototype.__class__ =  __haxe_ValueException
__haxe_ValueException.__super__ = __haxe_Exception
setmetatable(__haxe_ValueException.prototype,{__index=__haxe_Exception.prototype})

__haxe_io_Bytes.new = function(length,b) 
  local self = _hx_new(__haxe_io_Bytes.prototype)
  __haxe_io_Bytes.super(self,length,b)
  return self
end
__haxe_io_Bytes.super = function(self,length,b) 
  self.length = length;
  self.b = b;
end
__haxe_io_Bytes.__name__ = true
__haxe_io_Bytes.ofString = function(s,encoding) 
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = _G.string.len(s);
  while (_g1 < _g2) do 
    _g1 = _g1 + 1;
    local i = _g1 - 1;
    _g:push(_G.string.byte(s, i + 1));
  end;
  local bytes = _g;
  do return __haxe_io_Bytes.new(bytes.length, bytes) end;
end
__haxe_io_Bytes.prototype = _hx_e();
__haxe_io_Bytes.prototype.getString = function(self,pos,len,encoding) 
  local tmp = encoding == nil;
  if (((pos < 0) or (len < 0)) or ((pos + len) > self.length)) then 
    _G.error(__haxe_Exception.thrown(__haxe_io_Error.OutsideBounds),0);
  end;
  if ((self.b.length - pos) <= __lua_Boot.MAXSTACKSIZE) then 
    local _end = Math.min(self.b.length, pos + len) - 1;
    do return _G.string.char(_hx_table.unpack(self.b, pos, _end)) end;
  else
    local tbl = ({});
    local _g = pos;
    local _g1 = pos + len;
    while (_g < _g1) do 
      _g = _g + 1;
      local idx = _g - 1;
      _G.table.insert(tbl, _G.string.char(self.b[idx]));
    end;
    do return _G.table.concat(tbl, "") end;
  end;
end

__haxe_io_Bytes.prototype.__class__ =  __haxe_io_Bytes
_hxClasses["haxe.io.Encoding"] = { __ename__ = true, __constructs__ = _hx_tab_array({[0]="UTF8","RawNative"},2)}
__haxe_io_Encoding = _hxClasses["haxe.io.Encoding"];
__haxe_io_Encoding.UTF8 = _hx_tab_array({[0]="UTF8",0,__enum__ = __haxe_io_Encoding},2)

__haxe_io_Encoding.RawNative = _hx_tab_array({[0]="RawNative",1,__enum__ = __haxe_io_Encoding},2)

_hxClasses["haxe.io.Error"] = { __ename__ = true, __constructs__ = _hx_tab_array({[0]="Blocked","Overflow","OutsideBounds","Custom"},4)}
__haxe_io_Error = _hxClasses["haxe.io.Error"];
__haxe_io_Error.Blocked = _hx_tab_array({[0]="Blocked",0,__enum__ = __haxe_io_Error},2)

__haxe_io_Error.Overflow = _hx_tab_array({[0]="Overflow",1,__enum__ = __haxe_io_Error},2)

__haxe_io_Error.OutsideBounds = _hx_tab_array({[0]="OutsideBounds",2,__enum__ = __haxe_io_Error},2)

__haxe_io_Error.Custom = function(e) local _x = _hx_tab_array({[0]="Custom",3,e,__enum__=__haxe_io_Error}, 3); return _x; end 

__haxe_io_Output.new = {}
__haxe_io_Output.__name__ = true
__haxe_io_Output.prototype = _hx_e();
__haxe_io_Output.prototype.writeByte = function(self,c) 
  _G.error(__haxe_Exception.thrown("Not implemented"),0);
end
__haxe_io_Output.prototype.writeBytes = function(self,s,pos,len) 
  if (((pos < 0) or (len < 0)) or ((pos + len) > s.length)) then 
    _G.error(__haxe_Exception.thrown(__haxe_io_Error.OutsideBounds),0);
  end;
  local b = s.b;
  local k = len;
  while (k > 0) do 
    self:writeByte(b[pos]);
    pos = pos + 1;
    k = k - 1;
  end;
  do return len end
end
__haxe_io_Output.prototype.writeFullBytes = function(self,s,pos,len) 
  while (len > 0) do 
    local k = self:writeBytes(s, pos, len);
    pos = pos + k;
    len = len - k;
  end;
end
__haxe_io_Output.prototype.writeString = function(self,s,encoding) 
  local b = __haxe_io_Bytes.ofString(s, encoding);
  self:writeFullBytes(b, 0, b.length);
end

__haxe_io_Output.prototype.__class__ =  __haxe_io_Output

__haxe_iterators_ArrayIterator.new = function(array) 
  local self = _hx_new(__haxe_iterators_ArrayIterator.prototype)
  __haxe_iterators_ArrayIterator.super(self,array)
  return self
end
__haxe_iterators_ArrayIterator.super = function(self,array) 
  self.current = 0;
  self.array = array;
end
__haxe_iterators_ArrayIterator.__name__ = true
__haxe_iterators_ArrayIterator.prototype = _hx_e();
__haxe_iterators_ArrayIterator.prototype.hasNext = function(self) 
  do return self.current < self.array.length end
end
__haxe_iterators_ArrayIterator.prototype.next = function(self) 
  do return self.array[(function() 
  local _hx_obj = self;
  local _hx_fld = 'current';
  local _ = _hx_obj[_hx_fld];
  _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
   return _;
   end)()] end
end

__haxe_iterators_ArrayIterator.prototype.__class__ =  __haxe_iterators_ArrayIterator

__haxe_iterators_ArrayKeyValueIterator.new = function(array) 
  local self = _hx_new(__haxe_iterators_ArrayKeyValueIterator.prototype)
  __haxe_iterators_ArrayKeyValueIterator.super(self,array)
  return self
end
__haxe_iterators_ArrayKeyValueIterator.super = function(self,array) 
  self.array = array;
end
__haxe_iterators_ArrayKeyValueIterator.__name__ = true
__haxe_iterators_ArrayKeyValueIterator.prototype = _hx_e();

__haxe_iterators_ArrayKeyValueIterator.prototype.__class__ =  __haxe_iterators_ArrayKeyValueIterator

__lua_Boot.new = {}
__lua_Boot.__name__ = true
__lua_Boot.__instanceof = function(o,cl) 
  if (cl == nil) then 
    do return false end;
  end;
  local cl1 = cl;
  if (cl1) == Array then 
    do return __lua_Boot.isArray(o) end;
  elseif (cl1) == Bool then 
    do return _G.type(o) == "boolean" end;
  elseif (cl1) == Dynamic then 
    do return o ~= nil end;
  elseif (cl1) == Float then 
    do return _G.type(o) == "number" end;
  elseif (cl1) == Int then 
    if (_G.type(o) == "number") then 
      do return _hx_bit_clamp(o) == o end;
    else
      do return false end;
    end;
  elseif (cl1) == String then 
    do return _G.type(o) == "string" end;
  elseif (cl1) == _G.table then 
    do return _G.type(o) == "table" end;
  elseif (cl1) == __lua_Thread then 
    do return _G.type(o) == "thread" end;
  elseif (cl1) == __lua_UserData then 
    do return _G.type(o) == "userdata" end;else
  if (((o ~= nil) and (_G.type(o) == "table")) and (_G.type(cl) == "table")) then 
    local tmp;
    if (__lua_Boot.__instanceof(o, Array)) then 
      tmp = Array;
    else
      if (__lua_Boot.__instanceof(o, String)) then 
        tmp = String;
      else
        local cl = o.__class__;
        tmp = (function() 
          local _hx_1
          if (cl ~= nil) then 
          _hx_1 = cl; else 
          _hx_1 = nil; end
          return _hx_1
        end )();
      end;
    end;
    if (__lua_Boot.extendsOrImplements(tmp, cl)) then 
      do return true end;
    end;
    if ((function() 
      local _hx_2
      if (cl == Class) then 
      _hx_2 = o.__name__ ~= nil; else 
      _hx_2 = false; end
      return _hx_2
    end )()) then 
      do return true end;
    end;
    if ((function() 
      local _hx_3
      if (cl == Enum) then 
      _hx_3 = o.__ename__ ~= nil; else 
      _hx_3 = false; end
      return _hx_3
    end )()) then 
      do return true end;
    end;
    do return o.__enum__ == cl end;
  else
    do return false end;
  end; end;
end
__lua_Boot.isArray = function(o) 
  if (_G.type(o) == "table") then 
    if ((o.__enum__ == nil) and (_G.getmetatable(o) ~= nil)) then 
      do return _G.getmetatable(o).__index == Array.prototype end;
    else
      do return false end;
    end;
  else
    do return false end;
  end;
end
__lua_Boot.extendsOrImplements = function(cl1,cl2) 
  if ((cl1 == nil) or (cl2 == nil)) then 
    do return false end;
  else
    if (cl1 == cl2) then 
      do return true end;
    else
      if (cl1.__interfaces__ ~= nil) then 
        local intf = cl1.__interfaces__;
        local _g = 1;
        local _g1 = _hx_table.maxn(intf) + 1;
        while (_g < _g1) do 
          _g = _g + 1;
          local i = _g - 1;
          if (__lua_Boot.extendsOrImplements(intf[i], cl2)) then 
            do return true end;
          end;
        end;
      end;
    end;
  end;
  do return __lua_Boot.extendsOrImplements(cl1.__super__, cl2) end;
end

__lua_UserData.new = {}
__lua_UserData.__name__ = true

__lua_Thread.new = {}
__lua_Thread.__name__ = true

__sys_io_File.new = {}
__sys_io_File.__name__ = true
__sys_io_File.getContent = function(path) 
  local f = _G.io.open(path, "r");
  if (f == nil) then 
    _G.error(__haxe_Exception.thrown(Std.string("Invalid path : ") .. Std.string(path)),0);
  end;
  local s = f:read("*all");
  f:close();
  do return s end;
end
__sys_io_File.write = function(path,binary) 
  if (binary == nil) then 
    binary = true;
  end;
  local fh = _G.io.open(path, (function() 
    local _hx_1
    if (binary) then 
    _hx_1 = "wb"; else 
    _hx_1 = "w"; end
    return _hx_1
  end )());
  if (fh == nil) then 
    _G.error(__haxe_Exception.thrown(Std.string("Invalid path : ") .. Std.string(path)),0);
  end;
  do return __sys_io_FileOutput.new(fh) end;
end
__sys_io_File.saveContent = function(path,content) 
  local f = __sys_io_File.write(path, true);
  f:writeString(content);
  f:close();
end

__sys_io_FileOutput.new = function(f) 
  local self = _hx_new(__sys_io_FileOutput.prototype)
  __sys_io_FileOutput.super(self,f)
  return self
end
__sys_io_FileOutput.super = function(self,f) 
  if (f == nil) then 
    _G.error(__haxe_Exception.thrown(Std.string("Invalid filehandle : ") .. Std.string(Std.string(f))),0);
  end;
  self.f = f;
end
__sys_io_FileOutput.__name__ = true
__sys_io_FileOutput.prototype = _hx_e();
__sys_io_FileOutput.prototype.writeByte = function(self,c) 
  self.f:write(_G.string.char(c));
end
__sys_io_FileOutput.prototype.writeBytes = function(self,s,pos,len) 
  self.f:write(s:getString(pos, len));
  do return s.length end
end
__sys_io_FileOutput.prototype.close = function(self) 
  self.f:close();
end

__sys_io_FileOutput.prototype.__class__ =  __sys_io_FileOutput
__sys_io_FileOutput.__super__ = __haxe_io_Output
setmetatable(__sys_io_FileOutput.prototype,{__index=__haxe_io_Output.prototype})
if _hx_bit_raw then
    _hx_bit_clamp = function(v)
    if v <= 2147483647 and v >= -2147483648 then
        if v > 0 then return _G.math.floor(v)
        else return _G.math.ceil(v)
        end
    end
    if v > 2251798999999999 then v = v*2 end;
    if (v ~= v or math.abs(v) == _G.math.huge) then return nil end
    return _hx_bit_raw.band(v, 2147483647 ) - math.abs(_hx_bit_raw.band(v, 2147483648))
    end
else
    _hx_bit_clamp = function(v)
        if v < -2147483648 then
            return -2147483648
        elseif v > 2147483647 then
            return 2147483647
        elseif v > 0 then
            return _G.math.floor(v)
        else
            return _G.math.ceil(v)
        end
    end
end;



_hx_array_mt.__index = Array.prototype

local _hx_static_init = function()
  
  String.__name__ = true;
  Array.__name__ = true;__lua_Boot.MAXSTACKSIZE = 1000;
  
  
end

_G.math.randomseed(_G.os.time());

_hx_print = print or (function() end)

_hx_table = {}
_hx_table.pack = _G.table.pack or function(...)
    return {...}
end
_hx_table.unpack = _G.table.unpack or _G.unpack
_hx_table.maxn = _G.table.maxn or function(t)
  local maxn=0;
  for i in pairs(t) do
    maxn=type(i)=='number'and i>maxn and i or maxn
  end
  return maxn
end;

_hx_static_init();
return _hx_exports
